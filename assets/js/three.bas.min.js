!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],n):n(e.BAS={},e.THREE)}(this,function(e,n){"use strict";function t(e,t){n.ShaderMaterial.call(this);var r=e.uniformValues;if(delete e.uniformValues,this.setValues(e),this.uniforms=n.UniformsUtils.merge([t,this.uniforms]),this.setUniformValues(r),r&&(r.map&&(this.defines.USE_MAP=""),r.normalMap&&(this.defines.USE_NORMALMAP=""),r.envMap&&(this.defines.USE_ENVMAP=""),r.aoMap&&(this.defines.USE_AOMAP=""),r.specularMap&&(this.defines.USE_SPECULARMAP=""),r.alphaMap&&(this.defines.USE_ALPHAMAP=""),r.lightMap&&(this.defines.USE_LIGHTMAP=""),r.emissiveMap&&(this.defines.USE_EMISSIVEMAP=""),r.bumpMap&&(this.defines.USE_BUMPMAP=""),r.displacementMap&&(this.defines.USE_DISPLACEMENTMAP=""),r.roughnessMap&&(this.defines.USE_DISPLACEMENTMAP=""),r.roughnessMap&&(this.defines.USE_ROUGHNESSMAP=""),r.metalnessMap&&(this.defines.USE_METALNESSMAP=""),r.envMap)){this.defines.USE_ENVMAP="";var i="ENVMAP_TYPE_CUBE",a="ENVMAP_MODE_REFLECTION",o="ENVMAP_BLENDING_MULTIPLY";switch(r.envMap.mapping){case n.CubeReflectionMapping:case n.CubeRefractionMapping:i="ENVMAP_TYPE_CUBE";break;case n.CubeUVReflectionMapping:case n.CubeUVRefractionMapping:i="ENVMAP_TYPE_CUBE_UV";break;case n.EquirectangularReflectionMapping:case n.EquirectangularRefractionMapping:i="ENVMAP_TYPE_EQUIREC";break;case n.SphericalReflectionMapping:i="ENVMAP_TYPE_SPHERE"}switch(r.envMap.mapping){case n.CubeRefractionMapping:case n.EquirectangularRefractionMapping:a="ENVMAP_MODE_REFRACTION"}switch(r.combine){case n.MixOperation:o="ENVMAP_BLENDING_MIX";break;case n.AddOperation:o="ENVMAP_BLENDING_ADD";break;case n.MultiplyOperation:default:o="ENVMAP_BLENDING_MULTIPLY"}this.defines[i]="",this.defines[o]="",this.defines[a]=""}}function r(e){this.varyingParameters=[],this.vertexParameters=[],this.vertexFunctions=[],this.vertexInit=[],this.vertexNormal=[],this.vertexPosition=[],this.vertexColor=[],this.vertexPostMorph=[],this.vertexPostSkinning=[],this.fragmentFunctions=[],this.fragmentParameters=[],this.fragmentInit=[],this.fragmentMap=[],this.fragmentDiffuse=[],t.call(this,e,n.ShaderLib.basic.uniforms),this.lights=!1,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}function i(e){this.varyingParameters=[],this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexNormal=[],this.vertexPosition=[],this.vertexColor=[],this.vertexPostMorph=[],this.vertexPostSkinning=[],this.fragmentFunctions=[],this.fragmentParameters=[],this.fragmentInit=[],this.fragmentMap=[],this.fragmentDiffuse=[],this.fragmentEmissive=[],this.fragmentSpecular=[],t.call(this,e,n.ShaderLib.lambert.uniforms),this.lights=!0,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}function a(e){this.varyingParameters=[],this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexNormal=[],this.vertexPosition=[],this.vertexColor=[],this.fragmentFunctions=[],this.fragmentParameters=[],this.fragmentInit=[],this.fragmentMap=[],this.fragmentDiffuse=[],this.fragmentEmissive=[],this.fragmentSpecular=[],t.call(this,e,n.ShaderLib.phong.uniforms),this.lights=!0,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}function o(e){this.varyingParameters=[],this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexNormal=[],this.vertexPosition=[],this.vertexColor=[],this.vertexPostMorph=[],this.vertexPostSkinning=[],this.fragmentFunctions=[],this.fragmentParameters=[],this.fragmentInit=[],this.fragmentMap=[],this.fragmentDiffuse=[],this.fragmentRoughness=[],this.fragmentMetalness=[],this.fragmentEmissive=[],t.call(this,e,n.ShaderLib.standard.uniforms),this.lights=!0,this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}function s(e){this.varyingParameters=[],this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexPosition=[],this.vertexColor=[],this.fragmentFunctions=[],this.fragmentParameters=[],this.fragmentInit=[],this.fragmentMap=[],this.fragmentDiffuse=[],this.fragmentShape=[],t.call(this,e,n.ShaderLib.points.uniforms),this.vertexShader=this.concatVertexShader(),this.fragmentShader=this.concatFragmentShader()}function f(e){this.depthPacking=n.RGBADepthPacking,this.clipping=!0,this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexPosition=[],this.vertexPostMorph=[],this.vertexPostSkinning=[],t.call(this,e),this.uniforms=n.UniformsUtils.merge([n.ShaderLib.depth.uniforms,this.uniforms]),this.vertexShader=this.concatVertexShader(),this.fragmentShader=n.ShaderLib.depth.fragmentShader}function l(e){this.depthPacking=n.RGBADepthPacking,this.clipping=!0,this.vertexFunctions=[],this.vertexParameters=[],this.vertexInit=[],this.vertexPosition=[],this.vertexPostMorph=[],this.vertexPostSkinning=[],t.call(this,e),this.uniforms=n.UniformsUtils.merge([n.ShaderLib.distanceRGBA.uniforms,this.uniforms]),this.vertexShader=this.concatVertexShader(),this.fragmentShader=n.ShaderLib.distanceRGBA.fragmentShader}function c(e,t){n.BufferGeometry.call(this),this.prefabGeometry=e,this.isPrefabBufferGeometry=e.isBufferGeometry,this.prefabCount=t,this.isPrefabBufferGeometry?this.prefabVertexCount=e.attributes.position.count:this.prefabVertexCount=e.vertices.length,this.bufferIndices(),this.bufferPositions()}function u(e,t){n.BufferGeometry.call(this),Array.isArray(e)?this.prefabGeometries=e:this.prefabGeometries=[e],this.prefabGeometriesCount=this.prefabGeometries.length,this.prefabCount=t*this.prefabGeometriesCount,this.repeatCount=t,this.prefabVertexCounts=this.prefabGeometries.map(function(e){return e.isBufferGeometry?e.attributes.position.count:e.vertices.length}),this.repeatVertexCount=this.prefabVertexCounts.reduce(function(e,n){return e+n},0),this.bufferIndices(),this.bufferPositions()}function p(e,t){n.BufferGeometry.call(this),this.modelGeometry=e,this.faceCount=this.modelGeometry.faces.length,this.vertexCount=this.modelGeometry.vertices.length,(t=t||{}).computeCentroids&&this.computeCentroids(),this.bufferIndices(),this.bufferPositions(t.localizeFaces)}function d(e){n.BufferGeometry.call(this),this.pointCount=e,this.bufferPositions()}function m(e,n,t,r,i){this.key=e,this.start=n,this.duration=t,this.transition=r,this.compiler=i,this.trail=0}function h(){this.duration=0,this.timeKey="tTime",this.segments={},this.__key=0}t.prototype=Object.assign(Object.create(n.ShaderMaterial.prototype),{constructor:t,setUniformValues:function(e){var n=this;if(e){Object.keys(e).forEach(function(t){t in n.uniforms&&(n.uniforms[t].value=e[t])})}},stringifyChunk:function(e){return this[e]?"string"==typeof this[e]?this[e]:this[e].join("\n"):""}}),(r.prototype=Object.create(t.prototype)).constructor=r,r.prototype.concatVertexShader=function(){return"\n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <envmap_pars_vertex>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n\n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n    #include <skinbase_vertex>\n  \n    #ifdef USE_ENVMAP\n  \n    #include <beginnormal_vertex>\n    \n    "+this.stringifyChunk("vertexNormal")+"\n    \n    #include <morphnormal_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n  \n    #endif\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n    "+this.stringifyChunk("vertexColor")+"\n    \n    #include <morphtarget_vertex>\n    \n    "+this.stringifyChunk("vertexPostMorph")+"\n    \n    #include <skinning_vertex>\n\n    "+this.stringifyChunk("vertexPostSkinning")+"\n\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n  \n    #include <worldpos_vertex>\n    #include <clipping_planes_vertex>\n    #include <envmap_vertex>\n    #include <fog_vertex>\n  }"},r.prototype.concatFragmentShader=function(){return"\n  uniform vec3 diffuse;\n  uniform float opacity;\n  \n  "+this.stringifyChunk("fragmentParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("fragmentFunctions")+"\n  \n  #ifndef FLAT_SHADED\n  \n    varying vec3 vNormal;\n  \n  #endif\n  \n  #include <common>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <specularmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  void main() {\n  \n    "+this.stringifyChunk("fragmentInit")+"\n  \n    #include <clipping_planes_fragment>\n\n    vec4 diffuseColor = vec4( diffuse, opacity );\n\n    "+this.stringifyChunk("fragmentDiffuse")+"\n  \n    #include <logdepthbuf_fragment>\n    \n    "+(this.stringifyChunk("fragmentMap")||"#include <map_fragment>")+"\n    \n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n  \n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  \n    // accumulation (baked indirect lighting only)\n    #ifdef USE_LIGHTMAP\n  \n      reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n  \n    #else\n  \n      reflectedLight.indirectDiffuse += vec3( 1.0 );\n  \n    #endif\n  \n    // modulation\n    #include <aomap_fragment>\n  \n    reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n  \n    vec3 outgoingLight = reflectedLight.indirectDiffuse;\n  \n    #include <envmap_fragment>\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  \n    #include <premultiplied_alpha_fragment>\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n  }"},(i.prototype=Object.create(t.prototype)).constructor=i,i.prototype.concatVertexShader=function(){return"\n  #define LAMBERT\n\n  varying vec3 vLightFront;\n  \n  #ifdef DOUBLE_SIDED\n  \n    varying vec3 vLightBack;\n  \n  #endif\n  \n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <envmap_pars_vertex>\n  #include <bsdfs>\n  #include <lights_pars_begin>\n  #include <lights_pars_maps>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n  \n    #include <beginnormal_vertex>\n    \n    "+this.stringifyChunk("vertexNormal")+"\n    \n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n    "+this.stringifyChunk("vertexColor")+"\n    \n    #include <morphtarget_vertex>\n    \n    "+this.stringifyChunk("vertexPostMorph")+"\n    \n    #include <skinning_vertex>\n\n    "+this.stringifyChunk("vertexPostSkinning")+"\n    \n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n  \n    #include <worldpos_vertex>\n    #include <envmap_vertex>\n    #include <lights_lambert_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"},i.prototype.concatFragmentShader=function(){return"\n  uniform vec3 diffuse;\n  uniform vec3 emissive;\n  uniform float opacity;\n  \n  varying vec3 vLightFront;\n  \n  #ifdef DOUBLE_SIDED\n  \n    varying vec3 vLightBack;\n  \n  #endif\n  \n  #include <common>\n  #include <packing>\n  #include <dithering_pars_fragment>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <emissivemap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <bsdfs>\n  #include <lights_pars_begin>\n  #include <lights_pars_maps>\n  #include <fog_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <shadowmask_pars_fragment>\n  #include <specularmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  "+this.stringifyChunk("fragmentParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("fragmentFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("fragmentInit")+"\n  \n    #include <clipping_planes_fragment>\n\n    vec4 diffuseColor = vec4( diffuse, opacity );\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    vec3 totalEmissiveRadiance = emissive;\n\t\n    "+this.stringifyChunk("fragmentDiffuse")+"\n  \n    #include <logdepthbuf_fragment>\n\n    "+(this.stringifyChunk("fragmentMap")||"#include <map_fragment>")+"\n\n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n\n    "+this.stringifyChunk("fragmentEmissive")+"\n\n    #include <emissivemap_fragment>\n  \n    // accumulation\n    reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n  \n    #include <lightmap_fragment>\n  \n    reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n  \n    #ifdef DOUBLE_SIDED\n  \n      reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n  \n    #else\n  \n      reflectedLight.directDiffuse = vLightFront;\n  \n    #endif\n  \n    reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n  \n    // modulation\n    #include <aomap_fragment>\n  \n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n  \n    #include <envmap_fragment>\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  \n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n  }"},(a.prototype=Object.create(t.prototype)).constructor=a,a.prototype.concatVertexShader=function(){return"\n  #define PHONG\n\n  varying vec3 vViewPosition;\n  \n  #ifndef FLAT_SHADED\n  \n    varying vec3 vNormal;\n  \n  #endif\n  \n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <envmap_pars_vertex>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n  \n    #include <beginnormal_vertex>\n    \n    "+this.stringifyChunk("vertexNormal")+"\n    \n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n  \n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n  \n    vNormal = normalize( transformedNormal );\n  \n  #endif\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n    "+this.stringifyChunk("vertexColor")+"\n    \n    #include <morphtarget_vertex>\n    #include <skinning_vertex>\n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n  \n    vViewPosition = - mvPosition.xyz;\n  \n    #include <worldpos_vertex>\n    #include <envmap_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"},a.prototype.concatFragmentShader=function(){return"\n  #define PHONG\n\n  uniform vec3 diffuse;\n  uniform vec3 emissive;\n  uniform vec3 specular;\n  uniform float shininess;\n  uniform float opacity;\n  \n  #include <common>\n  #include <packing>\n  #include <dithering_pars_fragment>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <emissivemap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <gradientmap_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <bsdfs>\n  #include <lights_pars_begin>\n  #include <lights_pars_maps>\n  #include <lights_phong_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <bumpmap_pars_fragment>\n  #include <normalmap_pars_fragment>\n  #include <specularmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  "+this.stringifyChunk("fragmentParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("fragmentFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("fragmentInit")+"\n  \n    #include <clipping_planes_fragment>\n  \n    vec4 diffuseColor = vec4( diffuse, opacity );\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    vec3 totalEmissiveRadiance = emissive;\n  \n    "+this.stringifyChunk("fragmentDiffuse")+"\n  \n    #include <logdepthbuf_fragment>\n\n    "+(this.stringifyChunk("fragmentMap")||"#include <map_fragment>")+"\n\n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    #include <specularmap_fragment>\n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    \n    "+this.stringifyChunk("fragmentEmissive")+"\n    \n    #include <emissivemap_fragment>\n  \n    // accumulation\n    #include <lights_phong_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n    \n    "+this.stringifyChunk("fragmentSpecular")+"\n    \n    // modulation\n    #include <aomap_fragment>\n  \n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n  \n    #include <envmap_fragment>\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  \n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n  \n  }"},(o.prototype=Object.create(t.prototype)).constructor=o,o.prototype.concatVertexShader=function(){return"\n  #define PHYSICAL\n\n  varying vec3 vViewPosition;\n  \n  #ifndef FLAT_SHADED\n  \n    varying vec3 vNormal;\n  \n  #endif\n  \n  #include <common>\n  #include <uv_pars_vertex>\n  #include <uv2_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n\n    "+this.stringifyChunk("vertexInit")+"\n\n    #include <uv_vertex>\n    #include <uv2_vertex>\n    #include <color_vertex>\n  \n    #include <beginnormal_vertex>\n    \n    "+this.stringifyChunk("vertexNormal")+"\n    \n    #include <morphnormal_vertex>\n    #include <skinbase_vertex>\n    #include <skinnormal_vertex>\n    #include <defaultnormal_vertex>\n  \n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n  \n    vNormal = normalize( transformedNormal );\n  \n  #endif\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n    "+this.stringifyChunk("vertexColor")+"\n    \n    #include <morphtarget_vertex>\n    \n    "+this.stringifyChunk("vertexPostMorph")+"\n    \n    #include <skinning_vertex>\n\n    "+this.stringifyChunk("vertexPostSkinning")+"\n    \n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n  \n    vViewPosition = - mvPosition.xyz;\n  \n    #include <worldpos_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"},o.prototype.concatFragmentShader=function(){return"\n  #define PHYSICAL\n  \n  uniform vec3 diffuse;\n  uniform vec3 emissive;\n  uniform float roughness;\n  uniform float metalness;\n  uniform float opacity;\n  \n  #ifndef STANDARD\n    uniform float clearCoat;\n    uniform float clearCoatRoughness;\n  #endif\n  \n  varying vec3 vViewPosition;\n  \n  #ifndef FLAT_SHADED\n  \n    varying vec3 vNormal;\n  \n  #endif\n  \n  #include <common>\n  #include <packing>\n  #include <dithering_pars_fragment>\n  #include <color_pars_fragment>\n  #include <uv_pars_fragment>\n  #include <uv2_pars_fragment>\n  #include <map_pars_fragment>\n  #include <alphamap_pars_fragment>\n  #include <aomap_pars_fragment>\n  #include <lightmap_pars_fragment>\n  #include <emissivemap_pars_fragment>\n  #include <envmap_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <bsdfs>\n  #include <cube_uv_reflection_fragment>\n  #include <lights_pars_begin>\n  #include <lights_pars_maps>\n  #include <lights_physical_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <bumpmap_pars_fragment>\n  #include <normalmap_pars_fragment>\n  #include <roughnessmap_pars_fragment>\n  #include <metalnessmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  "+this.stringifyChunk("fragmentParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("fragmentFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("fragmentInit")+"\n  \n    #include <clipping_planes_fragment>\n  \n    vec4 diffuseColor = vec4( diffuse, opacity );\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    vec3 totalEmissiveRadiance = emissive;\n  \n    "+this.stringifyChunk("fragmentDiffuse")+"\n  \n    #include <logdepthbuf_fragment>\n\n    "+(this.stringifyChunk("fragmentMap")||"#include <map_fragment>")+"\n\n    #include <color_fragment>\n    #include <alphamap_fragment>\n    #include <alphatest_fragment>\n    \n    float roughnessFactor = roughness;\n    "+this.stringifyChunk("fragmentRoughness")+"\n    #ifdef USE_ROUGHNESSMAP\n    \n      vec4 texelRoughness = texture2D( roughnessMap, vUv );\n    \n      // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n      roughnessFactor *= texelRoughness.g;\n    \n    #endif\n    \n    float metalnessFactor = metalness;\n    "+this.stringifyChunk("fragmentMetalness")+"\n    #ifdef USE_METALNESSMAP\n    \n      vec4 texelMetalness = texture2D( metalnessMap, vUv );\n      metalnessFactor *= texelMetalness.b;\n    \n    #endif\n    \n    #include <normal_fragment_begin>\n    #include <normal_fragment_maps>\n    \n    "+this.stringifyChunk("fragmentEmissive")+"\n    \n    #include <emissivemap_fragment>\n  \n    // accumulation\n    #include <lights_physical_fragment>\n    #include <lights_fragment_begin>\n    #include <lights_fragment_maps>\n    #include <lights_fragment_end>\n  \n    // modulation\n    #include <aomap_fragment>\n  \n    vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n  \n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n    #include <premultiplied_alpha_fragment>\n    #include <dithering_fragment>\n  \n  }"},(s.prototype=Object.create(t.prototype)).constructor=s,s.prototype.concatVertexShader=function(){return"\n  uniform float size;\n  uniform float scale;\n  \n  #include <common>\n  #include <color_pars_vertex>\n  #include <fog_pars_vertex>\n  #include <shadowmap_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <color_vertex>\n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n    "+this.stringifyChunk("vertexColor")+"\n    \n    #include <project_vertex>\n  \n    #ifdef USE_SIZEATTENUATION\n      gl_PointSize = size * ( scale / - mvPosition.z );\n    #else\n      gl_PointSize = size;\n    #endif\n  \n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n    #include <worldpos_vertex>\n    #include <shadowmap_vertex>\n    #include <fog_vertex>\n  }"},s.prototype.concatFragmentShader=function(){return"\n  uniform vec3 diffuse;\n  uniform float opacity;\n  \n  #include <common>\n  #include <packing>\n  #include <color_pars_fragment>\n  #include <map_particle_pars_fragment>\n  #include <fog_pars_fragment>\n  #include <shadowmap_pars_fragment>\n  #include <logdepthbuf_pars_fragment>\n  #include <clipping_planes_pars_fragment>\n  \n  "+this.stringifyChunk("fragmentParameters")+"\n  "+this.stringifyChunk("varyingParameters")+"\n  "+this.stringifyChunk("fragmentFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("fragmentInit")+"\n  \n    #include <clipping_planes_fragment>\n  \n    vec3 outgoingLight = vec3( 0.0 );\n    vec4 diffuseColor = vec4( diffuse, opacity );\n  \n    "+this.stringifyChunk("fragmentDiffuse")+"\n  \n    #include <logdepthbuf_fragment>\n\n    "+(this.stringifyChunk("fragmentMap")||"#include <map_particle_fragment>")+"\n\n    #include <color_fragment>\n    #include <alphatest_fragment>\n  \n    outgoingLight = diffuseColor.rgb;\n  \n    gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n    \n    "+this.stringifyChunk("fragmentShape")+"\n  \n    #include <premultiplied_alpha_fragment>\n    #include <tonemapping_fragment>\n    #include <encodings_fragment>\n    #include <fog_fragment>\n  }"},(f.prototype=Object.create(t.prototype)).constructor=f,f.prototype.concatVertexShader=function(){return"\n  #include <common>\n  #include <uv_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <logdepthbuf_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n  \n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <uv_vertex>\n  \n    #include <skinbase_vertex>\n  \n    #ifdef USE_DISPLACEMENTMAP\n  \n      #include <beginnormal_vertex>\n      #include <morphnormal_vertex>\n      #include <skinnormal_vertex>\n  \n    #endif\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n\n    #include <morphtarget_vertex>\n    \n    "+this.stringifyChunk("vertexPostMorph")+"\n    \n    #include <skinning_vertex>\n\n    "+this.stringifyChunk("vertexPostSkinning")+"\n    \n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <logdepthbuf_vertex>\n    #include <clipping_planes_vertex>\n  }"},(l.prototype=Object.create(t.prototype)).constructor=l,l.prototype.concatVertexShader=function(){return"\n  #define DISTANCE\n\n  varying vec3 vWorldPosition;\n  \n  #include <common>\n  #include <uv_pars_vertex>\n  #include <displacementmap_pars_vertex>\n  #include <morphtarget_pars_vertex>\n  #include <skinning_pars_vertex>\n  #include <clipping_planes_pars_vertex>\n  \n  "+this.stringifyChunk("vertexParameters")+"\n  "+this.stringifyChunk("vertexFunctions")+"\n  \n  void main() {\n\n    "+this.stringifyChunk("vertexInit")+"\n  \n    #include <uv_vertex>\n  \n    #include <skinbase_vertex>\n  \n    #ifdef USE_DISPLACEMENTMAP\n  \n      #include <beginnormal_vertex>\n      #include <morphnormal_vertex>\n      #include <skinnormal_vertex>\n  \n    #endif\n  \n    #include <begin_vertex>\n    \n    "+this.stringifyChunk("vertexPosition")+"\n\n    #include <morphtarget_vertex>\n    \n    "+this.stringifyChunk("vertexPostMorph")+"\n    \n    #include <skinning_vertex>\n\n    "+this.stringifyChunk("vertexPostSkinning")+"\n    \n    #include <displacementmap_vertex>\n    #include <project_vertex>\n    #include <worldpos_vertex>\n    #include <clipping_planes_vertex>\n  \n    vWorldPosition = worldPosition.xyz;\n  \n  }"},(c.prototype=Object.create(n.BufferGeometry.prototype)).constructor=c,c.prototype.bufferIndices=function(){var e=[],t=void 0;if(this.isPrefabBufferGeometry)if(this.prefabGeometry.index)t=this.prefabGeometry.index.count,e=this.prefabGeometry.index.array;else{t=this.prefabVertexCount;for(var r=0;r<t;r++)e.push(r)}else{var i=this.prefabGeometry.faces.length;t=3*i;for(var a=0;a<i;a++){var o=this.prefabGeometry.faces[a];e.push(o.a,o.b,o.c)}}var s=new Uint32Array(this.prefabCount*t);this.setIndex(new n.BufferAttribute(s,1));for(var f=0;f<this.prefabCount;f++)for(var l=0;l<t;l++)s[f*t+l]=e[l]+f*this.prefabVertexCount},c.prototype.bufferPositions=function(){var e=this.createAttribute("position",3).array;if(this.isPrefabBufferGeometry)for(var n=this.prefabGeometry.attributes.position.array,t=0,r=0;t<this.prefabCount;t++)for(var i=0;i<this.prefabVertexCount;i++,r+=3)e[r]=n[3*i],e[r+1]=n[3*i+1],e[r+2]=n[3*i+2];else for(var a=0,o=0;a<this.prefabCount;a++)for(var s=0;s<this.prefabVertexCount;s++,o+=3){var f=this.prefabGeometry.vertices[s];e[o]=f.x,e[o+1]=f.y,e[o+2]=f.z}},c.prototype.bufferUvs=function(){var e=[];if(this.isPrefabBufferGeometry)for(var t=this.prefabGeometry.attributes.uv.array,r=0;r<this.prefabVertexCount;r++)e.push(new n.Vector2(t[2*r],t[2*r+1]));else for(var i=this.prefabGeometry.faces.length,a=0;a<i;a++){var o=this.prefabGeometry.faces[a],s=this.prefabGeometry.faceVertexUvs[0][a];e[o.a]=s[0],e[o.b]=s[1],e[o.c]=s[2]}for(var f=this.createAttribute("uv",2),l=0,c=0;l<this.prefabCount;l++)for(var u=0;u<this.prefabVertexCount;u++,c+=2){var p=e[u];f.array[c]=p.x,f.array[c+1]=p.y}},c.prototype.createAttribute=function(e,t,r){var i=new Float32Array(this.prefabCount*this.prefabVertexCount*t),a=new n.BufferAttribute(i,t);if(this.addAttribute(e,a),r)for(var o=[],s=0;s<this.prefabCount;s++)r(o,s,this.prefabCount),this.setPrefabData(a,s,o);return a},c.prototype.setPrefabData=function(e,n,t){e="string"==typeof e?this.attributes[e]:e;for(var r=n*this.prefabVertexCount*e.itemSize,i=0;i<this.prefabVertexCount;i++)for(var a=0;a<e.itemSize;a++)e.array[r++]=t[a]},(u.prototype=Object.create(n.BufferGeometry.prototype)).constructor=u,u.prototype.bufferIndices=function(){var e=0;this.prefabIndices=this.prefabGeometries.map(function(n){var t=[];if(n.isBufferGeometry)if(n.index)t=n.index.array;else for(var r=0;r<n.attributes.position.count;r++)t.push(r);else for(var i=0;i<n.faces.length;i++){var a=n.faces[i];t.push(a.a,a.b,a.c)}return e+=t.length,t});for(var t=new Uint32Array(e*this.repeatCount),r=0,i=0,a=0;a<this.prefabCount;a++){for(var o=a%this.prefabGeometriesCount,s=this.prefabIndices[o],f=this.prefabVertexCounts[o],l=0;l<s.length;l++)t[r++]=s[l]+i;i+=f}this.setIndex(new n.BufferAttribute(t,1))},u.prototype.bufferPositions=function(){for(var e=this,n=this.createAttribute("position",3).array,t=this.prefabGeometries.map(function(n,t){var r=void 0;if(n.isBufferGeometry)r=n.attributes.position.array;else{var i=e.prefabVertexCounts[t];r=[];for(var a=0,o=0;a<i;a++){var s=n.vertices[a];r[o++]=s.x,r[o++]=s.y,r[o++]=s.z}}return r}),r=0,i=0;r<this.prefabCount;r++)for(var a=r%this.prefabGeometries.length,o=this.prefabVertexCounts[a],s=t[a],f=0;f<o;f++)n[i++]=s[3*f],n[i++]=s[3*f+1],n[i++]=s[3*f+2]},u.prototype.bufferUvs=function(){for(var e=this,n=this.createAttribute("uv",2).array,t=this.prefabGeometries.map(function(n,t){var r=void 0;if(n.isBufferGeometry)n.attributes.uv||console.error("No UV found in prefab geometry",n),r=n.attributes.uv.array;else{for(var i=e.prefabIndices[t].length/3,a=[],o=0;o<i;o++){var s=n.faces[o],f=n.faceVertexUvs[0][o];a[s.a]=f[0],a[s.b]=f[1],a[s.c]=f[2]}r=[];for(var l=0;l<a.length;l++)r[2*l]=a[l].x,r[2*l+1]=a[l].y}return r}),r=0,i=0;r<this.prefabCount;r++)for(var a=r%this.prefabGeometries.length,o=this.prefabVertexCounts[a],s=t[a],f=0;f<o;f++)n[i++]=s[2*f],n[i++]=s[2*f+1]},u.prototype.createAttribute=function(e,t,r){var i=new Float32Array(this.repeatCount*this.repeatVertexCount*t),a=new n.BufferAttribute(i,t);if(this.addAttribute(e,a),r)for(var o=[],s=0;s<this.prefabCount;s++)r(o,s,this.prefabCount),this.setPrefabData(a,s,o);return a},u.prototype.setPrefabData=function(e,n,t){e="string"==typeof e?this.attributes[e]:e;for(var r=n%this.prefabGeometriesCount,i=this.prefabVertexCounts[r],a=(n/this.prefabGeometriesCount|0)*this.prefabGeometriesCount,o=a*this.repeatVertexCount,s=n-a,f=0,l=0;l<s;)f+=this.prefabVertexCounts[l++];for(var c=(o+f)*e.itemSize,u=0;u<i;u++)for(var p=0;p<e.itemSize;p++)e.array[c++]=t[p]};var v={separateFaces:function(e){for(var n=[],t=0,r=e.faces.length;t<r;t++){var i=n.length,a=e.faces[t],o=a.a,s=a.b,f=a.c,l=e.vertices[o],c=e.vertices[s],u=e.vertices[f];n.push(l.clone()),n.push(c.clone()),n.push(u.clone()),a.a=i,a.b=i+1,a.c=i+2}e.vertices=n},computeCentroid:function(e,t,r){var i=e.vertices[t.a],a=e.vertices[t.b],o=e.vertices[t.c];return r=r||new n.Vector3,r.x=(i.x+a.x+o.x)/3,r.y=(i.y+a.y+o.y)/3,r.z=(i.z+a.z+o.z)/3,r},randomInBox:function(e,t){return t=t||new n.Vector3,t.x=n.Math.randFloat(e.min.x,e.max.x),t.y=n.Math.randFloat(e.min.y,e.max.y),t.z=n.Math.randFloat(e.min.z,e.max.z),t},randomAxis:function(e){return e=e||new n.Vector3,e.x=n.Math.randFloatSpread(2),e.y=n.Math.randFloatSpread(2),e.z=n.Math.randFloatSpread(2),e.normalize(),e},createDepthAnimationMaterial:function(e){return new f({uniforms:e.uniforms,defines:e.defines,vertexFunctions:e.vertexFunctions,vertexParameters:e.vertexParameters,vertexInit:e.vertexInit,vertexPosition:e.vertexPosition})},createDistanceAnimationMaterial:function(e){return new l({uniforms:e.uniforms,defines:e.defines,vertexFunctions:e.vertexFunctions,vertexParameters:e.vertexParameters,vertexInit:e.vertexInit,vertexPosition:e.vertexPosition})}};(p.prototype=Object.create(n.BufferGeometry.prototype)).constructor=p,p.prototype.computeCentroids=function(){this.centroids=[];for(var e=0;e<this.faceCount;e++)this.centroids[e]=v.computeCentroid(this.modelGeometry,this.modelGeometry.faces[e])},p.prototype.bufferIndices=function(){var e=new Uint32Array(3*this.faceCount);this.setIndex(new n.BufferAttribute(e,1));for(var t=0,r=0;t<this.faceCount;t++,r+=3){var i=this.modelGeometry.faces[t];e[r]=i.a,e[r+1]=i.b,e[r+2]=i.c}},p.prototype.bufferPositions=function(e){var n=this.createAttribute("position",3).array,t=void 0,r=void 0;if(!0===e)for(t=0;t<this.faceCount;t++){var i=this.modelGeometry.faces[t],a=this.centroids?this.centroids[t]:v.computeCentroid(this.modelGeometry,i),o=this.modelGeometry.vertices[i.a],s=this.modelGeometry.vertices[i.b],f=this.modelGeometry.vertices[i.c];n[3*i.a]=o.x-a.x,n[3*i.a+1]=o.y-a.y,n[3*i.a+2]=o.z-a.z,n[3*i.b]=s.x-a.x,n[3*i.b+1]=s.y-a.y,n[3*i.b+2]=s.z-a.z,n[3*i.c]=f.x-a.x,n[3*i.c+1]=f.y-a.y,n[3*i.c+2]=f.z-a.z}else for(t=0,r=0;t<this.vertexCount;t++,r+=3){var l=this.modelGeometry.vertices[t];n[r]=l.x,n[r+1]=l.y,n[r+2]=l.z}},p.prototype.bufferUVs=function(){for(var e=this.createAttribute("uv",2).array,n=0;n<this.faceCount;n++){var t=this.modelGeometry.faces[n],r=void 0;r=this.modelGeometry.faceVertexUvs[0][n][0],e[2*t.a]=r.x,e[2*t.a+1]=r.y,r=this.modelGeometry.faceVertexUvs[0][n][1],e[2*t.b]=r.x,e[2*t.b+1]=r.y,r=this.modelGeometry.faceVertexUvs[0][n][2],e[2*t.c]=r.x,e[2*t.c+1]=r.y}},p.prototype.bufferSkinning=function(){for(var e=this.createAttribute("skinIndex",4).array,n=this.createAttribute("skinWeight",4).array,t=0;t<this.vertexCount;t++){var r=this.modelGeometry.skinIndices[t],i=this.modelGeometry.skinWeights[t];e[4*t]=r.x,e[4*t+1]=r.y,e[4*t+2]=r.z,e[4*t+3]=r.w,n[4*t]=i.x,n[4*t+1]=i.y,n[4*t+2]=i.z,n[4*t+3]=i.w}},p.prototype.createAttribute=function(e,t,r){var i=new Float32Array(this.vertexCount*t),a=new n.BufferAttribute(i,t);if(this.addAttribute(e,a),r)for(var o=[],s=0;s<this.faceCount;s++)r(o,s,this.faceCount),this.setFaceData(a,s,o);return a},p.prototype.setFaceData=function(e,n,t){for(var r=3*n*(e="string"==typeof e?this.attributes[e]:e).itemSize,i=0;i<3;i++)for(var a=0;a<e.itemSize;a++)e.array[r++]=t[a]},(d.prototype=Object.create(n.BufferGeometry.prototype)).constructor=d,d.prototype.bufferPositions=function(){this.createAttribute("position",3)},d.prototype.createAttribute=function(e,t,r){var i=new Float32Array(this.pointCount*t),a=new n.BufferAttribute(i,t);if(this.addAttribute(e,a),r)for(var o=[],s=0;s<this.pointCount;s++)r(o,s,this.pointCount),this.setPointData(a,s,o);return a},d.prototype.setPointData=function(e,n,t){for(var r=n*(e="string"==typeof e?this.attributes[e]:e).itemSize,i=0;i<e.itemSize;i++)e.array[r++]=t[i]};var g={catmull_rom_spline:"vec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t, vec2 c) {\r\n    vec4 v0 = (p2 - p0) * c.x;\r\n    vec4 v1 = (p3 - p1) * c.y;\r\n    float t2 = t * t;\r\n    float t3 = t * t * t;\r\n\r\n    return vec4((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\r\n}\r\nvec4 catmullRomSpline(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t) {\r\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\r\n}\r\n\r\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t, vec2 c) {\r\n    vec3 v0 = (p2 - p0) * c.x;\r\n    vec3 v1 = (p3 - p1) * c.y;\r\n    float t2 = t * t;\r\n    float t3 = t * t * t;\r\n\r\n    return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\r\n}\r\nvec3 catmullRomSpline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\r\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\r\n}\r\n\r\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t, vec2 c) {\r\n    vec2 v0 = (p2 - p0) * c.x;\r\n    vec2 v1 = (p3 - p1) * c.y;\r\n    float t2 = t * t;\r\n    float t3 = t * t * t;\r\n\r\n    return vec2((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\r\n}\r\nvec2 catmullRomSpline(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\r\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\r\n}\r\n\r\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t, vec2 c) {\r\n    float v0 = (p2 - p0) * c.x;\r\n    float v1 = (p3 - p1) * c.y;\r\n    float t2 = t * t;\r\n    float t3 = t * t * t;\r\n\r\n    return float((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\r\n}\r\nfloat catmullRomSpline(float p0, float p1, float p2, float p3, float t) {\r\n    return catmullRomSpline(p0, p1, p2, p3, t, vec2(0.5, 0.5));\r\n}\r\n\r\nivec4 getCatmullRomSplineIndices(float l, float p) {\r\n    float index = floor(p);\r\n    int i0 = int(max(0.0, index - 1.0));\r\n    int i1 = int(index);\r\n    int i2 = int(min(index + 1.0, l));\r\n    int i3 = int(min(index + 2.0, l));\r\n\r\n    return ivec4(i0, i1, i2, i3);\r\n}\r\n\r\nivec4 getCatmullRomSplineIndicesClosed(float l, float p) {\r\n    float index = floor(p);\r\n    int i0 = int(index == 0.0 ? l : index - 1.0);\r\n    int i1 = int(index);\r\n    int i2 = int(mod(index + 1.0, l));\r\n    int i3 = int(mod(index + 2.0, l));\r\n\r\n    return ivec4(i0, i1, i2, i3);\r\n}\r\n",cubic_bezier:"vec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t) {\r\n    float tn = 1.0 - t;\r\n\r\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\r\n}\r\n\r\nvec2 cubicBezier(vec2 p0, vec2 c0, vec2 c1, vec2 p1, float t) {\r\n    float tn = 1.0 - t;\r\n\r\n    return tn * tn * tn * p0 + 3.0 * tn * tn * t * c0 + 3.0 * tn * t * t * c1 + t * t * t * p1;\r\n}\r\n",ease_back_in:"float easeBackIn(float p, float amplitude) {\r\n    return p * p * ((amplitude + 1.0) * p - amplitude);\r\n}\r\n\r\nfloat easeBackIn(float p) {\r\n    return easeBackIn(p, 1.70158);\r\n}\r\n\r\nfloat easeBackIn(float t, float b, float c, float d, float amplitude) {\r\n    return b + easeBackIn(t / d, amplitude) * c;\r\n}\r\n\r\nfloat easeBackIn(float t, float b, float c, float d) {\r\n    return b + easeBackIn(t / d) * c;\r\n}\r\n",ease_back_in_out:"float easeBackInOut(float p, float amplitude) {\r\n    amplitude *= 1.525;\r\n\r\n    return ((p *= 2.0) < 1.0) ? 0.5 * p * p * ((amplitude + 1.0) * p - amplitude) : 0.5 * ((p -= 2.0) * p * ((amplitude + 1.0) * p + amplitude) + 2.0);\r\n}\r\n\r\nfloat easeBackInOut(float p) {\r\n    return easeBackInOut(p, 1.70158);\r\n}\r\n\r\nfloat easeBackInOut(float t, float b, float c, float d, float amplitude) {\r\n    return b + easeBackInOut(t / d, amplitude) * c;\r\n}\r\n\r\nfloat easeBackInOut(float t, float b, float c, float d) {\r\n    return b + easeBackInOut(t / d) * c;\r\n}\r\n",ease_back_out:"float easeBackOut(float p, float amplitude) {\r\n    return ((p = p - 1.0) * p * ((amplitude + 1.0) * p + amplitude) + 1.0);\r\n}\r\n\r\nfloat easeBackOut(float p) {\r\n    return easeBackOut(p, 1.70158);\r\n}\r\n\r\nfloat easeBackOut(float t, float b, float c, float d, float amplitude) {\r\n    return b + easeBackOut(t / d, amplitude) * c;\r\n}\r\n\r\nfloat easeBackOut(float t, float b, float c, float d) {\r\n    return b + easeBackOut(t / d) * c;\r\n}\r\n",ease_bezier:"float easeBezier(float p, vec4 curve) {\r\n    float ip = 1.0 - p;\r\n    return (3.0 * ip * ip * p * curve.xy + 3.0 * ip * p * p * curve.zw + p * p * p).y;\r\n}\r\n\r\nfloat easeBezier(float t, float b, float c, float d, vec4 curve) {\r\n    return b + easeBezier(t / d, curve) * c;\r\n}\r\n",ease_bounce_in:"float easeBounceIn(float p) {\r\n    if ((p = 1.0 - p) < 1.0 / 2.75) {\r\n        return 1.0 - (7.5625 * p * p);\r\n    } else if (p < 2.0 / 2.75) {\r\n        return 1.0 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);\r\n    } else if (p < 2.5 / 2.75) {\r\n        return 1.0 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);\r\n    }\r\n    return 1.0 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);\r\n}\r\n\r\nfloat easeBounceIn(float t, float b, float c, float d) {\r\n    return b + easeBounceIn(t / d) * c;\r\n}\r\n",ease_bounce_in_out:"float easeBounceInOut(float p) {\r\n    bool invert = (p < 0.5);\r\n\r\n    p = invert ? (1.0 - (p * 2.0)) : ((p * 2.0) - 1.0);\r\n\r\n    if (p < 1.0 / 2.75) {\r\n        p = 7.5625 * p * p;\r\n    } else if (p < 2.0 / 2.75) {\r\n        p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\r\n    } else if (p < 2.5 / 2.75) {\r\n        p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\r\n    } else {\r\n        p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\r\n    }\r\n\r\n    return invert ? (1.0 - p) * 0.5 : p * 0.5 + 0.5;\r\n}\r\n\r\nfloat easeBounceInOut(float t, float b, float c, float d) {\r\n    return b + easeBounceInOut(t / d) * c;\r\n}\r\n",ease_bounce_out:"float easeBounceOut(float p) {\r\n    if (p < 1.0 / 2.75) {\r\n        return 7.5625 * p * p;\r\n    } else if (p < 2.0 / 2.75) {\r\n        return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;\r\n    } else if (p < 2.5 / 2.75) {\r\n        return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;\r\n    }\r\n    return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;\r\n}\r\n\r\nfloat easeBounceOut(float t, float b, float c, float d) {\r\n    return b + easeBounceOut(t / d) * c;\r\n}\r\n",ease_circ_in:"float easeCircIn(float p) {\r\n    return -(sqrt(1.0 - p * p) - 1.0);\r\n}\r\n\r\nfloat easeCircIn(float t, float b, float c, float d) {\r\n    return b + easeCircIn(t / d) * c;\r\n}\r\n",ease_circ_in_out:"float easeCircInOut(float p) {\r\n    return ((p *= 2.0) < 1.0) ? -0.5 * (sqrt(1.0 - p * p) - 1.0) : 0.5 * (sqrt(1.0 - (p -= 2.0) * p) + 1.0);\r\n}\r\n\r\nfloat easeCircInOut(float t, float b, float c, float d) {\r\n    return b + easeCircInOut(t / d) * c;\r\n}\r\n",ease_circ_out:"float easeCircOut(float p) {\r\n  return sqrt(1.0 - (p = p - 1.0) * p);\r\n}\r\n\r\nfloat easeCircOut(float t, float b, float c, float d) {\r\n  return b + easeCircOut(t / d) * c;\r\n}\r\n",ease_cubic_in:"float easeCubicIn(float t) {\r\n  return t * t * t;\r\n}\r\n\r\nfloat easeCubicIn(float t, float b, float c, float d) {\r\n  return b + easeCubicIn(t / d) * c;\r\n}\r\n",ease_cubic_in_out:"float easeCubicInOut(float t) {\r\n  return (t /= 0.5) < 1.0 ? 0.5 * t * t * t : 0.5 * ((t-=2.0) * t * t + 2.0);\r\n}\r\n\r\nfloat easeCubicInOut(float t, float b, float c, float d) {\r\n  return b + easeCubicInOut(t / d) * c;\r\n}\r\n",ease_cubic_out:"float easeCubicOut(float t) {\r\n  float f = t - 1.0;\r\n  return f * f * f + 1.0;\r\n}\r\n\r\nfloat easeCubicOut(float t, float b, float c, float d) {\r\n  return b + easeCubicOut(t / d) * c;\r\n}\r\n",ease_elastic_in:"float easeElasticIn(float p, float amplitude, float period) {\r\n    float p1 = max(amplitude, 1.0);\r\n    float p2 = period / min(amplitude, 1.0);\r\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\r\n\r\n    return -(p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2));\r\n}\r\n\r\nfloat easeElasticIn(float p) {\r\n    return easeElasticIn(p, 1.0, 0.3);\r\n}\r\n\r\nfloat easeElasticIn(float t, float b, float c, float d, float amplitude, float period) {\r\n    return b + easeElasticIn(t / d, amplitude, period) * c;\r\n}\r\n\r\nfloat easeElasticIn(float t, float b, float c, float d) {\r\n    return b + easeElasticIn(t / d) * c;\r\n}\r\n",ease_elastic_in_out:"float easeElasticInOut(float p, float amplitude, float period) {\r\n    float p1 = max(amplitude, 1.0);\r\n    float p2 = period / min(amplitude, 1.0);\r\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\r\n\r\n    return ((p *= 2.0) < 1.0) ? -0.5 * (p1 * pow(2.0, 10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2)) : p1 * pow(2.0, -10.0 * (p -= 1.0)) * sin((p - p3) * PI2 / p2) * 0.5 + 1.0;\r\n}\r\n\r\nfloat easeElasticInOut(float p) {\r\n    return easeElasticInOut(p, 1.0, 0.3);\r\n}\r\n\r\nfloat easeElasticInOut(float t, float b, float c, float d, float amplitude, float period) {\r\n    return b + easeElasticInOut(t / d, amplitude, period) * c;\r\n}\r\n\r\nfloat easeElasticInOut(float t, float b, float c, float d) {\r\n    return b + easeElasticInOut(t / d) * c;\r\n}\r\n",ease_elastic_out:"float easeElasticOut(float p, float amplitude, float period) {\r\n    float p1 = max(amplitude, 1.0);\r\n    float p2 = period / min(amplitude, 1.0);\r\n    float p3 = p2 / PI2 * (asin(1.0 / p1));\r\n\r\n    return p1 * pow(2.0, -10.0 * p) * sin((p - p3) * PI2 / p2) + 1.0;\r\n}\r\n\r\nfloat easeElasticOut(float p) {\r\n    return easeElasticOut(p, 1.0, 0.3);\r\n}\r\n\r\nfloat easeElasticOut(float t, float b, float c, float d, float amplitude, float period) {\r\n    return b + easeElasticOut(t / d, amplitude, period) * c;\r\n}\r\n\r\nfloat easeElasticOut(float t, float b, float c, float d) {\r\n    return b + easeElasticOut(t / d) * c;\r\n}\r\n",ease_expo_in:"float easeExpoIn(float p) {\r\n    return pow(2.0, 10.0 * (p - 1.0));\r\n}\r\n\r\nfloat easeExpoIn(float t, float b, float c, float d) {\r\n    return b + easeExpoIn(t / d) * c;\r\n}\r\n",ease_expo_in_out:"float easeExpoInOut(float p) {\r\n    return ((p *= 2.0) < 1.0) ? 0.5 * pow(2.0, 10.0 * (p - 1.0)) : 0.5 * (2.0 - pow(2.0, -10.0 * (p - 1.0)));\r\n}\r\n\r\nfloat easeExpoInOut(float t, float b, float c, float d) {\r\n    return b + easeExpoInOut(t / d) * c;\r\n}\r\n",ease_expo_out:"float easeExpoOut(float p) {\r\n  return 1.0 - pow(2.0, -10.0 * p);\r\n}\r\n\r\nfloat easeExpoOut(float t, float b, float c, float d) {\r\n  return b + easeExpoOut(t / d) * c;\r\n}\r\n",ease_quad_in:"float easeQuadIn(float t) {\r\n    return t * t;\r\n}\r\n\r\nfloat easeQuadIn(float t, float b, float c, float d) {\r\n  return b + easeQuadIn(t / d) * c;\r\n}\r\n",ease_quad_in_out:"float easeQuadInOut(float t) {\r\n    float p = 2.0 * t * t;\r\n    return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\r\n}\r\n\r\nfloat easeQuadInOut(float t, float b, float c, float d) {\r\n    return b + easeQuadInOut(t / d) * c;\r\n}\r\n",ease_quad_out:"float easeQuadOut(float t) {\r\n  return -t * (t - 2.0);\r\n}\r\n\r\nfloat easeQuadOut(float t, float b, float c, float d) {\r\n  return b + easeQuadOut(t / d) * c;\r\n}\r\n",ease_quart_in:"float easeQuartIn(float t) {\r\n  return t * t * t * t;\r\n}\r\n\r\nfloat easeQuartIn(float t, float b, float c, float d) {\r\n  return b + easeQuartIn(t / d) * c;\r\n}\r\n",ease_quart_in_out:"float easeQuartInOut(float t) {\r\n    return t < 0.5 ? 8.0 * pow(t, 4.0) : -8.0 * pow(t - 1.0, 4.0) + 1.0;\r\n}\r\n\r\nfloat easeQuartInOut(float t, float b, float c, float d) {\r\n    return b + easeQuartInOut(t / d) * c;\r\n}\r\n",ease_quart_out:"float easeQuartOut(float t) {\r\n  return 1.0 - pow(1.0 - t, 4.0);\r\n}\r\n\r\nfloat easeQuartOut(float t, float b, float c, float d) {\r\n  return b + easeQuartOut(t / d) * c;\r\n}\r\n",ease_quint_in:"float easeQuintIn(float t) {\r\n    return pow(t, 5.0);\r\n}\r\n\r\nfloat easeQuintIn(float t, float b, float c, float d) {\r\n    return b + easeQuintIn(t / d) * c;\r\n}\r\n",ease_quint_in_out:"float easeQuintInOut(float t) {\r\n    return (t /= 0.5) < 1.0 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2.0) * t * t * t * t + 2.0);\r\n}\r\n\r\nfloat easeQuintInOut(float t, float b, float c, float d) {\r\n    return b + easeQuintInOut(t / d) * c;\r\n}\r\n",ease_quint_out:"float easeQuintOut(float t) {\r\n    return (t -= 1.0) * t * t * t * t + 1.0;\r\n}\r\n\r\nfloat easeQuintOut(float t, float b, float c, float d) {\r\n    return b + easeQuintOut(t / d) * c;\r\n}\r\n",ease_sine_in:"float easeSineIn(float p) {\r\n  return -cos(p * 1.57079632679) + 1.0;\r\n}\r\n\r\nfloat easeSineIn(float t, float b, float c, float d) {\r\n  return b + easeSineIn(t / d) * c;\r\n}\r\n",ease_sine_in_out:"float easeSineInOut(float p) {\r\n  return -0.5 * (cos(PI * p) - 1.0);\r\n}\r\n\r\nfloat easeSineInOut(float t, float b, float c, float d) {\r\n  return b + easeSineInOut(t / d) * c;\r\n}\r\n",ease_sine_out:"float easeSineOut(float p) {\r\n  return sin(p * 1.57079632679);\r\n}\r\n\r\nfloat easeSineOut(float t, float b, float c, float d) {\r\n  return b + easeSineOut(t / d) * c;\r\n}\r\n",quadratic_bezier:"vec3 quadraticBezier(vec3 p0, vec3 c0, vec3 p1, float t) {\r\n    float tn = 1.0 - t;\r\n\r\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\r\n}\r\n\r\nvec2 quadraticBezier(vec2 p0, vec2 c0, vec2 p1, float t) {\r\n    float tn = 1.0 - t;\r\n\r\n    return tn * tn * p0 + 2.0 * tn * t * c0 + t * t * p1;\r\n}",quaternion_rotation:"vec3 rotateVector(vec4 q, vec3 v) {\r\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\r\n}\r\n\r\nvec4 quatFromAxisAngle(vec3 axis, float angle) {\r\n    float halfAngle = angle * 0.5;\r\n    return vec4(axis.xyz * sin(halfAngle), cos(halfAngle));\r\n}\r\n",quaternion_slerp:"vec4 quatSlerp(vec4 q0, vec4 q1, float t) {\r\n    float s = 1.0 - t;\r\n    float c = dot(q0, q1);\r\n    float dir = -1.0; //c >= 0.0 ? 1.0 : -1.0;\r\n    float sqrSn = 1.0 - c * c;\r\n\r\n    if (sqrSn > 2.220446049250313e-16) {\r\n        float sn = sqrt(sqrSn);\r\n        float len = atan(sn, c * dir);\r\n\r\n        s = sin(s * len) / sn;\r\n        t = sin(t * len) / sn;\r\n    }\r\n\r\n    float tDir = t * dir;\r\n\r\n    return normalize(q0 * s + q1 * tDir);\r\n}\r\n"};m.prototype.compile=function(){return this.compiler(this)},Object.defineProperty(m.prototype,"end",{get:function(){return this.start+this.duration}}),h.segmentDefinitions={},h.register=function(e,n){return h.segmentDefinitions[e]=n,n},h.prototype.add=function(e,n,t){var r=eval,i=this.duration;void 0!==t?("number"==typeof t?i=t:"string"==typeof t&&r("start"+t),this.duration=Math.max(this.duration,i+e)):this.duration+=e;for(var a=Object.keys(n),o=void 0,s=0;s<a.length;s++)o=a[s],this.processTransition(o,n[o],i,e)},h.prototype.processTransition=function(e,n,t,r){var i=h.segmentDefinitions[e],a=this.segments[e];a||(a=this.segments[e]=[]),void 0===n.from&&(0===a.length?n.from=i.defaultFrom:n.from=a[a.length-1].transition.to),a.push(new m((this.__key++).toString(),t,r,n,i.compiler))},h.prototype.compile=function(){for(var e=[],n=Object.keys(this.segments),t=void 0,r=0;r<n.length;r++)t=this.segments[n[r]],this.fillGaps(t),t.forEach(function(n){e.push(n.compile())});return e},h.prototype.fillGaps=function(e){if(0!==e.length){for(var n=void 0,t=void 0,r=0;r<e.length-1;r++)n=e[r],t=e[r+1],n.trail=t.start-n.end;(n=e[e.length-1]).trail=this.duration-n.end}},h.prototype.getTransformCalls=function(e){var n=this.timeKey;return this.segments[e]?this.segments[e].map(function(e){return"applyTransform"+e.key+"("+n+", transformed);"}).join("\n"):""};var _={vec3:function(e,n,t){return"vec3 "+e+" = vec3("+(n.x||0).toPrecision(t)+", "+(n.y||0).toPrecision(t)+", "+(n.z||0).toPrecision(t)+");"},vec4:function(e,n,t){return"vec4 "+e+" = vec4("+(n.x||0).toPrecision(t)+", "+(n.y||0).toPrecision(t)+", "+(n.z||0).toPrecision(t)+", "+(n.w||0).toPrecision(t)+");"},delayDuration:function(e){return"\n    float cDelay"+e.key+" = "+e.start.toPrecision(4)+";\n    float cDuration"+e.key+" = "+e.duration.toPrecision(4)+";\n    "},progress:function(e){return 0===e.duration?"float progress = 1.0;":"\n      float progress = clamp(time - cDelay"+e.key+", 0.0, cDuration"+e.key+") / cDuration"+e.key+";\n      "+(e.transition.ease?"progress = "+e.transition.ease+"(progress"+(e.transition.easeParams?", "+e.transition.easeParams.map(function(e){return e.toPrecision(4)}).join(", "):"")+");":"")+"\n      "},renderCheck:function(e){return"if (time < "+e.start.toPrecision(4)+" || time > "+(e.end+e.trail).toPrecision(4)+") return;"}},x={compiler:function(e){return"\n    "+_.delayDuration(e)+"\n    "+_.vec3("cTranslateFrom"+e.key,e.transition.from,2)+"\n    "+_.vec3("cTranslateTo"+e.key,e.transition.to,2)+"\n    \n    void applyTransform"+e.key+"(float time, inout vec3 v) {\n    \n      "+_.renderCheck(e)+"\n      "+_.progress(e)+"\n    \n      v += mix(cTranslateFrom"+e.key+", cTranslateTo"+e.key+", progress);\n    }\n    "},defaultFrom:new n.Vector3(0,0,0)};h.register("translate",x);var y={compiler:function(e){var n=e.transition.origin;return"\n    "+_.delayDuration(e)+"\n    "+_.vec3("cScaleFrom"+e.key,e.transition.from,2)+"\n    "+_.vec3("cScaleTo"+e.key,e.transition.to,2)+"\n    "+(n?_.vec3("cOrigin"+e.key,n,2):"")+"\n    \n    void applyTransform"+e.key+"(float time, inout vec3 v) {\n    \n      "+_.renderCheck(e)+"\n      "+_.progress(e)+"\n    \n      "+(n?"v -= cOrigin"+e.key+";":"")+"\n      v *= mix(cScaleFrom"+e.key+", cScaleTo"+e.key+", progress);\n      "+(n?"v += cOrigin"+e.key+";":"")+"\n    }\n    "},defaultFrom:new n.Vector3(1,1,1)};h.register("scale",y);var b={compiler:function(e){var t=new n.Vector4(e.transition.from.axis.x,e.transition.from.axis.y,e.transition.from.axis.z,e.transition.from.angle),r=e.transition.to.axis||e.transition.from.axis,i=new n.Vector4(r.x,r.y,r.z,e.transition.to.angle),a=e.transition.origin;return"\n    "+_.delayDuration(e)+"\n    "+_.vec4("cRotationFrom"+e.key,t,8)+"\n    "+_.vec4("cRotationTo"+e.key,i,8)+"\n    "+(a?_.vec3("cOrigin"+e.key,a,2):"")+"\n    \n    void applyTransform"+e.key+"(float time, inout vec3 v) {\n      "+_.renderCheck(e)+"\n      "+_.progress(e)+"\n\n      "+(a?"v -= cOrigin"+e.key+";":"")+"\n      vec3 axis = normalize(mix(cRotationFrom"+e.key+".xyz, cRotationTo"+e.key+".xyz, progress));\n      float angle = mix(cRotationFrom"+e.key+".w, cRotationTo"+e.key+".w, progress);\n      vec4 q = quatFromAxisAngle(axis, angle);\n      v = rotateVector(q, v);\n      "+(a?"v += cOrigin"+e.key+";":"")+"\n    }\n    "},defaultFrom:{axis:new n.Vector3,angle:0}};h.register("rotate",b),e.BasicAnimationMaterial=r,e.LambertAnimationMaterial=i,e.PhongAnimationMaterial=a,e.StandardAnimationMaterial=o,e.PointsAnimationMaterial=s,e.DepthAnimationMaterial=f,e.DistanceAnimationMaterial=l,e.PrefabBufferGeometry=c,e.MultiPrefabBufferGeometry=u,e.ModelBufferGeometry=p,e.PointBufferGeometry=d,e.ShaderChunk=g,e.Timeline=h,e.TimelineSegment=m,e.TimelineChunks=_,e.TranslationSegment=x,e.ScaleSegment=y,e.RotationSegment=b,e.Utils=v,Object.defineProperty(e,"__esModule",{value:!0})});
