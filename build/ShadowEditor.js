(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.Shadow = {}));
}(this, function (exports) { 'use strict';

	window.URL = window.URL || window.webkitURL;
	window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;

	Number.prototype.format = function () {
	  return this.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1,");
	};

	String.prototype.format = function () {
	  var str = this;

	  for (var i = 0; i < arguments.length; i++) {
	    str = str.replace('{' + i + '}', arguments[i]);
	  }

	  return str;
	}; // TODO: three.js bug THREE.js linearRampToValueAtTime cost too much CPU.


	THREE.AudioListener.prototype.updateMatrixWorld = function () {
	  var position = new THREE.Vector3();
	  var quaternion = new THREE.Quaternion();
	  var scale = new THREE.Vector3();
	  var orientation = new THREE.Vector3();
	  var clock = new THREE.Clock();
	  return function updateMatrixWorld(force) {
	    THREE.Object3D.prototype.updateMatrixWorld.call(this, force); // var listener = this.context.listener;
	    // var up = this.up;

	    this.timeDelta = clock.getDelta();
	    this.matrixWorld.decompose(position, quaternion, scale); // orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	    // if ( listener.positionX ) {
	    //     // code path for Chrome (see #14393)
	    //     var endTime = this.context.currentTime + this.timeDelta;
	    //     listener.positionX.linearRampToValueAtTime( position.x, endTime );
	    //     listener.positionY.linearRampToValueAtTime( position.y, endTime );
	    //     listener.positionZ.linearRampToValueAtTime( position.z, endTime );
	    //     listener.forwardX.linearRampToValueAtTime( orientation.x, endTime );
	    //     listener.forwardY.linearRampToValueAtTime( orientation.y, endTime );
	    //     listener.forwardZ.linearRampToValueAtTime( orientation.z, endTime );
	    //     listener.upX.linearRampToValueAtTime( up.x, endTime );
	    //     listener.upY.linearRampToValueAtTime( up.y, endTime );
	    //     listener.upZ.linearRampToValueAtTime( up.z, endTime );
	    // } else {
	    //     listener.setPosition( position.x, position.y, position.z );
	    //     listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
	    // }
	  };
	}();

	var applyMatrix4 = "\r\nvec3 applyMatrix4(vec3 v, mat4 m) {\r\n    float x = v.x;\r\n    float y = v.y;\r\n    float z = v.z;\r\n    \r\n    float w = 1.0 / ( m[0][3] * x + m[1][3] * y + m[2][3] * z + m[3][3] );\r\n\r\n    return vec3(\r\n        (m[0][0] * x + m[1][0] * y + m[2][0] * z + m[3][0]) * w,\r\n        (m[0][1] * x + m[1][1] * y + m[2][1] * z + m[3][1]) * w,\r\n        (m[0][2] * x + m[1][2] * y + m[2][2] * z + m[3][2] ) * w\r\n    );\r\n}";

	var lengthSq = "\r\nfloat lengthSq(vec3 v) {\r\n    return v.x * v.x + v.y * v.y + v.z * v.z;\r\n}";

	var angleTo = "#include <lengthSq>\r\n\r\n\r\nfloat angleTo(vec3 v1, vec3 v2) {\r\n    float theta = dot(v1, v2) / sqrt(lengthSq(v1) * lengthSq(v2) );\r\n    \r\n    // clamp, to handle numerical problems\r\n    return acos(clamp(theta, -1.0, 1.0));\r\n}";

	var makeOrthographic = "\r\nmat4 makeOrthographic(float left, float right, float top, float bottom, float near, float far) {\r\n    float w = 1.0 / ( right - left );\r\n    float h = 1.0 / ( top - bottom );\r\n    float p = 1.0 / ( far - near );\r\n    \r\n    float x = ( right + left ) * w;\r\n    float y = ( top + bottom ) * h;\r\n    float z = ( far + near ) * p;\r\n\r\n    return mat4(\r\n        2 * w, 0.0,     0.0,      0.0,\r\n        0.0,   2.0 * h, 0.0,      0.0,\r\n        0.0,   0.0,     -2.0 * p, 0.0,\r\n        -x,    -y,      -z,       1.0\r\n    );\r\n}";

	var makePerspective = "\r\nmat4 makePerspective(float left, float right, float top, float bottom, float near, float far) {\r\n    float x = 2.0 * near / ( right - left );\r\n    float y = 2.0 * near / ( top - bottom );\r\n    \r\n    float a = ( right + left ) / ( right - left );\r\n    float b = ( top + bottom ) / ( top - bottom );\r\n    float c = - ( far + near ) / ( far - near );\r\n    float d = - 2.0 * far * near / ( far - near );\r\n\r\n    return mat4(\r\n        x,   0.0, 0.0, 0.0,\r\n        0.0, y,   0.0, 0.0,\r\n        a,   b,   c,   -1.0,\r\n        0.0, 0.0, d,   0.0\r\n    );\r\n}";

	var makePerspective2 = "#include <makePerspective>\r\n\r\n\r\nmat4 makePerspective2(float fov, float aspect, float near, float far) {\r\n    const float DEG2RAD = 0.017453292519943295; // PI / 180\r\n\r\n    float top = near * tan( DEG2RAD * 0.5 * fov );\r\n\tfloat height = 2.0 * top;\r\n\tfloat width = aspect * height;\r\n\tfloat left = - 0.5 * width;\r\n    \r\n    return makePerspective(left, left + width, top, top - height, near, far );\r\n}";

	var determinant = "\r\nfloat determinant(mat4 te) {\r\n    float n11 = te[0][0], n12 = te[1][0], n13 = te[2][0], n14 = te[3][0];\r\n\tfloat n21 = te[0][1], n22 = te[1][1], n23 = te[2][1], n24 = te[3][1];\r\n\tfloat n31 = te[0][2], n32 = te[1][2], n33 = te[2][2], n34 = te[3][2];\r\n\tfloat n41 = te[0][3], n42 = te[1][3], n43 = te[2][3], n44 = te[3][3];\r\n\r\n\t//TODO: make this more efficient\r\n\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\treturn (\r\n\t\tn41 * (\r\n\t\t\t+ n14 * n23 * n32\r\n\t\t\t - n13 * n24 * n32\r\n\t\t\t - n14 * n22 * n33\r\n\t\t\t + n12 * n24 * n33\r\n\t\t\t + n13 * n22 * n34\r\n\t\t\t - n12 * n23 * n34\r\n\t\t) +\r\n\t\tn42 * (\r\n\t\t\t+ n11 * n23 * n34\r\n\t\t\t - n11 * n24 * n33\r\n\t\t\t + n14 * n21 * n33\r\n\t\t\t - n13 * n21 * n34\r\n\t\t\t + n13 * n24 * n31\r\n\t\t\t - n14 * n23 * n31\r\n\t\t) +\r\n\t\tn43 * (\r\n\t\t\t+ n11 * n24 * n32\r\n\t\t\t - n11 * n22 * n34\r\n\t\t\t - n14 * n21 * n32\r\n\t\t\t + n12 * n21 * n34\r\n\t\t\t + n14 * n22 * n31\r\n\t\t\t - n12 * n24 * n31\r\n\t\t) +\r\n\t\tn44 * (\r\n\t\t\t- n13 * n22 * n31\r\n\t\t\t - n11 * n23 * n32\r\n\t\t\t + n11 * n22 * n33\r\n\t\t\t + n13 * n21 * n32\r\n\t\t\t - n12 * n21 * n33\r\n\t\t\t + n12 * n23 * n31\r\n\t\t)\r\n\t);\r\n}";

	var compose = "\r\nmat4 compose( vec3 position, vec4 quaternion, vec3 scale ) {\r\n\tfloat x = quaternion.x,\r\n          y = quaternion.y,\r\n          z = quaternion.z,\r\n          w = quaternion.w;\r\n\r\n\tfloat x2 = x + x,\r\n          y2 = y + y,\r\n          z2 = z + z;\r\n\r\n\tfloat xx = x * x2, xy = x * y2, xz = x * z2;\r\n\tfloat yy = y * y2, yz = y * z2, zz = z * z2;\r\n\tfloat wx = w * x2, wy = w * y2, wz = w * z2;\r\n\t\r\n    float sx = scale.x, sy = scale.y, sz = scale.z;\r\n\r\n    return mat4(\r\n        ( 1.0 - ( yy + zz ) ) * sx,\r\n        ( xy + wz ) * sx,\r\n        ( xz - wy ) * sx,\r\n        0.0,\r\n        ( xy - wz ) * sy,\r\n        ( 1.0 - ( xx + zz ) ) * sy,\r\n        ( yz + wx ) * sy,\r\n        0.0,\r\n        ( xz + wy ) * sz,\r\n        ( yz - wx ) * sz,\r\n        ( 1.0 - ( xx + yy ) ) * sz,\r\n        0.0,\r\n        position.x,\r\n        position.y,\r\n        position.z,\r\n        1.0\r\n    );\r\n}";

	var decomposeMatrix = "#include <determinant>\r\n\r\n\r\nvoid decomposeMatrix(in mat4 te, out mat4 position, out mat4 rotation, out mat4 scale) {\r\n    float sx = length(vec3(te[0][0], te[0][1], te[0][2]));\r\n    float sy = length(vec3(te[1][0], te[1][1], te[1][2]));\r\n    float sz = length(vec3(te[2][0], te[2][1], te[2][2]));\r\n    \r\n    // if determine is negative, we need to invert one scale\r\n\tfloat det = determinant(te);\r\n    \r\n    if (det < 0.0) sx = -sx;\r\n\r\n\tposition = mat4(\r\n\t\t1.0, 0.0, 0.0, 0.0,\r\n\t\t0.0, 1.0, 0.0, 0.0,\r\n\t\t0.0, 0.0, 1.0, 0.0,\r\n\t\tte[3][0], te[3][1], te[3][2], 1.0\r\n\t);\r\n    \r\n    // scale the rotation part\r\n    float invSX = 1.0 / sx;\r\n\tfloat invSY = 1.0 / sy;\r\n\tfloat invSZ = 1.0 / sz;\r\n\r\n\trotation = mat4(\r\n\t\tte[0][0] * invSX, te[0][1] * invSX, te[0][2] * invSX, 0.0,\r\n\t\tte[1][0] * invSY, te[1][1] * invSY, te[1][2] * invSY, 0.0,\r\n\t\tte[2][0] * invSZ, te[2][1] * invSZ, te[2][2] * invSZ, 0.0,\r\n\t\t0.0,              0.0,              0.0,              1.0\r\n\t);\r\n    \r\n\tscale = mat4(\r\n\t\tsx, 0.0, 0.0, 0.0,\r\n\t\t0.0, sy, 0.0, 0.0,\r\n\t\t0.0, 0.0, sz, 0.0,\r\n\t\t0.0, 0.0, 0.0, 1.0\r\n\t);\r\n}";

	var mercator = "\r\nvec2 mercator(vec2 lonlat) \r\n{\r\n    return vec2(\r\n        lonlat.x,\r\n        log(tan((PI / 2.0 + lonlat.y) / 2.0))\r\n    );\r\n}";

	var mercatorInvert = "\r\nvec2 mercatorInvert(vec2 mercatorXY) \r\n{\r\n    return vec2(\r\n        mercatorXY.x,\r\n        2.0 * atan(exp(mercatorXY.y)) - PI / 2.0\r\n    );\r\n}";

	Object.assign(THREE.ShaderChunk, {
	  // vec3
	  applyMatrix4: applyMatrix4,
	  lengthSq: lengthSq,
	  angleTo: angleTo,
	  // mat4
	  makeOrthographic: makeOrthographic,
	  makePerspective: makePerspective,
	  makePerspective2: makePerspective2,
	  determinant: determinant,
	  compose: compose,
	  decomposeMatrix: decomposeMatrix,
	  // geo
	  mercator: mercator,
	  mercatorInvert: mercatorInvert
	});

	/**
	 * 配置选项
	 * @author tengge / https://github.com/tengge1
	 * @param {*} options 配置选项
	 */
	function Options(options = {}) {
	  // 服务端配置
	  this.server = options.server === undefined ? location.origin : options.server; // 服务端地址

	  if (!this.server.startsWith('http') && this.server !== '.') {
	    this.server = `http://${this.server}`;
	  }

	  this.sceneType = options.sceneType === undefined ? 'Empty' : options.sceneType; // 场景类型：Empty, GIS
	  // 阴影配置

	  this.shadowMapType = THREE.PCFSoftShadowMap; // gamma校正

	  this.gammaInput = false;
	  this.gammaOutput = false;
	  this.gammaFactor = 2.0; // 滤镜

	  this.hueRotate = 0;
	  this.saturate = 1;
	  this.brightness = 1;
	  this.blur = 0;
	  this.contrast = 1;
	  this.grayscale = 0;
	  this.invert = 0;
	  this.sepia = 0;
	}

	const PackageList = [{
	  name: 'NRRDLoader',
	  assets: ['assets/js/misc/Volume.js', 'assets/js/misc/VolumeSlice.js', 'assets/js/loaders/NRRDLoader.js']
	}, {
	  name: '3MFLoader',
	  assets: ['assets/js/loaders/3MFLoader.js']
	}, {
	  name: 'AMFLoader',
	  assets: ['assets/js/loaders/AMFLoader.js']
	}, {
	  name: 'AssimpLoader',
	  assets: ['assets/js/loaders/AssimpLoader.js']
	}, {
	  name: 'AWDLoader',
	  assets: ['assets/js/loaders/AWDLoader.js']
	}, {
	  name: 'BabylonLoader',
	  assets: ['assets/js/loaders/BabylonLoader.js']
	}, {
	  name: 'BinaryLoader',
	  assets: ['assets/js/loaders/BinaryLoader.js']
	}, {
	  name: 'BVHLoader',
	  assets: ['assets/js/loaders/BVHLoader.js']
	}, {
	  name: 'ColladaLoader',
	  assets: ['assets/js/loaders/ColladaLoader.js']
	}, {
	  name: 'FBXLoader',
	  assets: ['assets/js/curves/NURBSCurve.js', 'assets/js/curves/NURBSUtils.js', 'assets/js/loaders/FBXLoader.js']
	}, {
	  name: 'GCodeLoader',
	  assets: ['assets/js/loaders/GCodeLoader.js']
	}, {
	  name: 'DRACOLoader',
	  assets: ['assets/js/loaders/DRACOLoader.js']
	}, {
	  name: 'GLTFLoader',
	  assets: ['assets/js/loaders/GLTFLoader.js']
	}, {
	  name: 'LegacyJSONLoader',
	  assets: ['assets/js/loaders/deprecated/LegacyJSONLoader.js']
	}, {
	  name: 'KMZLoader',
	  assets: ['assets/js/loaders/KMZLoader.js']
	}, {
	  name: 'MD2Loader',
	  assets: ['assets/js/loaders/MD2Loader.js', 'assets/js/MD2Character.js']
	}, {
	  name: 'OBJLoader',
	  assets: ['assets/js/loaders/OBJLoader.js']
	}, {
	  name: 'OBJLoader2',
	  assets: ['assets/js/loaders/OBJLoader2.js']
	}, {
	  name: 'PCDLoader',
	  assets: ['assets/js/loaders/PCDLoader.js']
	}, {
	  name: 'PDBLoader',
	  assets: ['assets/js/loaders/PDBLoader.js']
	}, {
	  name: 'PLYLoader',
	  assets: ['assets/js/loaders/PLYLoader.js']
	}, {
	  name: 'PRWMLoader',
	  assets: ['assets/js/loaders/PRWMLoader.js']
	}, {
	  name: 'STLLoader',
	  assets: ['assets/js/loaders/STLLoader.js']
	}, {
	  name: 'TDSLoader',
	  assets: ['assets/js/loaders/TDSLoader.js']
	}, {
	  name: 'VRMLoader',
	  assets: ['assets/js/loaders/VRMLoader.js']
	}, {
	  name: 'VRMLLoader',
	  assets: ['assets/js/loaders/VRMLLoader.js']
	}, {
	  name: 'VTKLoader',
	  assets: ['assets/js/loaders/VTKLoader.js']
	}, {
	  name: 'CTMLoader',
	  assets: ['assets/js/libs/ctm.js', 'assets/js/loaders/ctm/CTMLoader.js']
	}, {
	  name: 'XLoader',
	  assets: ['assets/js/loaders/XLoader.js']
	}, {
	  name: 'SEA3D',
	  assets: ['assets/js/loaders/sea3d/SEA3D.js', 'assets/js/loaders/sea3d/SEA3DLZMA.js', 'assets/js/loaders/sea3d/SEA3DLoader.js', 'assets/js/libs/draco/draco_decoder.js', 'assets/js/loaders/sea3d/SEA3DDraco.js']
	}, {
	  name: 'lzma',
	  assets: ['assets/js/libs/lzma.js']
	}, {
	  name: 'codemirror',
	  assets: ['assets/css/codemirror.css', 'assets/css/theme/monokai.css', 'assets/js/codemirror.js', 'assets/js/mode/javascript.js', 'assets/js/mode/glsl.js']
	}, {
	  name: 'codemirror-addon',
	  assets: ['assets/css/addon/dialog.css', 'assets/css/addon/show-hint.css', 'assets/css/addon/tern.css', 'assets/js/addon/dialog.js', 'assets/js/addon/show-hint.js']
	}, {
	  name: 'esprima',
	  assets: ['assets/js/esprima.js']
	}, {
	  name: 'jsonlint',
	  assets: ['assets/js/jsonlint.js']
	}, {
	  name: 'glslprep',
	  assets: ['assets/js/glslprep.min.js']
	}, {
	  name: 'acorn',
	  assets: ['assets/js/acorn/acorn.js', 'assets/js/acorn/acorn_loose.js', 'assets/js/acorn/walk.js']
	}, {
	  name: 'ternjs',
	  assets: ['assets/js/addon/tern.js', 'assets/js/ternjs/polyfill.js', 'assets/js/ternjs/signal.js', 'assets/js/ternjs/tern.js', 'assets/js/ternjs/def.js', 'assets/js/ternjs/comment.js', 'assets/js/ternjs/infer.js', 'assets/js/ternjs/doc_comment.js', 'assets/js/tern-threejs/threejs.js']
	}, {
	  name: 'line',
	  assets: ['assets/js/lines/LineSegmentsGeometry.js', 'assets/js/lines/LineGeometry.js', 'assets/js/lines/WireframeGeometry2.js', 'assets/js/lines/LineMaterial.js', 'assets/js/lines/LineSegments2.js', 'assets/js/lines/Line2.js', 'assets/js/lines/Wireframe.js']
	}, {
	  name: 'GLTFExporter',
	  assets: ['assets/js/exporters/GLTFExporter.js']
	}, {
	  name: 'OBJExporter',
	  assets: ['assets/js/exporters/OBJExporter.js']
	}, {
	  name: 'PLYExporter',
	  assets: ['assets/js/exporters/PLYExporter.js']
	}, {
	  name: 'STLBinaryExporter',
	  assets: ['assets/js/exporters/STLBinaryExporter.js']
	}, {
	  name: 'STLExporter',
	  assets: ['assets/js/exporters/STLExporter.js']
	}, {
	  name: 'MMD',
	  assets: ['assets/js/libs/mmdparser.min.js', 'assets/js/loaders/MMDLoader.js', 'assets/js/animation/CCDIKSolver.js', 'assets/js/animation/MMDPhysics.js', 'assets/js/animation/MMDAnimationHelper.js']
	}, {
	  name: 'gl-matrix',
	  assets: ['assets/js/libs/gl-matrix.js']
	}, {
	  name: 'pako',
	  assets: ['assets/js/libs/pako.js']
	}, {
	  name: 'NormalMapShader',
	  assets: ['assets/js/shaders/NormalMapShader.js']
	}, {
	  name: 'FXAAShader',
	  assets: ['assets/js/shaders/FXAAShader.js']
	}, {
	  name: 'DotScreenShader',
	  assets: ['assets/js/shaders/DotScreenShader.js']
	}, {
	  name: 'RGBShiftShader',
	  assets: ['assets/js/shaders/RGBShiftShader.js']
	}, {
	  name: 'AfterimageShader',
	  assets: ['assets/js/shaders/AfterimageShader.js']
	}, {
	  name: 'BokehShader',
	  assets: ['assets/js/shaders/BokehShader.js']
	}, {
	  name: 'DigitalGlitch',
	  assets: ['assets/js/shaders/DigitalGlitch.js']
	}, {
	  name: 'HalftoneShader',
	  assets: ['assets/js/shaders/HalftoneShader.js']
	}, {
	  name: 'DepthLimitedBlurShader',
	  assets: ['assets/js/shaders/DepthLimitedBlurShader.js']
	}, {
	  name: 'UnpackDepthRGBAShader',
	  assets: ['assets/js/shaders/UnpackDepthRGBAShader.js']
	}, {
	  name: 'PixelShader',
	  assets: ['assets/js/shaders/PixelShader.js']
	}, {
	  name: 'SAOShader',
	  assets: ['assets/js/shaders/SAOShader.js']
	}, {
	  name: 'SMAAShader',
	  assets: ['assets/js/shaders/SMAAShader.js']
	}, {
	  name: 'SSAOShader',
	  assets: ['assets/js/shaders/SSAOShader.js']
	}, {
	  name: 'MaskPass',
	  assets: ['assets/js/postprocessing/MaskPass.js']
	}, {
	  name: 'AfterimagePass',
	  assets: ['assets/js/postprocessing/AfterimagePass.js']
	}, {
	  name: 'BokehPass',
	  assets: ['assets/js/postprocessing/BokehPass.js']
	}, {
	  name: 'GlitchPass',
	  assets: ['assets/js/postprocessing/GlitchPass.js']
	}, {
	  name: 'HalftonePass',
	  assets: ['assets/js/postprocessing/HalftonePass.js']
	}, {
	  name: 'SSAARenderPass',
	  assets: ['assets/js/postprocessing/SSAARenderPass.js']
	}, {
	  name: 'SMAAPass',
	  assets: ['assets/js/postprocessing/SMAAPass.js']
	}, {
	  name: 'TAARenderPass',
	  assets: ['assets/js/postprocessing/TAARenderPass.js']
	}, {
	  name: 'CopyShader',
	  assets: ['assets/js/shaders/CopyShader.js']
	}, {
	  name: 'EffectComposer',
	  assets: ['assets/js/postprocessing/EffectComposer.js']
	}, {
	  name: 'RenderPass',
	  assets: ['assets/js/postprocessing/RenderPass.js']
	}, {
	  name: 'ShaderPass',
	  assets: ['assets/js/postprocessing/ShaderPass.js']
	}, {
	  name: 'OutlinePass',
	  assets: ['assets/js/postprocessing/OutlinePass.js']
	}, {
	  name: 'SAOPass',
	  assets: ['assets/js/postprocessing/SAOPass.js']
	}, {
	  name: 'SSAOPass',
	  assets: ['assets/js/postprocessing/SSAOPass.js']
	}, {
	  name: 'FirstPersonControls',
	  assets: ['assets/js/controls/FirstPersonControls.js']
	}, {
	  name: 'FlyControls',
	  assets: ['assets/js/controls/FlyControls.js']
	}, {
	  name: 'EditorControls',
	  assets: ['assets/js/controls/EditorControls.js']
	}, {
	  name: 'OrbitControls',
	  assets: ['assets/js/controls/OrbitControls.js']
	}, {
	  name: 'PointerLockControls',
	  assets: ['assets/js/controls/PointerLockControls.js']
	}, {
	  name: 'TrackballControls',
	  assets: ['assets/js/controls/TrackballControls.js']
	}, {
	  name: 'TransformControls',
	  assets: ['assets/js/controls/TransformControls.js']
	}, {
	  name: 'SPE',
	  assets: ['assets/js/SPE.js']
	}, {
	  name: 'VolumetricFire',
	  assets: ['assets/js/VolumetricFire.js']
	}, {
	  name: 'ammo',
	  assets: ['assets/js/libs/ammo.js']
	}, {
	  name: 'chevrotain',
	  assets: ['assets/js/libs/chevrotain.min.js']
	}, {
	  name: 'TexGen',
	  assets: ['assets/js/libs/TexGen.js']
	}, {
	  name: 'ColladaExporter',
	  assets: ['assets/js/exporters/ColladaExporter.js']
	}, {
	  name: 'DRACOExporter',
	  assets: ['assets/js/libs/draco/draco_encoder.js', 'assets/js/exporters/DRACOExporter.js']
	}, {
	  name: 'MTLLoader',
	  assets: ['assets/js/loaders/MTLLoader.js']
	}, {
	  name: 'LoaderSupport',
	  assets: ['assets/js/loaders/LoaderSupport.js']
	}];

	/**
	 * CSS下载器
	 * @author tengge / https://github.com/tengge1
	 */
	function CssLoader() {}

	CssLoader.prototype.load = function (url) {
	  var head = document.getElementsByTagName('head')[0];
	  var link = document.createElement('link');
	  link.type = 'text/css';
	  link.rel = 'stylesheet';
	  link.href = url;
	  head.appendChild(link);
	  return new Promise(resolve => {
	    link.onload = event => {
	      link.onload = link.onerror = null;
	      resolve(link);
	    };

	    link.onerror = event => {
	      link.onload = link.onerror = null;
	      console.warn(`CssLoader: ${url} loaded failed.`);
	      resolve(null);
	    };
	  });
	};

	/**
	 * JS下载器
	 * @author tengge / https://github.com/tengge1
	 */
	function JsLoader() {
	  this.assets = [];
	}

	JsLoader.prototype.load = function (url) {
	  var data = {
	    url,
	    script: null
	  };
	  this.assets.push(data);
	  return new Promise(resolve => {
	    fetch(url).then(response => {
	      if (response.ok) {
	        response.text().then(text => {
	          data.script = text;
	          resolve(data);
	        });
	      } else {
	        console.warn(`JsLoader: ${url} loaded failed.`);
	        resolve(null);
	      }
	    }).catch(() => {
	      console.warn(`JsLoader: ${url} loaded failed.`);
	      resolve(null);
	    });
	  });
	};

	JsLoader.prototype.eval = function () {
	  var eval2 = eval;
	  var script = '';
	  this.assets.forEach(n => {
	    if (n.script) {
	      script += n.script + '\n';
	    }
	  });

	  if (script) {
	    eval2.call(window, script);
	  }
	};

	const loaded = new Map();
	/**
	 * 包管理器
	 * @author tengge / https://github.com/tengge1
	 */

	function PackageManager() {}
	/**
	 * 加载包
	 * @param {*} names 包名或包名列表
	 */

	PackageManager.prototype.require = function (names) {
	  names = Array.isArray(names) ? names : [names];
	  var promises = [];
	  names.forEach(n => {
	    if (loaded.has(n) && loaded.get(n).loading === true) {
	      promises.push(loaded.get(n).promise);
	    } else if (!loaded.has(n)) {
	      var promise = Promise.all(promises).then(() => {
	        var packages = PackageList.filter(m => m.name === n);

	        if (packages.length === 0) {
	          console.warn(`PackageManager: ${n} does not exist.`);
	          return;
	        } else if (packages.length > 1) {
	          console.warn(`PackageManager: Package name ${n} duplicated.`);
	        }

	        var assets = [];
	        packages.forEach(m => {
	          assets.push.apply(assets, m.assets);
	        });
	        return this._load(assets).then(() => {
	          loaded.set(n, {
	            loading: false,
	            loaded: true,
	            promise: null
	          });
	          return new Promise(resolve => {
	            resolve();
	          });
	        });
	      });
	      loaded.set(n, {
	        loading: true,
	        loaded: false,
	        promise: promise
	      });
	      promises.push(promise);
	    }
	  });
	  return Promise.all(promises);
	};

	PackageManager.prototype._load = function (assets = []) {
	  var cssLoader = new CssLoader();
	  var jsLoader = new JsLoader();
	  var promises = assets.map(n => {
	    if (n.toLowerCase().endsWith('.css')) {
	      return cssLoader.load(n);
	    } else if (n.toLowerCase().endsWith('.js')) {
	      return jsLoader.load(n);
	    } else {
	      console.warn(`PackageManager: unknown assets ${n}.`);
	      return new Promise(resolve => {
	        resolve();
	      });
	    }
	  });
	  return Promise.all(promises).then(() => {
	    jsLoader.eval();
	    return new Promise(resolve => {
	      resolve();
	    });
	  });
	};

	/**
	 * 场景序列化信息
	 * @author tengge / https://github.com/tengge1
	 */
	var Metadata = {
	  generator: 'ShadowEditor',
	  type: 'Object',
	  version: '0.0.1'
	};

	var ID = -1;
	/**
	 * 序列化器基类
	 * @author tengge / https://github.com/tengge1
	 */

	function BaseSerializer() {
	  this.id = 'BaseSerializer' + ID--;
	  this.metadata = Object.assign({}, Metadata, {
	    generator: this.constructor.name
	  });
	}
	/**
	 *对象转json
	 * @param {*} obj 对象
	 */


	BaseSerializer.prototype.toJSON = function (obj) {
	  var json = {
	    metadata: this.metadata
	  };
	  return json;
	};
	/**
	 * json转对象
	 * @param {*} json json对象
	 * @param {*} parent 父对象
	 */


	BaseSerializer.prototype.fromJSON = function (json, parent) {
	  if (parent) {
	    return parent;
	  }

	  return {};
	};

	/**
	 * Object3DSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function Object3DSerializer() {
	  BaseSerializer.call(this);
	}

	Object3DSerializer.prototype = Object.create(BaseSerializer.prototype);
	Object3DSerializer.prototype.constructor = Object3DSerializer;

	Object3DSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.castShadow = obj.castShadow;
	  json.children = obj.children.map(child => {
	    return child.uuid;
	  });
	  json.frustumCulled = obj.frustumCulled;
	  json.layers = obj.layers;
	  json.matrix = obj.matrix;
	  json.matrixAutoUpdate = obj.matrixAutoUpdate;
	  json.matrixWorld = obj.matrixWorld;
	  json.matrixWorldNeedsUpdate = obj.matrixWorldNeedsUpdate;
	  json.modelViewMatrix = obj.modelViewMatrix;
	  json.name = obj.name;
	  json.normalMatrix = obj.normalMatrix;
	  json.parent = obj.parent == null ? null : obj.parent.uuid;
	  json.position = obj.position;
	  json.quaternion = {
	    x: obj.quaternion.x,
	    y: obj.quaternion.y,
	    z: obj.quaternion.z,
	    w: obj.quaternion.w
	  };
	  json.receiveShadow = obj.receiveShadow;
	  json.renderOrder = obj.renderOrder;
	  json.rotation = {
	    x: obj.rotation.x,
	    y: obj.rotation.y,
	    z: obj.rotation.z,
	    order: obj.rotation.order
	  };
	  json.scale = obj.scale;
	  json.type = obj.type;
	  json.up = obj.up;
	  json.userData = {};
	  Object.assign(json.userData, obj.userData); // 重要bug：由于obj.userData.obj缓存下载模型
	  // 如果不把json.userData上的obj删除，则会导致播放器中的obj和场景中的obj是同一个。

	  delete json.userData.obj;
	  delete json.userData.root;
	  delete json.userData.helper;
	  json.uuid = obj.uuid;
	  json.visible = obj.visible;
	  json.isObject3D = obj.isObject3D;
	  return json;
	};

	Object3DSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.Object3D() : parent;
	  BaseSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.castShadow = json.castShadow;
	  obj.frustumCulled = json.frustumCulled;
	  obj.type = json.type;
	  obj.uuid = json.uuid;
	  obj.matrix.copy(json.matrix);
	  obj.matrixAutoUpdate = json.matrixAutoUpdate;
	  obj.name = json.name;
	  obj.position.copy(json.position);
	  obj.quaternion.copy(json.quaternion);
	  obj.receiveShadow = json.receiveShadow;
	  obj.renderOrder = json.renderOrder;
	  obj.rotation.set(json.rotation.x, json.rotation.y, json.rotation.z, json.rotation.order);
	  obj.scale.copy(json.scale);
	  obj.up.copy(json.up);
	  obj.visible = json.visible;

	  for (var i in json.userData) {
	    if (json.userData[i]) {
	      obj.userData[i] = json.userData[i];
	    }
	  }

	  return obj;
	};

	/**
	 * 产生一个单像素画布
	 * @param {*} color 默认颜色
	 */
	function onePixelCanvas(color = '#000000') {
	  var canvas = document.createElement('canvas');
	  canvas.width = 1;
	  canvas.height = 1;
	  var ctx = canvas.getContext('2d');
	  ctx.fillStyle = color;
	  ctx.fillRect(0, 0, 1, 1);
	  return canvas;
	}
	/**
	 * 图片工具类
	 */


	const ImageUtils = {
	  onePixelCanvas: onePixelCanvas
	};

	/**
	 * TextureSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TextureSerializer() {
	  BaseSerializer.call(this);
	}

	TextureSerializer.prototype = Object.create(BaseSerializer.prototype);
	TextureSerializer.prototype.constructor = TextureSerializer;

	TextureSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.anisotropy = obj.anisotropy;
	  json.center = obj.center;
	  json.encoding = obj.encoding;
	  json.flipY = obj.flipY;
	  json.format = obj.format;
	  json.generateMipmaps = obj.generateMipmaps; // 说明：立体贴图obj.image是一个图片数组。

	  if (obj.image && !Array.isArray(obj.image) && obj.image.tagName && obj.image.tagName.toLowerCase() === 'img') {
	    // 图片
	    var src = obj.image.src;

	    if (!src.startsWith('data:') && !src.startsWith('blob')) {
	      // data和blob地址不应该被修改
	      src = src.replace(location.href, '/');
	    }

	    json.image = {
	      tagName: 'img',
	      src: src,
	      width: obj.image.width,
	      height: obj.image.height
	    };
	  } else if (obj.image && !Array.isArray(obj.image) && obj.image.tagName && obj.image.tagName.toLowerCase() === 'canvas') {
	    // 画布
	    json.image = {
	      tagName: 'canvas',
	      src: obj.image.toDataURL(),
	      width: obj.image.width,
	      height: obj.image.height
	    };
	  } else {
	    json.image = null;
	  }

	  json.magFilter = obj.magFilter;
	  json.mapping = obj.mapping;
	  json.matrix = obj.matrix;
	  json.matrixAutoUpdate = obj.matrixAutoUpdate;
	  json.minFilter = obj.minFilter;
	  json.mipmaps = obj.mipmaps;
	  json.name = obj.name;
	  json.offset = obj.offset;
	  json.premultiplyAlpha = obj.premultiplyAlpha;
	  json.repeat = obj.repeat;
	  json.rotation = obj.rotation;
	  json.type = obj.type;
	  json.unpackAlignment = obj.unpackAlignment;
	  json.uuid = obj.uuid;
	  json.version = obj.version;
	  json.wrapS = obj.wrapS;
	  json.wrapT = obj.wrapT;
	  json.isTexture = obj.isTexture;
	  json.needsUpdate = obj.needsUpdate;
	  return json;
	};

	TextureSerializer.prototype.fromJSON = function (json, parent, server) {
	  // 用一个像素的图片初始化Texture，避免图片载入前的警告信息。
	  var img = ImageUtils.onePixelCanvas();
	  var obj = parent === undefined ? new THREE.Texture(img) : parent;
	  obj.anisotropy = json.anisotropy;
	  obj.center.copy(json.center);
	  obj.encoding = json.encoding;
	  obj.flipY = json.flipY;
	  obj.format = json.format;
	  obj.generateMipmaps = json.generateMipmaps;

	  if (json.image && !Array.isArray(json.image) && json.image.tagName === 'img') {
	    // 图片
	    var img = document.createElement('img');

	    if (!json.image.src.startsWith('blob:http://')) {
	      // 这种类型不能被反序列化，例如：blob:http://localhost:2000/d6590b48-8b50-44d0-a3a7-248a8047bc89
	      if (json.image.src && json.image.src.startsWith('/')) {
	        img.src = server + json.image.src;
	      } else {
	        img.src = json.image.src;
	      }
	    }

	    img.width = json.image.width;
	    img.height = json.image.height;

	    img.onload = function () {
	      obj.image = img;
	      obj.needsUpdate = true;
	    };
	  } else if (json.image && !Array.isArray(obj.image) && json.image.tagName === 'canvas') {
	    // 画布
	    var canvas = document.createElement('canvas');
	    canvas.width = 256;
	    canvas.height = 256;
	    var ctx = canvas.getContext('2d');
	    var img = document.createElement('img');

	    if (json.image.src && json.image.src.startsWith('/')) {
	      img.src = server + json.image.src;
	    } else {
	      img.src = json.image.src;
	    }

	    img.onload = function () {
	      canvas.width = img.width;
	      canvas.height = img.height;
	      ctx.drawImage(img, 0, 0);
	      obj.needsUpdate = true;
	    };

	    obj.image = canvas;
	  }

	  obj.magFilter = json.magFilter;
	  obj.mapping = json.mapping;
	  obj.matrix.copy(json.matrix);
	  obj.matrixAutoUpdate = json.matrixAutoUpdate;
	  obj.minFilter = json.minFilter;
	  obj.mipmaps = json.mipmaps;
	  obj.name = json.name;
	  obj.offset.copy(json.offset);
	  obj.premultiplyAlpha = json.premultiplyAlpha;
	  obj.repeat.copy(json.repeat);
	  obj.rotation = json.rotation;
	  obj.type = json.type;
	  obj.unpackAlignment = json.unpackAlignment;
	  obj.uuid = json.uuid;
	  obj.version = json.version;
	  obj.wrapS = json.wrapS;
	  obj.wrapT = json.wrapT;
	  obj.isTexture = json.isTexture;
	  obj.needsUpdate = true;
	  return obj;
	};

	/**
	 * CanvasTextureSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CanvasTextureSerializer() {
	  BaseSerializer.call(this);
	}

	CanvasTextureSerializer.prototype = Object.create(BaseSerializer.prototype);
	CanvasTextureSerializer.prototype.constructor = CanvasTextureSerializer;

	CanvasTextureSerializer.prototype.toJSON = function (obj) {
	  return TextureSerializer.prototype.toJSON.call(this, obj);
	};

	CanvasTextureSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.CanvasTexture() : parent;
	  TextureSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * CompressedTextureSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CompressedTextureSerializer() {
	  BaseSerializer.call(this);
	}

	CompressedTextureSerializer.prototype = Object.create(BaseSerializer.prototype);
	CompressedTextureSerializer.prototype.constructor = CompressedTextureSerializer;

	CompressedTextureSerializer.prototype.toJSON = function (obj) {
	  return TextureSerializer.prototype.toJSON.call(this, obj);
	};

	CompressedTextureSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.CompressedTexture() : parent;
	  TextureSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * CubeTextureSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CubeTextureSerializer() {
	  BaseSerializer.call(this);
	}

	CubeTextureSerializer.prototype = Object.create(BaseSerializer.prototype);
	CubeTextureSerializer.prototype.constructor = CubeTextureSerializer;

	CubeTextureSerializer.prototype.toJSON = function (obj) {
	  var json = TextureSerializer.prototype.toJSON.call(this, obj);
	  json.image = [];
	  obj.image.forEach(n => {
	    if (n.src.startsWith('data')) {
	      // base64
	      json.image.push({
	        tagName: 'img',
	        src: n.src,
	        width: n.width,
	        height: n.height
	      });
	    } else {
	      // url
	      json.image.push({
	        tagName: 'img',
	        src: n.src.replace(location.href, '/'),
	        width: n.width,
	        height: n.height
	      });
	    }
	  });
	  return json;
	};

	CubeTextureSerializer.prototype.fromJSON = function (json, parent, server) {
	  // 用一个像素的图片初始化CubeTexture，避免图片载入前的警告信息。
	  var img = ImageUtils.onePixelCanvas();
	  var obj = parent === undefined ? new THREE.CubeTexture([img, img, img, img, img, img]) : parent;
	  TextureSerializer.prototype.fromJSON.call(this, json, obj, server);

	  if (Array.isArray(json.image)) {
	    var promises = json.image.map(n => {
	      return new Promise(resolve => {
	        var img = document.createElement('img');

	        if (n.src && n.src.startsWith('/')) {
	          img.src = server + n.src;
	        } else {
	          img.src = n.src;
	        }

	        img.width = n.width;
	        img.height = n.height;

	        img.onload = () => {
	          resolve(img);
	        };
	      });
	    });
	    Promise.all(promises).then(imgs => {
	      obj.image = imgs;
	      obj.needsUpdate = true;
	    });
	  }

	  return obj;
	};

	/**
	 * DataTextureSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function DataTextureSerializer() {
	  BaseSerializer.call(this);
	}

	DataTextureSerializer.prototype = Object.create(BaseSerializer.prototype);
	DataTextureSerializer.prototype.constructor = DataTextureSerializer;

	DataTextureSerializer.prototype.toJSON = function (obj) {
	  return TextureSerializer.prototype.toJSON.call(this, obj);
	};

	DataTextureSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.DataTexture() : parent;
	  TextureSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * DepthTextureSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function DepthTextureSerializer() {
	  BaseSerializer.call(this);
	}

	DepthTextureSerializer.prototype = Object.create(BaseSerializer.prototype);
	DepthTextureSerializer.prototype.constructor = DepthTextureSerializer;

	DepthTextureSerializer.prototype.toJSON = function (obj) {
	  return TextureSerializer.prototype.toJSON.call(this, obj);
	};

	DepthTextureSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.DataTexture() : parent;
	  TextureSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * VideoTextureSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function VideoTextureSerializer() {
	  BaseSerializer.call(this);
	}

	VideoTextureSerializer.prototype = Object.create(BaseSerializer.prototype);
	VideoTextureSerializer.prototype.constructor = VideoTextureSerializer;

	VideoTextureSerializer.prototype.toJSON = function (obj) {
	  var json = TextureSerializer.prototype.toJSON.call(this, obj);
	  json.image = {
	    tagName: 'video',
	    src: obj.image.src.replace(location.href, '/')
	  };
	  return json;
	};

	VideoTextureSerializer.prototype.fromJSON = function (json, parent, server) {
	  let video = document.createElement('video');
	  video.setAttribute('src', json.image.src);
	  video.setAttribute('autoplay', 'autoplay');
	  video.setAttribute('loop', 'loop');
	  video.setAttribute('crossorigin', 'anonymous');
	  var obj = parent === undefined ? new THREE.VideoTexture(video) : parent;
	  TextureSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	var Serializers = {
	  'CanvasTexture': CanvasTextureSerializer,
	  'CompressedTexture': CompressedTextureSerializer,
	  'CubeTexture': CubeTextureSerializer,
	  'DataTexture': DataTextureSerializer,
	  'DepthTexture': DepthTextureSerializer,
	  'VideoTexture': VideoTextureSerializer,
	  'Texture': TextureSerializer
	};
	/**
	 * TexturesSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TexturesSerializer() {
	  BaseSerializer.call(this);
	}

	TexturesSerializer.prototype = Object.create(BaseSerializer.prototype);
	TexturesSerializer.prototype.constructor = TexturesSerializer;

	TexturesSerializer.prototype.toJSON = function (obj) {
	  var serializer = Serializers[obj.constructor.name];

	  if (serializer === undefined) {
	    console.warn(`TexturesSerializer: No serializer with ${obj.type}.`);
	    return null;
	  }

	  return new serializer().toJSON(obj);
	};

	TexturesSerializer.prototype.fromJSON = function (json, parent, server) {
	  var generator = json.metadata.generator;
	  var serializer = Serializers[generator.replace('Serializer', '')];

	  if (serializer === undefined) {
	    console.warn(`TexturesSerializer: No deserializer with ${generator}.`);
	    return null;
	  }

	  return new serializer().fromJSON(json, parent, server);
	};

	/**
	 * MaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MaterialSerializer.prototype.constructor = MaterialSerializer;

	MaterialSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.alphaMap = obj.alphaMap == null ? null : new TexturesSerializer().toJSON(obj.alphaMap);
	  json.alphaTest = obj.alphaTest;
	  json.aoMap = obj.aoMap == null ? null : new TexturesSerializer().toJSON(obj.aoMap);
	  json.aoMapIntensity = obj.aoMapIntensity;
	  json.blendDst = obj.blendDst;
	  json.blendDstAlpha = obj.blendDstAlpha;
	  json.blendEquation = obj.blendEquation;
	  json.blendEquationAlpha = obj.blendEquationAlpha;
	  json.blendSrc = obj.blendSrc;
	  json.blendSrcAlpha = obj.blendSrcAlpha;
	  json.blending = obj.blending;
	  json.bumpMap = obj.bumpMap == null ? null : new TexturesSerializer().toJSON(obj.bumpMap);
	  json.bumpScale = obj.bumpScale;
	  json.clipIntersection = obj.clipIntersection;
	  json.clipShadow = obj.clipShadow;
	  json.clippingPlanes = obj.clippingPlanes;
	  json.color = obj.color;
	  json.colorWrite = obj.colorWrite;
	  json.depthFunc = obj.depthFunc;
	  json.depthTest = obj.depthTest;
	  json.depthWrite = obj.depthWrite;
	  json.displacementBias = obj.displacementBias;
	  json.displacementMap = obj.displacementMap == null ? null : new TexturesSerializer().toJSON(obj.displacementMap);
	  json.displacementScale = obj.displacementScale;
	  json.dithering = obj.dithering;
	  json.emissive = obj.emissive;
	  json.emissiveIntensity = obj.emissiveIntensity;
	  json.emissiveMap = obj.emissiveMap == null ? null : new TexturesSerializer().toJSON(obj.emissiveMap);
	  json.envMap = obj.envMap == null ? null : new TexturesSerializer().toJSON(obj.envMap);
	  json.envMapIntensity = obj.envMapIntensity;
	  json.flatShading = obj.flatShading;
	  json.fog = obj.fog;
	  json.lightMap = obj.lightMap == null ? null : new TexturesSerializer().toJSON(obj.lightMap);
	  json.lightMapIntensity = obj.lightMapIntensity;
	  json.lights = obj.lights;
	  json.linewidth = obj.linewidth;
	  json.map = obj.map == null ? null : new TexturesSerializer().toJSON(obj.map);
	  json.metalness = obj.metalness;
	  json.metalnessMap = obj.metalnessMap == null ? null : new TexturesSerializer().toJSON(obj.metalnessMap);
	  json.morphNormals = obj.morphNormals;
	  json.morphTargets = obj.morphTargets;
	  json.name = obj.name;
	  json.normalMap = obj.normalMap == null ? null : new TexturesSerializer().toJSON(obj.normalMap);
	  json.normalScale = obj.normalScale;
	  json.opacity = obj.opacity;
	  json.polygonOffset = obj.polygonOffset;
	  json.polygonOffsetFactor = obj.polygonOffsetFactor;
	  json.polygonOffsetUnits = obj.polygonOffsetUnits;
	  json.precision = obj.precision;
	  json.premultipliedAlpha = obj.premultipliedAlpha;
	  json.refractionRatio = obj.refractionRatio;
	  json.roughness = obj.roughness;
	  json.roughnessMap = obj.roughnessMap == null ? null : new TexturesSerializer().toJSON(obj.roughnessMap);
	  json.shadowSide = obj.shadowSide;
	  json.side = obj.side;
	  json.skinning = obj.skinning;
	  json.transparent = obj.transparent;
	  json.type = obj.type;
	  json.userData = obj.userData;
	  json.uuid = obj.uuid;
	  json.vertexColors = obj.vertexColors;
	  json.visible = obj.visible;
	  json.wireframe = obj.wireframe;
	  json.wireframeLinecap = obj.wireframeLinecap;
	  json.wireframeLinejoin = obj.wireframeLinejoin;
	  json.wireframeLinewidth = obj.wireframeLinewidth;
	  return json;
	};

	MaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.Material() : parent;
	  obj.alphaMap = json.alphaMap == null ? null : new TexturesSerializer().fromJSON(json.alphaMap, undefined, server);
	  obj.alphaTest = json.alphaTest;
	  obj.aoMap = json.aoMap == null ? null : new TexturesSerializer().fromJSON(json.aoMap, undefined, server);
	  obj.aoMapIntensity = json.aoMapIntensity;
	  obj.blendDst = json.blendDst;
	  obj.blendDstAlpha = json.blendDstAlpha;
	  obj.blendEquation = json.blendEquation;
	  obj.blendEquationAlpha = json.blendEquationAlpha;
	  obj.blendSrc = json.blendSrc;
	  obj.blendSrcAlpha = json.blendSrcAlpha;
	  obj.blending = json.blending;
	  obj.bumpMap = json.bumpMap == null ? null : new TexturesSerializer().fromJSON(json.bumpMap, undefined, server);
	  obj.bumpScale = json.bumpScale;
	  obj.clipIntersection = json.clipIntersection;
	  obj.clipShadow = json.clipShadow;
	  obj.clippingPlanes = json.clippingPlanes;
	  obj.color = json.color == null ? null : new THREE.Color(json.color);
	  obj.colorWrite = json.colorWrite;
	  obj.depthFunc = json.depthFunc;
	  obj.depthTest = json.depthTest;
	  obj.depthWrite = json.depthWrite;
	  obj.displacementBias = json.displacementBias;
	  obj.displacementMap = json.displacementMap == null ? null : new TexturesSerializer().fromJSON(json.displacementMap, undefined, server);
	  obj.displacementScale = json.displacementScale;
	  obj.dithering = json.dithering;
	  obj.emissive = json.emissive === undefined ? undefined : new THREE.Color(json.emissive);
	  obj.emissiveIntensity = json.emissiveIntensity;
	  obj.emissiveMap = json.emissiveMap == null ? null : new TexturesSerializer().fromJSON(json.emissiveMap, undefined, server);
	  obj.envMap = json.envMap == null ? null : new TexturesSerializer().fromJSON(json.envMap, undefined, server);
	  obj.envMapIntensity = json.envMapIntensity;
	  obj.flatShading = json.flatShading;
	  obj.fog = json.fog;
	  obj.lightMap = json.lightMap == null ? null : new TexturesSerializer().fromJSON(json.lightMap, undefined, server);
	  obj.lightMapIntensity = json.lightMapIntensity;
	  obj.lights = json.lights;
	  obj.linewidth = json.linewidth;
	  obj.map = json.map == null ? null : new TexturesSerializer().fromJSON(json.map, undefined, server);
	  obj.metalness = json.metalness;
	  obj.metalnessMap = json.metalnessMap == null ? null : new TexturesSerializer().fromJSON(json.metalnessMap, undefined, server);
	  obj.morphNormals = json.morphNormals;
	  obj.morphTargets = json.morphTargets;
	  obj.name = json.name;
	  obj.normalMap = json.normalMap == null ? null : new TexturesSerializer().fromJSON(json.normalMap, undefined, server);
	  obj.normalScale = json.normalScale == null ? null : new THREE.Vector2().copy(json.normalScale);
	  obj.opacity = json.opacity;
	  obj.polygonOffset = json.polygonOffset;
	  obj.polygonOffsetFactor = json.polygonOffsetFactor;
	  obj.polygonOffsetUnits = json.polygonOffsetUnits;
	  obj.precision = json.precision;
	  obj.premultipliedAlpha = json.premultipliedAlpha;
	  obj.refractionRatio = json.refractionRatio;
	  obj.roughness = json.roughness;
	  obj.roughnessMap = json.roughnessMap == null ? null : new TexturesSerializer().fromJSON(json.roughnessMap, undefined, server);
	  obj.shadowSide = json.shadowSide;
	  obj.side = json.side;
	  obj.skinning = json.skinning;
	  obj.transparent = json.transparent;
	  obj.type = json.type;
	  obj.userData = json.userData;
	  obj.uuid = json.uuid;
	  obj.vertexColors = json.vertexColors;
	  obj.visible = json.visible;
	  obj.wireframe = json.wireframe;
	  obj.wireframeLinecap = json.wireframeLinecap;
	  obj.wireframeLinejoin = json.wireframeLinejoin;
	  obj.wireframeLinewidth = json.wireframeLinewidth;
	  return obj;
	};

	/**
	 * LineBasicMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function LineBasicMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	LineBasicMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	LineBasicMaterialSerializer.prototype.constructor = LineBasicMaterialSerializer;

	LineBasicMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	LineBasicMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.LineBasicMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * LineDashedMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function LineDashedMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	LineDashedMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	LineDashedMaterialSerializer.prototype.constructor = LineDashedMaterialSerializer;

	LineDashedMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	LineDashedMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.LineDashedMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshBasicMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshBasicMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshBasicMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshBasicMaterialSerializer.prototype.constructor = MeshBasicMaterialSerializer;

	MeshBasicMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshBasicMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshBasicMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshDepthMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshDepthMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshDepthMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshDepthMaterialSerializer.prototype.constructor = MeshDepthMaterialSerializer;

	MeshDepthMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshDepthMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshDepthMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshDistanceMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshDistanceMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshDistanceMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshDistanceMaterialSerializer.prototype.constructor = MeshDistanceMaterialSerializer;

	MeshDistanceMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshDistanceMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshDistanceMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshFaceMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshFaceMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshFaceMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshFaceMaterialSerializer.prototype.constructor = MeshFaceMaterialSerializer;

	MeshFaceMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshFaceMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshFaceMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshLambertMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshLambertMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshLambertMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshLambertMaterialSerializer.prototype.constructor = MeshLambertMaterialSerializer;

	MeshLambertMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshLambertMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshLambertMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshNormalMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshNormalMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshNormalMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshNormalMaterialSerializer.prototype.constructor = MeshNormalMaterialSerializer;

	MeshNormalMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshNormalMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshNormalMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshPhongMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshPhongMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshPhongMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshPhongMaterialSerializer.prototype.constructor = MeshPhongMaterialSerializer;

	MeshPhongMaterialSerializer.prototype.toJSON = function (obj) {
	  let json = MaterialSerializer.prototype.toJSON.call(this, obj);
	  json.specular = obj.specular;
	  json.shininess = obj.shininess;
	  return json;
	};

	MeshPhongMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshPhongMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  obj.specular = new THREE.Color(json.specular);
	  obj.shininess = json.shininess;
	  return obj;
	};

	/**
	 * MeshPhysicalMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshPhysicalMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshPhysicalMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshPhysicalMaterialSerializer.prototype.constructor = MeshPhysicalMaterialSerializer;

	MeshPhysicalMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshPhysicalMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshPhysicalMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshStandardMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshStandardMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshStandardMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshStandardMaterialSerializer.prototype.constructor = MeshStandardMaterialSerializer;

	MeshStandardMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshStandardMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshStandardMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MeshToonMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshToonMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MeshToonMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshToonMaterialSerializer.prototype.constructor = MeshToonMaterialSerializer;

	MeshToonMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MeshToonMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MeshToonMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * MultiMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MultiMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	MultiMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	MultiMaterialSerializer.prototype.constructor = MultiMaterialSerializer;

	MultiMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	MultiMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.MultiMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * ParticleBasicMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ParticleBasicMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	ParticleBasicMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	ParticleBasicMaterialSerializer.prototype.constructor = ParticleBasicMaterialSerializer;

	ParticleBasicMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	ParticleBasicMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.ParticleBasicMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * ParticleSystemMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ParticleSystemMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	ParticleSystemMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	ParticleSystemMaterialSerializer.prototype.constructor = ParticleSystemMaterialSerializer;

	ParticleSystemMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	ParticleSystemMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.ParticleSystemMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * PointCloudMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function PointCloudMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	PointCloudMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	PointCloudMaterialSerializer.prototype.constructor = PointCloudMaterialSerializer;

	PointCloudMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	PointCloudMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.PointCloudMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * PointsMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function PointsMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	PointsMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	PointsMaterialSerializer.prototype.constructor = PointsMaterialSerializer;

	PointsMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	PointsMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.PointsMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * RawShaderMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function RawShaderMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	RawShaderMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	RawShaderMaterialSerializer.prototype.constructor = RawShaderMaterialSerializer;

	RawShaderMaterialSerializer.prototype.toJSON = function (obj) {
	  var json = MaterialSerializer.prototype.toJSON.call(this, obj);
	  json.defines = obj.defines;
	  json.uniforms = {};

	  for (var i in obj.uniforms) {
	    var uniform = obj.uniforms[i];

	    if (uniform.value instanceof THREE.Color) {
	      json.uniforms[i] = {
	        type: 'color',
	        value: uniform.value
	      };
	    } else {
	      json.uniforms[i] = {
	        value: uniform.value
	      };
	    }
	  }

	  json.vertexShader = obj.vertexShader;
	  json.fragmentShader = obj.fragmentShader;
	  return json;
	};

	RawShaderMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.RawShaderMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  obj.defines = json.defines;
	  obj.uniforms = {};

	  for (var i in json.uniforms) {
	    var uniform = json.uniforms[i];

	    if (uniform.type === 'color') {
	      obj.uniforms[i] = {
	        value: new THREE.Color(uniform.value)
	      };
	    } else {
	      obj.uniforms[i] = {
	        value: uniform.value
	      };
	    }
	  }

	  obj.vertexShader = json.vertexShader;
	  obj.fragmentShader = json.fragmentShader;
	  return obj;
	};

	/**
	 * ShaderMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ShaderMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	ShaderMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	ShaderMaterialSerializer.prototype.constructor = ShaderMaterialSerializer;

	ShaderMaterialSerializer.prototype.toJSON = function (obj) {
	  var json = MaterialSerializer.prototype.toJSON.call(this, obj);
	  json.defines = obj.defines;
	  json.uniforms = {};

	  for (var i in obj.uniforms) {
	    var uniform = obj.uniforms[i];

	    if (uniform.value instanceof THREE.Color) {
	      json.uniforms[i] = {
	        type: 'color',
	        value: uniform.value
	      };
	    } else {
	      json.uniforms[i] = {
	        value: uniform.value
	      };
	    }
	  }

	  json.vertexShader = obj.vertexShader;
	  json.fragmentShader = obj.fragmentShader;
	  return json;
	};

	ShaderMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.ShaderMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  obj.defines = json.defines;
	  obj.uniforms = {};

	  for (var i in json.uniforms) {
	    var uniform = json.uniforms[i];

	    if (uniform.type === 'color') {
	      obj.uniforms[i] = {
	        value: new THREE.Color(uniform.value)
	      };
	    } else {
	      obj.uniforms[i] = {
	        value: uniform.value
	      };
	    }
	  }

	  obj.vertexShader = json.vertexShader;
	  obj.fragmentShader = json.fragmentShader;
	  return obj;
	};

	/**
	 * ShadowMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ShadowMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	ShadowMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	ShadowMaterialSerializer.prototype.constructor = ShadowMaterialSerializer;

	ShadowMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	ShadowMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.ShadowMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * SpriteCanvasMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SpriteCanvasMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	SpriteCanvasMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	SpriteCanvasMaterialSerializer.prototype.constructor = SpriteCanvasMaterialSerializer;

	SpriteCanvasMaterialSerializer.prototype.toJSON = function (obj) {
	  return MaterialSerializer.prototype.toJSON.call(this, obj);
	};

	SpriteCanvasMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.SpriteCanvasMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	/**
	 * SpriteMaterialSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SpriteMaterialSerializer() {
	  BaseSerializer.call(this);
	}

	SpriteMaterialSerializer.prototype = Object.create(BaseSerializer.prototype);
	SpriteMaterialSerializer.prototype.constructor = SpriteMaterialSerializer;

	SpriteMaterialSerializer.prototype.toJSON = function (obj) {
	  var json = MaterialSerializer.prototype.toJSON.call(this, obj);
	  json.isSpriteMaterial = true;
	  return json;
	};

	SpriteMaterialSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.SpriteMaterial() : parent;
	  MaterialSerializer.prototype.fromJSON.call(this, json, obj, server);
	  return obj;
	};

	var Serializers$1 = {
	  'LineBasicMaterial': LineBasicMaterialSerializer,
	  'LineDashedMaterial': LineDashedMaterialSerializer,
	  'MeshBasicMaterial': MeshBasicMaterialSerializer,
	  'MeshDepthMaterial': MeshDepthMaterialSerializer,
	  'MeshDistanceMaterial': MeshDistanceMaterialSerializer,
	  'MeshFaceMaterial': MeshFaceMaterialSerializer,
	  'MeshLambertMaterial': MeshLambertMaterialSerializer,
	  'MeshNormalMaterial': MeshNormalMaterialSerializer,
	  'MeshPhongMaterial': MeshPhongMaterialSerializer,
	  'MeshPhysicalMaterial': MeshPhysicalMaterialSerializer,
	  'MeshStandardMaterial': MeshStandardMaterialSerializer,
	  'MeshToonMaterial': MeshToonMaterialSerializer,
	  'MultiMaterial': MultiMaterialSerializer,
	  'ParticleBasicMaterial': ParticleBasicMaterialSerializer,
	  'ParticleSystemMaterial': ParticleSystemMaterialSerializer,
	  'PointCloudMaterial': PointCloudMaterialSerializer,
	  'PointsMaterial': PointsMaterialSerializer,
	  'RawShaderMaterial': RawShaderMaterialSerializer,
	  'ShaderMaterial': ShaderMaterialSerializer,
	  'ShadowMaterial': ShadowMaterialSerializer,
	  'SpriteCanvasMaterial': SpriteCanvasMaterialSerializer,
	  'SpriteMaterial': SpriteMaterialSerializer
	};
	/**
	 * MaterialsSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MaterialsSerializer() {
	  BaseSerializer.call(this);
	}

	MaterialsSerializer.prototype = Object.create(BaseSerializer.prototype);
	MaterialsSerializer.prototype.constructor = MaterialsSerializer;

	MaterialsSerializer.prototype.toJSON = function (obj) {
	  if (Array.isArray(obj)) {
	    // 多材质
	    var list = [];
	    obj.forEach(n => {
	      var serializer = Serializers$1[n.type];

	      if (serializer === undefined) {
	        console.warn(`MaterialsSerializer: No serializer with ${n.type}.`);
	        return;
	      }

	      list.push(new serializer().toJSON(n));
	    });
	    return list;
	  } else {
	    // 单材质
	    var serializer = Serializers$1[obj.type];

	    if (serializer === undefined) {
	      console.warn(`MaterialsSerializer: No serializer with ${obj.type}.`);
	      return null;
	    }

	    return new serializer().toJSON(obj);
	  }
	};

	MaterialsSerializer.prototype.fromJSON = function (json, parent, server) {
	  if (Array.isArray(json)) {
	    // 多材质
	    var list = [];
	    json.forEach(n => {
	      var generator = n.metadata.generator;
	      var serializer = Serializers$1[generator.replace('Serializer', '')];

	      if (serializer === undefined) {
	        console.warn(`MaterialsSerializer: No deserializer with ${generator}.`);
	        return null;
	      }

	      list.push(new serializer().fromJSON(n, parent, server));
	    });
	    return list;
	  } else {
	    // 单材质
	    var generator = json.metadata.generator;
	    var serializer = Serializers$1[generator.replace('Serializer', '')];

	    if (serializer === undefined) {
	      console.warn(`MaterialsSerializer: No deserializer with ${generator}.`);
	      return null;
	    }

	    return new serializer().fromJSON(json, parent, server);
	  }
	};

	/**
	 * SceneSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SceneSerializer() {
	  BaseSerializer.call(this);
	}

	SceneSerializer.prototype = Object.create(BaseSerializer.prototype);
	SceneSerializer.prototype.constructor = SceneSerializer;

	SceneSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);

	  if (obj.background instanceof THREE.Texture) {
	    // 天空盒和背景图片
	    json.background = new TexturesSerializer().toJSON(obj.background);
	  } else {
	    // 纯色
	    json.background = obj.background;
	  }

	  json.fog = obj.fog;
	  json.overrideMaterial = obj.overrideMaterial == null ? null : new MaterialsSerializer().toJSON(obj.overrideMaterial);
	  return json;
	};

	SceneSerializer.prototype.fromJSON = function (json, parent, server) {
	  var obj = parent === undefined ? new THREE.Scene() : parent;
	  Object3DSerializer.prototype.fromJSON(json, obj);

	  if (json.background && json.background.metadata && (json.background.metadata.generator === 'CubeTextureSerializer' || json.background.metadata.generator === 'TextureSerializer')) {
	    // 天空盒和背景图片
	    obj.background = new TexturesSerializer().fromJSON(json.background, undefined, server);
	  } else if (json.background) {
	    // 纯色
	    obj.background = new THREE.Color(json.background);
	  }

	  if (json.fog && (json.fog.type === 'Fog' || json.fog instanceof THREE.Fog)) {
	    obj.fog = new THREE.Fog(json.fog.color, json.fog.near, json.fog.far);
	  } else if (json.fog && (json.fog.type === 'FogExp2' || json.fog instanceof THREE.FogExp2)) {
	    obj.fog = new THREE.FogExp2(json.fog.color, json.fog.density);
	  } else if (json.fog) {
	    console.warn(`SceneSerializer: unknown fog type ${json.fog.type}.`);
	  }

	  obj.overrideMaterial = json.overrideMaterial == null ? null : new MaterialsSerializer().fromJSON(json.overrideMaterial, undefined, server);
	  return obj;
	};

	/**
	 * BufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function BufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	BufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	BufferGeometrySerializer.prototype.constructor = BufferGeometrySerializer;

	BufferGeometrySerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj); // json.attributes太大，不要保存在Mongo
	  // json.attributes = obj.attributes;

	  json.boundingBox = obj.boundingBox;
	  json.boundingSphere = obj.boundingSphere;
	  json.drawRange = obj.drawRange;
	  json.groups = obj.groups; // json.index = obj.index;

	  json.morphAttributes = obj.morphAttributes;
	  json.name = obj.name;
	  json.parameters = obj.parameters;
	  json.type = obj.type;
	  json.userData = obj.userData;
	  json.uuid = obj.uuid;
	  return json;
	};

	BufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.BufferGeometry() : parent;
	  BaseSerializer.prototype.fromJSON.call(this, json, obj); // obj.attributes = json.attributes;
	  // if (json.boundingBox) {
	  //     obj.boundingBox = new THREE.Box3(
	  //         new THREE.Vector3().copy(json.boundingBox.min),
	  //         new THREE.Vector3().copy(json.boundingBox.max),
	  //     );
	  // }
	  // if (json.boundingSphere) {
	  //     obj.boundingSphere = new THREE.Sphere(
	  //         new THREE.Vector3().copy(json.boundingSphere.center),
	  //         json.boundingSphere.radius
	  //     );
	  // }
	  // if (json.drawRange) {
	  //     obj.drawRange.start = json.drawRange.start;
	  //     obj.drawRange.count = json.drawRange.count === null ? Infinity : json.drawRange.count;
	  // }

	  obj.groups = json.groups; // obj.index = json.index;

	  obj.morphAttributes = json.morphAttributes;
	  obj.name = json.name;
	  obj.parameters = json.parameters;
	  obj.type = json.type;
	  obj.userData = json.userData;
	  obj.uuid = json.uuid;
	  return obj;
	};

	/**
	 * BoxBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function BoxBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	BoxBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	BoxBufferGeometrySerializer.prototype.constructor = BoxBufferGeometrySerializer;

	BoxBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	BoxBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.BoxBufferGeometry(json.parameters.width, json.parameters.height, json.parameters.depth, json.parameters.widthSegments, json.parameters.heightSegments, json.parameters.depthSegments) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * CircleBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CircleBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	CircleBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	CircleBufferGeometrySerializer.prototype.constructor = CircleBufferGeometrySerializer;

	CircleBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	CircleBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.CircleBufferGeometry(json.parameters.radius, json.parameters.segments, json.parameters.thetaStart, json.parameters.thetaLength) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * ConeBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ConeBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	ConeBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	ConeBufferGeometrySerializer.prototype.constructor = ConeBufferGeometrySerializer;

	ConeBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	ConeBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.ConeBufferGeometry(json.parameters.radius, json.parameters.height, json.parameters.radialSegments, json.parameters.heightSegments, json.parameters.openEnded, json.parameters.thetaStart, json.parameters.thetaLength) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * CylinderBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CylinderBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	CylinderBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	CylinderBufferGeometrySerializer.prototype.constructor = CylinderBufferGeometrySerializer;

	CylinderBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	CylinderBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.CylinderBufferGeometry(json.parameters.radiusTop, json.parameters.radiusBottom, json.parameters.height, json.parameters.radialSegments, json.parameters.heightSegments, json.parameters.openEnded, json.parameters.thetaStart, json.parameters.thetaLength) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * DodecahedronBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function DodecahedronBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	DodecahedronBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	DodecahedronBufferGeometrySerializer.prototype.constructor = DodecahedronBufferGeometrySerializer;

	DodecahedronBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	DodecahedronBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.DodecahedronBufferGeometry(json.parameters.radius, json.parameters.detail) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * ExtrudeBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ExtrudeBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	ExtrudeBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	ExtrudeBufferGeometrySerializer.prototype.constructor = ExtrudeBufferGeometrySerializer;

	ExtrudeBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	ExtrudeBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  // TODO
	  var obj = parent === undefined ? new THREE.ExtrudeBufferGeometry(json.parameters.shapes, json.parameters.options) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * IcosahedronBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function IcosahedronBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	IcosahedronBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	IcosahedronBufferGeometrySerializer.prototype.constructor = IcosahedronBufferGeometrySerializer;

	IcosahedronBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	IcosahedronBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.IcosahedronBufferGeometry(json.parameters.radius, json.parameters.detail) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * InstancedBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function InstancedBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	InstancedBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	InstancedBufferGeometrySerializer.prototype.constructor = InstancedBufferGeometrySerializer;

	InstancedBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	InstancedBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.InstancedBufferGeometry() : parent; // TODO: 

	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * LatheBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function LatheBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	LatheBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	LatheBufferGeometrySerializer.prototype.constructor = LatheBufferGeometrySerializer;

	LatheBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	LatheBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.LatheBufferGeometry(json.parameters.points, json.parameters.segments, json.parameters.phiStart, json.parameters.phiLength) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * OctahedronBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function OctahedronBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	OctahedronBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	OctahedronBufferGeometrySerializer.prototype.constructor = OctahedronBufferGeometrySerializer;

	OctahedronBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	OctahedronBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.OctahedronBufferGeometry(json.parameters.radius, json.parameters.detail) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * ParametricBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ParametricBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	ParametricBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	ParametricBufferGeometrySerializer.prototype.constructor = ParametricBufferGeometrySerializer;

	ParametricBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	ParametricBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.ParametricBufferGeometry(json.parameters.func, json.parameters.slices, json.parameters.stacks) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * PlaneBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function PlaneBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	PlaneBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	PlaneBufferGeometrySerializer.prototype.constructor = PlaneBufferGeometrySerializer;

	PlaneBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	PlaneBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.PlaneBufferGeometry(json.parameters.width, json.parameters.height, json.parameters.widthSegments, json.parameters.heightSegments) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * PolyhedronBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function PolyhedronBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	PolyhedronBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	PolyhedronBufferGeometrySerializer.prototype.constructor = PolyhedronBufferGeometrySerializer;

	PolyhedronBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	PolyhedronBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.PolyhedronBufferGeometry(json.parameters.vertices, json.parameters.indices, json.parameters.radius, json.parameters.detail) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * RingBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function RingBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	RingBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	RingBufferGeometrySerializer.prototype.constructor = RingBufferGeometrySerializer;

	RingBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	RingBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.RingBufferGeometry(json.parameters.innerRadius, json.parameters.outerRadius, json.parameters.thetaSegments, json.parameters.phiSegments, json.parameters.thetaStart, json.parameters.thetaLength) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * ShapeBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ShapeBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	ShapeBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	ShapeBufferGeometrySerializer.prototype.constructor = ShapeBufferGeometrySerializer;

	ShapeBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	ShapeBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.ShapeBufferGeometry(json.parameters.shapes, json.parameters.curveSegments) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * SphereBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SphereBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	SphereBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	SphereBufferGeometrySerializer.prototype.constructor = SphereBufferGeometrySerializer;

	SphereBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	SphereBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.SphereBufferGeometry(json.parameters.radius, json.parameters.widthSegments, json.parameters.heightSegments, json.parameters.phiStart, json.parameters.phiLength, json.parameters.thetaStart, json.parameters.thetaLength) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * TeapotBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TeapotBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	TeapotBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	TeapotBufferGeometrySerializer.prototype.constructor = TeapotBufferGeometrySerializer;

	TeapotBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	TeapotBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.TeapotBufferGeometry(json.parameters.size, json.parameters.segments, json.parameters.bottom, json.parameters.lid, json.parameters.body, json.parameters.fitLid, json.parameters.blinn) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * TetrahedronBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TetrahedronBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	TetrahedronBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	TetrahedronBufferGeometrySerializer.prototype.constructor = TetrahedronBufferGeometrySerializer;

	TetrahedronBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	TetrahedronBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.TetrahedronBufferGeometry(json.parameters.radius, json.parameters.detail) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * TextBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TextBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	TextBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	TextBufferGeometrySerializer.prototype.constructor = TextBufferGeometrySerializer;

	TextBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	TextBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.TextBufferGeometry(json.parameters.text, json.parameters.parameters) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * TorusBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TorusBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	TorusBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	TorusBufferGeometrySerializer.prototype.constructor = TorusBufferGeometrySerializer;

	TorusBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	TorusBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.TorusBufferGeometry(json.parameters.radius, json.parameters.tube, json.parameters.radialSegments, json.parameters.tubularSegments, json.parameters.arc) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * TorusKnotBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TorusKnotBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	TorusKnotBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	TorusKnotBufferGeometrySerializer.prototype.constructor = TorusKnotBufferGeometrySerializer;

	TorusKnotBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	TorusKnotBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.TorusKnotBufferGeometry(json.parameters.radius, json.parameters.tube, json.parameters.tubularSegments, json.parameters.radialSegments, json.parameters.p, json.parameters.q) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * TubeBufferGeometrySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function TubeBufferGeometrySerializer() {
	  BaseSerializer.call(this);
	}

	TubeBufferGeometrySerializer.prototype = Object.create(BaseSerializer.prototype);
	TubeBufferGeometrySerializer.prototype.constructor = TubeBufferGeometrySerializer;

	TubeBufferGeometrySerializer.prototype.toJSON = function (obj) {
	  return BufferGeometrySerializer.prototype.toJSON.call(this, obj);
	};

	TubeBufferGeometrySerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.TubeBufferGeometry(json.parameters.path, json.parameters.tubularSegments, json.parameters.radius, json.parameters.radialSegments, json.parameters.closed) : parent;
	  BufferGeometrySerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	var Serializers$2 = {
	  'BoxBufferGeometry': BoxBufferGeometrySerializer,
	  'BufferGeometry': BufferGeometrySerializer,
	  'CircleBufferGeometry': CircleBufferGeometrySerializer,
	  'ConeBufferGeometry': ConeBufferGeometrySerializer,
	  'CylinderBufferGeometry': CylinderBufferGeometrySerializer,
	  'DodecahedronBufferGeometry': DodecahedronBufferGeometrySerializer,
	  'ExtrudeBufferGeometry': ExtrudeBufferGeometrySerializer,
	  'IcosahedronBufferGeometry': IcosahedronBufferGeometrySerializer,
	  'InstancedBufferGeometry': InstancedBufferGeometrySerializer,
	  'LatheBufferGeometry': LatheBufferGeometrySerializer,
	  'OctahedronBufferGeometry': OctahedronBufferGeometrySerializer,
	  'ParametricBufferGeometry': ParametricBufferGeometrySerializer,
	  'PlaneBufferGeometry': PlaneBufferGeometrySerializer,
	  'PolyhedronBufferGeometry': PolyhedronBufferGeometrySerializer,
	  'RingBufferGeometry': RingBufferGeometrySerializer,
	  'ShapeBufferGeometry': ShapeBufferGeometrySerializer,
	  'SphereBufferGeometry': SphereBufferGeometrySerializer,
	  'TeapotBufferGeometry': TeapotBufferGeometrySerializer,
	  'TetrahedronBufferGeometry': TetrahedronBufferGeometrySerializer,
	  'TextBufferGeometry': TextBufferGeometrySerializer,
	  'TorusBufferGeometry': TorusBufferGeometrySerializer,
	  'TorusKnotBufferGeometry': TorusKnotBufferGeometrySerializer,
	  'TubeBufferGeometry': TubeBufferGeometrySerializer
	};
	/**
	 * GeometriesSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function GeometriesSerializer() {
	  BaseSerializer.call(this);
	}

	GeometriesSerializer.prototype = Object.create(BaseSerializer.prototype);
	GeometriesSerializer.prototype.constructor = GeometriesSerializer;

	GeometriesSerializer.prototype.toJSON = function (obj) {
	  var serializer = Serializers$2[obj.type];

	  if (serializer === undefined) {
	    console.warn(`GeometriesSerializer: No serializer with ${obj.type}.`);
	    return null;
	  }

	  return new serializer().toJSON(obj);
	};

	GeometriesSerializer.prototype.fromJSON = function (json, parent) {
	  var generator = json.metadata.generator;
	  var serializer = Serializers$2[generator.replace('Serializer', '')];

	  if (serializer === undefined) {
	    console.warn(`GeometriesSerializer: No deserializer with ${generator}.`);
	    return null;
	  }

	  return new serializer().fromJSON(json, parent);
	};

	/**
	 * MeshSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function MeshSerializer() {
	  BaseSerializer.call(this);
	}

	MeshSerializer.prototype = Object.create(BaseSerializer.prototype);
	MeshSerializer.prototype.constructor = MeshSerializer;

	MeshSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  json.drawMode = obj.drawMode;
	  json.geometry = new GeometriesSerializer().toJSON(obj.geometry);
	  json.material = new MaterialsSerializer().toJSON(obj.material);
	  return json;
	};

	MeshSerializer.prototype.fromJSON = function (json, parent, server) {
	  // 子类创建模型
	  if (parent !== undefined) {
	    var obj = parent;
	    Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	    return obj;
	  } // 其他模型


	  if (json.geometry == null) {
	    console.warn(`MeshSerializer: ${json.name} json.geometry is not defined.`);
	    return null;
	  }

	  if (json.material == null) {
	    console.warn(`MeshSerializer: ${json.name} json.material is not defined.`);
	    return null;
	  }

	  var geometry = new GeometriesSerializer().fromJSON(json.geometry);
	  var material = new MaterialsSerializer().fromJSON(json.material, undefined, server);
	  var obj = new THREE.Mesh(geometry, material);
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * GroupSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function GroupSerializer() {
	  BaseSerializer.call(this);
	}

	GroupSerializer.prototype = Object.create(BaseSerializer.prototype);
	GroupSerializer.prototype.constructor = GroupSerializer;

	GroupSerializer.prototype.toJSON = function (obj) {
	  return Object3DSerializer.prototype.toJSON.call(this, obj);
	};

	GroupSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.Group() : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * BoneSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function BoneSerializer() {
	  BaseSerializer.call(this);
	}

	BoneSerializer.prototype = Object.create(BaseSerializer.prototype);
	BoneSerializer.prototype.constructor = BoneSerializer;

	BoneSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	BoneSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.Bone() : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * SpriteSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SpriteSerializer() {
	  BaseSerializer.call(this);
	}

	SpriteSerializer.prototype = Object.create(BaseSerializer.prototype);
	SpriteSerializer.prototype.constructor = SpriteSerializer;

	SpriteSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  json.center = obj.center;
	  json.material = new MaterialsSerializer().toJSON(obj.material);
	  json.z = obj.z;
	  json.isSprite = obj.isSprite;
	  return json;
	};

	SpriteSerializer.prototype.fromJSON = function (json, parent, server) {
	  var material;

	  if (parent === undefined) {
	    if (json.material == null) {
	      console.warn(`SpriteSerializer: ${json.name} json.material is not defined.`);
	      return null;
	    }

	    material = new MaterialsSerializer().fromJSON(json.material, undefined, server);
	  }

	  var obj = parent === undefined ? new THREE.Sprite(material) : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.center.copy(json.center);
	  obj.z = json.z;
	  return obj;
	};

	var ID$1 = -1;
	/**
	 * BaseLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function BaseLoader() {
	  this.id = `BaseLoader${ID$1--}`;
	  this.packageManager = new PackageManager();
	  this.require = this.packageManager.require.bind(this.packageManager);
	}

	BaseLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    resolve(null);
	  });
	};

	/**
	 * AMFLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function AMFLoader() {
	  BaseLoader.call(this);
	}

	AMFLoader.prototype = Object.create(BaseLoader.prototype);
	AMFLoader.prototype.constructor = AMFLoader;

	AMFLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('AMFLoader').then(() => {
	      var loader = new THREE.AMFLoader();
	      loader.load(url, group => {
	        resolve(group);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * AWDLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function AWDLoader() {
	  BaseLoader.call(this);
	}

	AWDLoader.prototype = Object.create(BaseLoader.prototype);
	AWDLoader.prototype.constructor = AWDLoader;

	AWDLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('AWDLoader').then(() => {
	      var loader = new THREE.AWDLoader();
	      loader.load(url, obj3d => {
	        resolve(obj3d);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * BabylonLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function BabylonLoader() {
	  BaseLoader.call(this);
	}

	BabylonLoader.prototype = Object.create(BaseLoader.prototype);
	BabylonLoader.prototype.constructor = BabylonLoader;

	BabylonLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('BabylonLoader').then(() => {
	      var loader = new THREE.BabylonLoader();
	      loader.load(url, scene => {
	        var obj3d = new THREE.Object3D();
	        obj3d.children = scene.children;
	        resolve(obj3d);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * BinaryLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function BinaryLoader() {
	  BaseLoader.call(this);
	}

	BinaryLoader.prototype = Object.create(BaseLoader.prototype);
	BinaryLoader.prototype.constructor = BinaryLoader;

	BinaryLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('BinaryLoader').then(() => {
	      var loader = new THREE.BinaryLoader();
	      loader.load(url, (geometry, materials) => {
	        var mesh = new THREE.Mesh(geometry, materials);
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * ColladaLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function ColladaLoader() {
	  BaseLoader.call(this);
	}

	ColladaLoader.prototype = Object.create(BaseLoader.prototype);
	ColladaLoader.prototype.constructor = ColladaLoader;

	ColladaLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require('ColladaLoader').then(() => {
	      var loader = new THREE.ColladaLoader();
	      loader.load(url, collada => {
	        var dae = collada.scene;
	        dae.traverse(child => {
	          if (child instanceof THREE.Mesh) {
	            child.material.flatShading = true;
	          }

	          if (child.isSkinnedMesh) {
	            child.frustumCulled = false;
	          }
	        });

	        if (isNaN(dae.scale.x) || isNaN(dae.scale.y) || isNaN(dae.scale.z)) {
	          dae.scale.x = dae.scale.y = dae.scale.z = 10.0;
	          dae.updateMatrix();
	        }

	        Object.assign(dae.userData, {
	          obj: collada,
	          root: dae
	        });

	        if (collada.animations && collada.animations.length > 0) {
	          Object.assign(dae.userData, {
	            animNames: collada.animations.map(n => n.name),
	            scripts: [{
	              id: null,
	              name: `${options.Name}${_t('Animation')}`,
	              type: 'javascript',
	              source: this.createScripts(options.Name),
	              uuid: THREE.Math.generateUUID()
	            }]
	          });
	        }

	        resolve(dae);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	ColladaLoader.prototype.createScripts = function (name) {
	  return `var mesh = this.getObjectByName('${name}');\n\n` + `var obj = mesh.userData.obj;\n\n` + `var root = mesh.userData.root;\n\n` + `var mixer = new THREE.AnimationMixer(root);\n\n` + `mixer.clipAction(obj.animations[0]).play();\n\n` + `function update(clock, deltaTime) { \n    mixer.update(deltaTime); \n}`;
	};

	/**
	 * CTMLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function CTMLoader() {
	  BaseLoader.call(this);
	}

	CTMLoader.prototype = Object.create(BaseLoader.prototype);
	CTMLoader.prototype.constructor = CTMLoader;

	CTMLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require(['lzma', 'CTMLoader']).then(() => {
	      var loader = new THREE.CTMLoader();
	      loader.load(url, geometry => {
	        var material = new THREE.MeshStandardMaterial();
	        var mesh = new THREE.Mesh(geometry, material);
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * FBXLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function FBXLoader() {
	  BaseLoader.call(this);
	}

	FBXLoader.prototype = Object.create(BaseLoader.prototype);
	FBXLoader.prototype.constructor = FBXLoader;

	FBXLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require('FBXLoader').then(() => {
	      var loader = new THREE.FBXLoader();
	      loader.load(url, obj3d => {
	        Object.assign(obj3d.userData, {
	          obj: obj3d,
	          root: obj3d
	        });

	        if (obj3d.animations && obj3d.animations.length > 0) {
	          Object.assign(obj3d.userData, {
	            animNames: obj3d.animations.map(n => n.name),
	            scripts: [{
	              id: null,
	              name: `${options.Name}${_t('Animation')}`,
	              type: 'javascript',
	              source: this.createScripts(options.Name),
	              uuid: THREE.Math.generateUUID()
	            }]
	          });
	        }

	        resolve(obj3d);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	FBXLoader.prototype.createScripts = function (name) {
	  return `var mesh = this.getObjectByName('${name}');\n\n` + `var obj = mesh.userData.obj;\n\n` + `var root = mesh.userData.root;\n\n` + `var mixer = new THREE.AnimationMixer(root);\n\n` + `mixer.clipAction(obj.animations[0]).play();\n\n` + `function update(clock, deltaTime) { \n    mixer.update(deltaTime); \n}`;
	};

	/**
	 * GLTFLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function GLTFLoader() {
	  BaseLoader.call(this);
	}

	GLTFLoader.prototype = Object.create(BaseLoader.prototype);
	GLTFLoader.prototype.constructor = GLTFLoader;

	GLTFLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require(['DRACOLoader', 'GLTFLoader']).then(() => {
	      var loader = new THREE.GLTFLoader();
	      THREE.DRACOLoader.setDecoderPath('assets/js/libs/draco/gltf/');
	      loader.setDRACOLoader(new THREE.DRACOLoader());
	      loader.load(url, result => {
	        var obj3d = result.scene;
	        Object.assign(obj3d.userData, {
	          obj: result,
	          root: result.scene
	        });

	        if (result.animations && result.animations.length > 0) {
	          Object.assign(obj3d.userData, {
	            animNames: result.animations.map(n => n.name),
	            scripts: [{
	              id: null,
	              name: `${options.Name}${_t('Animation')}`,
	              type: 'javascript',
	              source: this.createScripts(options.Name),
	              uuid: THREE.Math.generateUUID()
	            }]
	          });
	        }

	        resolve(obj3d);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	GLTFLoader.prototype.createScripts = function (name) {
	  return `var mesh = this.getObjectByName('${name}');\n\n` + `var obj = mesh.userData.obj;\n\n` + `var root = mesh.userData.root;\n\n` + `var mixer = new THREE.AnimationMixer(root);\n\n` + `mixer.clipAction(obj.animations[0]).play();\n\n` + `function update(clock, deltaTime) { \n    mixer.update(deltaTime); \n}`;
	};

	/**
	 * KMZLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function KMZLoader() {
	  BaseLoader.call(this);
	}

	KMZLoader.prototype = Object.create(BaseLoader.prototype);
	KMZLoader.prototype.constructor = KMZLoader;

	KMZLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require(['ColladaLoader', 'KMZLoader']).then(() => {
	      var loader = new THREE.KMZLoader();
	      loader.load(url, collada => {
	        var obj3d = collada.scene;
	        resolve(obj3d);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * MD2Loader
	 * @author tengge / https://github.com/tengge1
	 */

	function MD2Loader() {
	  BaseLoader.call(this);
	}

	MD2Loader.prototype = Object.create(BaseLoader.prototype);
	MD2Loader.prototype.constructor = MD2Loader;

	MD2Loader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('MD2Loader').then(() => {
	      var loader = new THREE.MD2Loader();
	      loader.load(url, geometry => {
	        var material = new THREE.MeshStandardMaterial({
	          morphTargets: true,
	          morphNormals: true
	        });
	        var mesh = new THREE.Mesh(geometry, material);
	        mesh.mixer = new THREE.AnimationMixer(mesh);
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * ObjectLoader（json文件加载器）
	 * @author tengge / https://github.com/tengge1
	 */

	function ObjectLoader() {
	  BaseLoader.call(this);
	}

	ObjectLoader.prototype = Object.create(BaseLoader.prototype);
	ObjectLoader.prototype.constructor = ObjectLoader;

	ObjectLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require(['LegacyJSONLoader']).then(() => {
	      var loader = new THREE.ObjectLoader();
	      loader.load(url, obj => {
	        if (obj instanceof THREE.Scene && obj.children.length > 0 && obj.children[0] instanceof THREE.SkinnedMesh) {
	          resolve(this.loadSkinnedMesh(obj, options));
	        } else {
	          resolve(obj);
	        }
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	ObjectLoader.prototype.loadSkinnedMesh = function (scene, options) {
	  var mesh = null;
	  scene.traverse(child => {
	    if (child instanceof THREE.SkinnedMesh) {
	      mesh = child;
	    }
	  });
	  var animations = mesh.geometry.animations;

	  if (options.Name && animations && animations.length > 0) {
	    var names = animations.map(n => n.name);
	    var source1 = `var mesh = this.getObjectByName('${options.Name}');\nvar mixer = new THREE.AnimationMixer(mesh);\n\n`;
	    var source2 = ``;
	    names.forEach(n => {
	      source2 += `var ${n}Animation = mixer.clipAction('${n}');\n`;
	    });
	    var source3 = `\n${names[0]}Animation.play();\n\n`;
	    var source4 = `function update(clock, deltaTime) { \n    mixer.update(deltaTime); \n}`;
	    var source = source1 + source2 + source3 + source4;
	    mesh.userData.scripts = [{
	      id: null,
	      name: `${options.Name}${_t('Animation')}`,
	      type: 'javascript',
	      source: source,
	      uuid: THREE.Math.generateUUID()
	    }];
	  }

	  return mesh;
	};

	/**
	 * OBJLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function OBJLoader() {
	  BaseLoader.call(this);
	}

	OBJLoader.prototype = Object.create(BaseLoader.prototype);
	OBJLoader.prototype.constructor = OBJLoader;

	OBJLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require(['LoaderSupport', 'OBJLoader2', 'MTLLoader']).then(() => {
	      var objLoader = new THREE.OBJLoader2();
	      var mtlLoader = new THREE.MTLLoader();
	      var promise = new Promise(resolve1 => {
	        mtlLoader.load(url.replace('.obj', '.mtl'), obj => {
	          resolve1(obj);
	        }, undefined, () => {
	          resolve1(null);
	        });
	      });
	      promise.then(mtl => {
	        if (mtl) {
	          mtl.preload();
	          objLoader.setMaterials(mtl.materials);
	        }

	        objLoader.load(url, obj => {
	          resolve(obj.detail.loaderRootNode);
	        }, undefined, () => {
	          resolve(null);
	        });
	      });
	    });
	  });
	};

	/**
	 * PLYLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function PLYLoader() {
	  BaseLoader.call(this);
	}

	PLYLoader.prototype = Object.create(BaseLoader.prototype);
	PLYLoader.prototype.constructor = PLYLoader;

	PLYLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('PLYLoader').then(() => {
	      var loader = new THREE.PLYLoader();
	      loader.load(url, geometry => {
	        geometry.computeVertexNormals();
	        var material = new THREE.MeshStandardMaterial();
	        var mesh = new THREE.Mesh(geometry, material);
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * STLLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function STLLoader() {
	  BaseLoader.call(this);
	}

	STLLoader.prototype = Object.create(BaseLoader.prototype);
	STLLoader.prototype.constructor = STLLoader;

	STLLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('STLLoader').then(() => {
	      var loader = new THREE.STLLoader();
	      loader.load(url, geometry => {
	        var material = new THREE.MeshStandardMaterial();
	        var mesh = new THREE.Mesh(geometry, material);
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * VTKLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function VTKLoader() {
	  BaseLoader.call(this);
	}

	VTKLoader.prototype = Object.create(BaseLoader.prototype);
	VTKLoader.prototype.constructor = VTKLoader;

	VTKLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('VTKLoader').then(() => {
	      var loader = new THREE.VTKLoader();
	      loader.load(url, geometry => {
	        var material = new THREE.MeshStandardMaterial();
	        var mesh = new THREE.Mesh(geometry, material);
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 */
	function DataView2(buffer) {
	  this.buffer = new DataView(buffer);
	  this.position = 0;
	}

	DataView2.prototype.getBool = function () {
	  var v = this.buffer.getUint8(this.position) != 0;
	  this.position += 1;
	  return v;
	};

	DataView2.prototype.getUint8 = function () {
	  var v = this.buffer.getUint8(this.position);
	  this.position += 1;
	  return v;
	};

	DataView2.prototype.getInt8 = function () {
	  var v = this.buffer.getInt8(this.position);
	  this.position += 1;
	  return v;
	};

	DataView2.prototype.getUint16 = function () {
	  var v = this.buffer.getUint16(this.position, true);
	  this.position += 2;
	  return v;
	};

	DataView2.prototype.getInt16 = function () {
	  var v = this.buffer.getInt16(this.position, true);
	  this.position += 2;
	  return v;
	};

	DataView2.prototype.getUint32 = function () {
	  var v = this.buffer.getUint32(this.position, true);
	  this.position += 4;
	  return v;
	};

	DataView2.prototype.getInt32 = function () {
	  var v = this.buffer.getInt32(this.position, true);
	  this.position += 4;
	  return v;
	};

	DataView2.prototype.getFloat = function () {
	  var v = this.buffer.getFloat32(this.position, true);
	  this.position += 4;
	  return v;
	};

	DataView2.prototype.getString = function (len) {
	  if (len === undefined) len = this.getUint16();
	  var str = "";

	  for (var i = 0; i < len; ++i) {
	    str += String.fromCharCode(this.getUint8());
	  }

	  return str;
	};

	DataView2.prototype.setBool = function (v) {
	  this.buffer.setUint8(this.position, v ? 1 : 0);
	  this.position += 1;
	};

	DataView2.prototype.setUint8 = function (v) {
	  this.buffer.setUint8(this.position, v);
	  this.position += 1;
	};

	DataView2.prototype.setInt8 = function (v) {
	  this.buffer.setInt8(this.position, v);
	  this.position += 1;
	};

	DataView2.prototype.setUint16 = function (v) {
	  this.buffer.setUint16(this.position, v, true);
	  this.position += 2;
	};

	DataView2.prototype.setInt16 = function (v) {
	  this.buffer.setInt16(this.position, v, true);
	  this.position += 2;
	};

	DataView2.prototype.setUint32 = function (v) {
	  this.buffer.setUint32(this.position, v, true);
	  this.position += 4;
	};

	DataView2.prototype.setInt32 = function (v) {
	  this.buffer.setInt32(this.position, v, true);
	  this.position += 4;
	};

	DataView2.prototype.setFloat = function (v) {
	  this.buffer.setFloat32(this.position, v, true);
	  this.position += 4;
	};

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 */
	function Vertex(r) {
	  var self = this,
	      i;
	  self.position = [r.getFloat(), r.getFloat(), r.getFloat()];
	  self.normal = [r.getFloat(), r.getFloat(), r.getFloat(), 0];
	  self.u = r.getFloat();
	  self.v = r.getFloat();
	  self.bones = new Array(4);

	  for (i = 0; i < 4; ++i) {
	    self.bones[i] = r.getUint8();
	  }

	  self.weights = new Array(4);

	  for (i = 0; i < 4; ++i) {
	    self.weights[i] = r.getFloat();
	  }
	}

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 */
	function Texture(model, url) {
	  var self = this;
	  self.model = model;
	  self.url = url;
	  self.texture = null;
	  self.load();
	}

	Texture.prototype.load = function () {
	  var self = this;
	  self.texture = new THREE.TextureLoader().load(self.url, function (texture) {
	    self.onLoad.call(self, texture);
	  });
	};

	Texture.prototype.onLoad = function (texture) {
	  var self = this;
	  texture.flipY = false;
	  self.model.material.map = texture;
	  self.model.material.needsUpdate = true;
	  self.model.dispatch.call('loadTexture');
	};

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 */
	function Bone(model, index, r) {
	  var self = this,
	      i;
	  self.model = model;
	  self.index = index;
	  self.name = r.getString().toLowerCase();
	  self.parent = r.getInt32();
	  self.scale = r.getFloat();
	  self.origMatrix = mat4.create();

	  for (i = 0; i < 16; ++i) self.origMatrix[i] = r.getFloat();

	  self.baseMatrix = mat4.clone(self.origMatrix);
	  mat4.transpose(self.baseMatrix, self.baseMatrix);
	  mat4.invert(self.baseMatrix, self.baseMatrix);
	  mat4.transpose(self.origMatrix, self.origMatrix);
	  self.incrMatrix = mat4.create();

	  if (model.version >= 2) {
	    for (i = 0; i < 16; ++i) self.incrMatrix[i] = r.getFloat();

	    mat4.transpose(self.incrMatrix, self.incrMatrix);
	  } else {
	    mat4.identity(self.incrMatrix);
	  }
	}

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 */
	var HiddenBones = {
	  12: {
	    9: {
	      recall: {},
	      all: {
	        recall_chair: true
	      }
	    },
	    10: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    11: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    12: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    13: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    14: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    15: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    16: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    17: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    },
	    18: {
	      recall: {
	        cowbell: true,
	        stick: true
	      },
	      dancein: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      danceloop: {
	        cata_root: true,
	        catb_root: true,
	        catc_root: true,
	        cork: true,
	        bowl: true,
	        bowl_milk: true,
	        milk_root: true,
	        bottle: true
	      },
	      all: {}
	    }
	  },
	  21: {
	    9: {
	      all: {
	        orange: true
	      },
	      recall: {
	        l_weapon: true,
	        r_weapon: true
	      }
	    },
	    10: {
	      recall: {},
	      all: {
	        tv_joint: true,
	        tv_rabit_ears_joints: true
	      }
	    },
	    11: {
	      recall: {},
	      all: {
	        tv_joint: true,
	        tv_rabit_ears_joints: true
	      }
	    },
	    12: {
	      recall: {},
	      all: {
	        tv_joint: true,
	        tv_rabit_ears_joints: true
	      }
	    },
	    13: {
	      recall: {},
	      all: {
	        tv_joint: true,
	        tv_rabit_ears_joints: true
	      }
	    },
	    14: {
	      recall: {},
	      all: {
	        tv_joint: true,
	        tv_rabit_ears_joints: true
	      }
	    }
	  },
	  22: {
	    8: {
	      all: {
	        c_drone_base: true
	      },
	      joke: {},
	      dance: {}
	    }
	  },
	  36: {
	    9: {
	      all: {
	        recall_chair: true
	      },
	      recall: {}
	    }
	  },
	  41: {
	    0: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    },
	    1: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    },
	    2: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    },
	    3: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    },
	    4: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    },
	    5: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    },
	    6: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    },
	    7: {
	      all: {
	        orange1: true,
	        orange2: true,
	        orange3: true
	      },
	      joke: {}
	    }
	  },
	  44: {
	    4: {
	      all: {
	        jacket: true
	      },
	      dance: {
	        jacket: true,
	        weapon: true
	      },
	      recall: {
	        weapon: true
	      }
	    }
	  },
	  55: {
	    7: {
	      recall: {},
	      all: {
	        xmas_pole_skin07: true
	      }
	    }
	  },
	  61: {
	    7: {
	      recall: {},
	      all: {
	        planet1: true,
	        planet2: true,
	        planet3: true,
	        planet4: true,
	        planet5: true,
	        planet6: true
	      }
	    }
	  },
	  69: {
	    4: {
	      all: {
	        l_fan: true,
	        r_fan: true
	      },
	      recall: {}
	    }
	  },
	  80: {
	    8: {
	      all: {
	        oven: true
	      },
	      recall: {}
	    }
	  },
	  83: {
	    0: {
	      all: {},
	      idle2: {
	        weapon: true
	      }
	    },
	    1: {
	      all: {},
	      idle2: {
	        weapon: true
	      }
	    },
	    2: {
	      all: {},
	      idle2: {
	        weapon: true
	      }
	    }
	  },
	  103: {
	    7: {
	      recall: {},
	      all: {
	        arcade: true
	      }
	    }
	  },
	  114: {
	    5: {
	      all: {
	        weapon_krab: true,
	        root_krab: true
	      },
	      recall: {}
	    }
	  },
	  115: {
	    4: {
	      all: {
	        sled: true
	      },
	      satcheljump: {
	        bomb: true,
	        bomb_b: true
	      }
	    }
	  },
	  119: {
	    4: {
	      all: {
	        chair_root: true,
	        sun_reflector_root: true
	      },
	      recall: {}
	    }
	  },
	  136: {
	    0: {
	      all: {
	        shades_sunglass: true
	      },
	      joke: {}
	    },
	    1: {
	      all: {
	        shades_sunglass: true
	      },
	      joke: {}
	    }
	  },
	  143: {
	    4: {
	      attack1: {
	        r_wing: true,
	        l_wing: true
	      },
	      attack2: {
	        r_wing: true,
	        l_wing: true
	      },
	      dance: {
	        r_wing: true,
	        l_wing: true
	      },
	      idle1: {
	        r_wing: true,
	        l_wing: true
	      },
	      idle3: {
	        r_wing: true,
	        l_wing: true
	      },
	      idle4: {
	        r_wing: true,
	        l_wing: true
	      },
	      laugh: {
	        r_wing: true,
	        l_wing: true
	      },
	      run: {
	        r_wing: true,
	        l_wing: true
	      },
	      spell2: {
	        r_wing: true,
	        l_wing: true
	      },
	      all: {}
	    }
	  },
	  157: {
	    4: {
	      all: {
	        flute: true
	      },
	      dance: {}
	    },
	    5: {
	      all: {
	        flute: true
	      },
	      dance: {}
	    },
	    6: {
	      all: {
	        flute: true
	      },
	      dance: {}
	    },
	    7: {
	      all: {
	        flute: true
	      },
	      dance: {}
	    },
	    8: {
	      all: {
	        flute: true
	      },
	      dance: {}
	    }
	  },
	  201: {
	    3: {
	      all: {
	        poro: true
	      }
	    }
	  },
	  222: {
	    4: {
	      all: {
	        rocket_launcher: true
	      },
	      r_attack1: {},
	      r_attack2: {},
	      r_idle1: {},
	      r_idle_in: {},
	      r_run: {},
	      r_run_fast: {},
	      r_run_haste: {},
	      r_spell2: {},
	      r_spell3: {},
	      r_spell3_run: {},
	      r_spell4: {},
	      respawn_trans_rlauncher: {},
	      rlauncher_spell3: {},
	      spell1a: {}
	    }
	  },
	  238: {
	    10: {
	      all: {
	        chair_skin10: true,
	        step1_skin10: true,
	        step2_skin10: true
	      },
	      recall: {}
	    }
	  },
	  245: {
	    0: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    1: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    2: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    3: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    4: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    5: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    6: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    7: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    8: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    9: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    },
	    10: {
	      deathrespawn: {},
	      all: {
	        book_pen: true
	      }
	    }
	  },
	  254: {
	    0: {
	      all: {
	        teacup: true
	      },
	      taunt2: {}
	    },
	    1: {
	      all: {
	        teacup: true
	      },
	      taunt2: {}
	    },
	    3: {
	      all: {
	        teacup: true
	      },
	      taunt2: {}
	    },
	    4: {
	      all: {
	        teacup: true
	      },
	      taunt2: {}
	    }
	  },
	  412: {
	    1: {
	      all: {
	        coin1: true,
	        coin2: true,
	        coin3: true,
	        coin4: true,
	        coin5: true,
	        coin6: true,
	        coin7: true,
	        treasure_chest: true,
	        treasure_chest_cover: true,
	        tire: true
	      },
	      recall: {
	        tire: true
	      },
	      undersea_recall_loop: {
	        tire: true
	      },
	      undersea_recall_loop2: {
	        coin1: true,
	        coin2: true,
	        coin3: true,
	        coin4: true,
	        coin5: true,
	        coin6: true,
	        coin7: true,
	        treasure_chest: true,
	        treasure_chest_cover: true
	      },
	      undersea_recall_windup: {
	        tire: true
	      },
	      undersea_recall_windup2: {
	        coin1: true,
	        coin2: true,
	        coin3: true,
	        coin4: true,
	        coin5: true,
	        coin6: true,
	        coin7: true,
	        treasure_chest: true,
	        treasure_chest_cover: true
	      }
	    },
	    5: {
	      all: {
	        mini_root: true
	      },
	      joke: {}
	    }
	  },
	  420: {
	    0: {
	      all: {
	        c_tentacle1: true
	      }
	    },
	    1: {
	      all: {
	        c_tentacle1: true
	      }
	    }
	  },
	  429: {
	    3: {
	      death: {
	        altar_spear: true,
	        buffbone_cstm_back_spear1: true,
	        buffbone_cstm_back_spear2: true,
	        buffbone_cstm_back_spear3: true
	      }
	    }
	  },
	  432: {
	    0: {
	      all: {
	        follower_root: true
	      },
	      dance: {}
	    },
	    2: {
	      all: {
	        follower_root: true
	      },
	      dance: {}
	    },
	    3: {
	      all: {
	        follower_root: true
	      },
	      dance: {}
	    },
	    4: {
	      all: {
	        follower_root: true
	      },
	      dance: {}
	    }
	  },
	  gnarbig: {
	    0: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    1: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    2: {
	      all: {
	        rock: true,
	        cane_bot: true,
	        cane_top: true
	      },
	      spell1: {
	        cane_bot: true,
	        cane_top: true
	      },
	      laugh: {
	        cane_bot: true,
	        cane_top: true
	      },
	      recall: {
	        rock: true
	      }
	    },
	    3: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    4: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    5: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    6: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    7: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    8: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    9: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    10: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    11: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    },
	    12: {
	      all: {
	        rock: true
	      },
	      spell1: {},
	      laugh: {}
	    }
	  }
	};

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 */
	function AnimationBone(model, anim, r, version) {
	  var self = this;
	  self.model = model;
	  self.anim = anim;
	  var numFrames = r.getUint32();
	  self.bone = r.getString().toLowerCase();
	  self.flags = r.getUint32();
	  self.frames = new Array(numFrames);
	  var scale = [1, 1, 1];

	  for (var i = 0; i < numFrames; ++i) {
	    var pos = [r.getFloat(), r.getFloat(), r.getFloat()];
	    var rot = [r.getFloat(), r.getFloat(), r.getFloat(), r.getFloat()];
	    if (version >= 3) scale = [r.getFloat(), r.getFloat(), r.getFloat()];
	    self.frames[i] = {
	      pos: pos,
	      rot: rot,
	      scale: scale
	    };
	  }

	  self.matrix = mat4.create();
	  self.tmpMat = mat4.create();
	  self.tmpMat2 = mat4.create();
	  self.tmpPos = vec3.create();
	  self.tmpRot = quat.create();
	  self.tmpScale = vec3.create();
	}

	AnimationBone.prototype.update = function (boneId, frame, r) {
	  var self = this;
	  self.index = boneId;
	  var parent = self.model.bones[boneId].parent;
	  var f0 = frame % self.frames.length,
	      f1 = (frame + 1) % self.frames.length;
	  vec3.lerp(self.tmpPos, self.frames[f0].pos, self.frames[f1].pos, r);
	  vec3.lerp(self.tmpScale, self.frames[f0].scale, self.frames[f1].scale, r);
	  quat.slerp(self.tmpRot, self.frames[f0].rot, self.frames[f1].rot, r);
	  self.translation(self.tmpMat2, self.tmpPos);
	  self.rotationQuat(self.tmpMat, self.tmpRot);
	  self.mulSlimDX(self.matrix, self.tmpMat, self.tmpMat2);

	  if (parent != -1) {
	    self.mulSlimDX(self.matrix, self.matrix, self.model.transforms[parent]);
	  }

	  mat4.copy(self.model.transforms[boneId], self.matrix);
	};

	AnimationBone.prototype.translation = function (out, vec) {
	  mat4.identity(out);
	  out[12] = vec[0];
	  out[13] = vec[1];
	  out[14] = vec[2];
	  return out;
	};

	AnimationBone.prototype.rotationQuat = function (out, q) {
	  mat4.identity(out);
	  var xx = q[0] * q[0],
	      yy = q[1] * q[1],
	      zz = q[2] * q[2],
	      xy = q[0] * q[1],
	      zw = q[2] * q[3],
	      zx = q[2] * q[0],
	      yw = q[1] * q[3],
	      yz = q[1] * q[2],
	      xw = q[0] * q[3];
	  out[0] = 1 - 2 * (yy + zz);
	  out[1] = 2 * (xy + zw);
	  out[2] = 2 * (zx - yw);
	  out[4] = 2 * (xy - zw);
	  out[5] = 1 - 2 * (zz + xx);
	  out[6] = 2 * (yz + xw);
	  out[8] = 2 * (zx + yw);
	  out[9] = 2 * (yz - xw);
	  out[10] = 1 - 2 * (yy + xx);
	  return out;
	};

	AnimationBone.prototype.mulSlimDX = function (out, l, r) {
	  var left = {
	    M11: l[0],
	    M12: l[1],
	    M13: l[2],
	    M14: l[3],
	    M21: l[4],
	    M22: l[5],
	    M23: l[6],
	    M24: l[7],
	    M31: l[8],
	    M32: l[9],
	    M33: l[10],
	    M34: l[11],
	    M41: l[12],
	    M42: l[13],
	    M43: l[14],
	    M44: l[15]
	  };
	  var right = {
	    M11: r[0],
	    M12: r[1],
	    M13: r[2],
	    M14: r[3],
	    M21: r[4],
	    M22: r[5],
	    M23: r[6],
	    M24: r[7],
	    M31: r[8],
	    M32: r[9],
	    M33: r[10],
	    M34: r[11],
	    M41: r[12],
	    M42: r[13],
	    M43: r[14],
	    M44: r[15]
	  };
	  out[0] = left.M11 * right.M11 + left.M12 * right.M21 + left.M13 * right.M31 + left.M14 * right.M41;
	  out[1] = left.M11 * right.M12 + left.M12 * right.M22 + left.M13 * right.M32 + left.M14 * right.M42;
	  out[2] = left.M11 * right.M13 + left.M12 * right.M23 + left.M13 * right.M33 + left.M14 * right.M43;
	  out[3] = left.M11 * right.M14 + left.M12 * right.M24 + left.M13 * right.M34 + left.M14 * right.M44;
	  out[4] = left.M21 * right.M11 + left.M22 * right.M21 + left.M23 * right.M31 + left.M24 * right.M41;
	  out[5] = left.M21 * right.M12 + left.M22 * right.M22 + left.M23 * right.M32 + left.M24 * right.M42;
	  out[6] = left.M21 * right.M13 + left.M22 * right.M23 + left.M23 * right.M33 + left.M24 * right.M43;
	  out[7] = left.M21 * right.M14 + left.M22 * right.M24 + left.M23 * right.M34 + left.M24 * right.M44;
	  out[8] = left.M31 * right.M11 + left.M32 * right.M21 + left.M33 * right.M31 + left.M34 * right.M41;
	  out[9] = left.M31 * right.M12 + left.M32 * right.M22 + left.M33 * right.M32 + left.M34 * right.M42;
	  out[10] = left.M31 * right.M13 + left.M32 * right.M23 + left.M33 * right.M33 + left.M34 * right.M43;
	  out[11] = left.M31 * right.M14 + left.M32 * right.M24 + left.M33 * right.M34 + left.M34 * right.M44;
	  out[12] = left.M41 * right.M11 + left.M42 * right.M21 + left.M43 * right.M31 + left.M44 * right.M41;
	  out[13] = left.M41 * right.M12 + left.M42 * right.M22 + left.M43 * right.M32 + left.M44 * right.M42;
	  out[14] = left.M41 * right.M13 + left.M42 * right.M23 + left.M43 * right.M33 + left.M44 * right.M43;
	  out[15] = left.M41 * right.M14 + left.M42 * right.M24 + left.M43 * right.M34 + left.M44 * right.M44;
	  return out;
	};

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 */

	function Animation(model, r, version) {
	  var self = this,
	      i;
	  self.model = model;
	  self.meshOverride = {};
	  self.name = r.getString().toLowerCase();
	  self.fps = r.getInt32();
	  var numBones = r.getUint32();
	  self.bones = new Array(numBones);
	  self.lookup = {};

	  for (i = 0; i < numBones; ++i) {
	    self.bones[i] = new AnimationBone(model, self, r, version);
	    self.lookup[self.bones[i].bone] = i;
	  }

	  if (numBones == 0 || self.fps <= 1) {
	    self.duration = 1e3;
	  } else {
	    self.duration = Math.floor(1e3 * (self.bones[0].frames.length / self.fps));
	  }
	}

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 */
	var BaseAnimations = {
	  19: {
	    0: {
	      all: "idle"
	    }
	  },
	  32: {
	    4: {
	      all: "idle1_bow",
	      idle1_bow: "idle1"
	    }
	  },
	  55: {
	    7: {
	      idle1_candycane_below: "idle1"
	    }
	  }
	};

	/**
	 * @author lolking / http://www.lolking.net/models
	 * @author tengge / https://github.com/tengge1
	 */

	function Model(options) {
	  var self = this;
	  self.champion = options.champion || "1";
	  self.skin = options.skin || 0;
	  self.meshUrl = options.meshUrl;
	  self.animUrl = options.animUrl;
	  self.textureUrl = options.textureUrl;
	  self.loaded = false;
	  self.animsLoaded = false;
	  self.meshes = null;
	  self.vertices = null;
	  self.indices = null;
	  self.transforms = null;
	  self.bones = null;
	  self.boneLookup = {};
	  self.animIndex = -1;
	  self.animName = null;
	  self.baseAnim = null;
	  self.newAnimation = false;
	  self.animTime = 0;
	  self.tmpMat = mat4.create();
	  self.tmpVec = vec4.create();
	  self.ANIMATED = true;
	  self.dispatch = d3.dispatch('load', 'loadMesh', 'loadTexture', 'loadAnim');
	  self.hiddenBones = null;
	  var hiddenBones = HiddenBones;

	  if (hiddenBones[self.champion] !== undefined) {
	    if (hiddenBones[self.champion][self.skin] !== undefined) {
	      self.hiddenBones = hiddenBones[self.champion][self.skin];
	    }
	  }

	  self.ambientColor = [.35, .35, .35, 1];
	  self.primaryColor = [1, 1, 1, 1];
	  self.secondaryColor = [.35, .35, .35, 1];
	  self.lightDir1 = vec3.create();
	  self.lightDir2 = vec3.create();
	  self.lightDir3 = vec3.create();
	  vec3.normalize(self.lightDir1, [5, 5, -5]);
	  vec3.normalize(self.lightDir2, [5, 5, 5]);
	  vec3.normalize(self.lightDir3, [-5, -5, -5]);
	  self.texture = null;
	  self.geometry = new THREE.BufferGeometry();
	  self.material = new THREE.MeshPhongMaterial();
	  var promise1 = new Promise(resolve => {
	    self.dispatch.on('loadMesh.Model', () => {
	      resolve();
	    });
	  });
	  var promise2 = new Promise(resolve => {
	    self.dispatch.on('loadTexture.Model', () => {
	      resolve();
	    });
	  });
	  var promise3 = new Promise(resolve => {
	    self.dispatch.on('loadAnim.Model', () => {
	      resolve();
	    });
	  });
	  Promise.all([promise1, promise2, promise3]).then(() => {
	    self.dispatch.call('load');
	  });
	}

	Model.prototype.getAnimations = function () {
	  if (!this.animations) {
	    return null;
	  }

	  var names = [];
	  this.animations.forEach(function (n) {
	    names.push(n.name);
	  });
	  return names;
	};

	Model.prototype.getAnimation = function (name) {
	  var self = this,
	      i,
	      animIndex = -1;

	  if (!self.animations) {
	    return animIndex;
	  }
	  name = name.toLowerCase();

	  if (name == "idle" || name == "attack") {
	    var anims = [],
	        re = new RegExp(name + "[0-9]*");

	    for (i = 0; i < self.animations.length; ++i) {
	      if (self.animations[i].name.search(re) == 0) anims.push(i);
	    }

	    if (anims.length > 0) {
	      animIndex = anims[0];
	    }
	  } else {
	    for (i = 0; i < self.animations.length; ++i) {
	      if (self.animations[i].name == name) {
	        animIndex = i;
	        break;
	      }
	    }
	  }

	  return animIndex;
	};

	Model.prototype.setAnimation = function (name) {
	  var self = this;
	  self.animName = name;
	  self.newAnimation = true;
	};

	Model.prototype.update = function (time) {
	  var self = this,
	      i,
	      j;

	  if (self.animTime == 0) {
	    self.animTime = time;
	  }

	  if (!self.loaded || !self.vertices || !self.animations || self.animations.length == 0) {
	    return;
	  }

	  self.animIndex = self.getAnimation(self.animName);

	  if (self.animIndex == -1) {
	    self.animIndex = 0;
	    self.animName = "idle";
	  }

	  var baseAnims = BaseAnimations;

	  if (baseAnims[self.champion] !== undefined) {
	    if (baseAnims[self.champion][self.skin] !== undefined) {
	      var baseAnim = baseAnims[self.champion][self.skin],
	          baseIndex = -1;

	      if (baseAnim[self.animations[self.animIndex].name]) {
	        baseIndex = self.getAnimation(baseAnim[self.animations[self.animIndex].name]);
	      } else if (baseAnim["all"]) {
	        baseIndex = self.getAnimation(baseAnim["all"]);
	      }

	      if (baseIndex > -1) {
	        self.baseAnim = self.animations[baseIndex];
	      } else {
	        self.baseAnim = null;
	      }
	    }
	  }

	  var deltaTime = time - self.animTime;
	  var anim = self.animations[self.animIndex];

	  if (deltaTime >= anim.duration) {
	    self.animTime = time;
	    deltaTime = 0;
	  }

	  if (self.ANIMATED) {
	    var timePerFrame = 1e3 / anim.fps;
	    var frame = Math.floor(deltaTime / timePerFrame);
	    var r = deltaTime % timePerFrame / timePerFrame;
	    var hiddenBones = {};

	    if (self.hiddenBones) {
	      if (self.hiddenBones[anim.name]) {
	        hiddenBones = self.hiddenBones[anim.name];
	      } else if (self.hiddenBones["all"]) {
	        hiddenBones = self.hiddenBones["all"];
	      }
	    }

	    var b;

	    if (self.version >= 1) {
	      for (i = 0; i < self.bones.length; ++i) {
	        b = self.bones[i];

	        if (hiddenBones[b.name]) {
	          mat4.identity(self.tmpMat);
	          mat4.scale(self.tmpMat, self.tmpMat, vec3.set(self.tmpVec, 0, 0, 0));
	          mat4.copy(self.transforms[i], self.tmpMat);
	        } else if (anim.lookup[b.name] !== undefined) {
	          anim.bones[anim.lookup[b.name]].update(i, frame, r);
	        } else if (self.baseAnim && self.baseAnim.lookup[b.name] !== undefined) {
	          self.baseAnim.bones[self.baseAnim.lookup[b.name]].update(i, frame, r);
	        } else {
	          if (b.parent != -1) {
	            AnimationBone.prototype.mulSlimDX(self.transforms[i], b.incrMatrix, self.transforms[b.parent]);
	          } else {
	            mat4.copy(self.transforms[i], b.incrMatrix);
	          }
	        }
	      }
	    } else {
	      for (i = 0; i < anim.bones.length; ++i) {
	        b = anim.bones[i];

	        if (self.boneLookup[b.bone] !== undefined) {
	          b.update(self.boneLookup[b.bone], frame, r);
	        } else {
	          var parentBone = anim.bones[i - 1];
	          if (!parentBone) continue;

	          if (parentBone.index + 1 < self.transforms.length) {
	            mat4.copy(self.transforms[parentBone.index + 1], self.transforms[parentBone.index]);
	          }

	          b.index = parentBone.index + 1;
	        }
	      }
	    }

	    var numBones = Math.min(self.transforms.length, self.bones.length);

	    for (i = 0; i < numBones; ++i) {
	      AnimationBone.prototype.mulSlimDX(self.transforms[i], self.bones[i].baseMatrix, self.transforms[i]);
	    }

	    mat4.identity(self.tmpMat);
	    var numVerts = self.vertices.length,
	        vec = self.tmpVec,
	        position = self.geometry.attributes.position.array,
	        normal = self.geometry.attributes.normal.array,
	        v,
	        w,
	        m,
	        idx;

	    for (i = 0; i < numVerts; ++i) {
	      v = self.vertices[i];
	      idx = i * 3;
	      position[idx] = position[idx + 1] = position[idx + 2] = 0;
	      normal[idx] = normal[idx + 1] = normal[idx + 2] = 0;

	      for (j = 0; j < 4; ++j) {
	        if (v.weights[j] > 0) {
	          w = v.weights[j];
	          m = anim.fps == 1 ? self.tmpMat : self.transforms[v.bones[j]];
	          vec3.transformMat4(vec, v.position, m);
	          position[idx] += vec[0] * w;
	          position[idx + 1] += vec[1] * w;
	          position[idx + 2] += vec[2] * w;
	          vec4.transformMat4(vec, v.normal, m);
	          normal[idx] += vec[0] * w;
	          normal[idx + 1] += vec[1] * w;
	          normal[idx + 2] += vec[2] * w;
	        }
	      }
	    }

	    self.geometry.attributes.position.needsUpdate = true;
	    self.geometry.attributes.normal.needsUpdate = true;
	  }

	  if (self.newAnimation) {
	    self.newAnimation = false;
	  }
	};

	Model.prototype.load = function () {
	  var self = this;
	  var loader = new THREE.FileLoader();
	  loader.setResponseType('arraybuffer');
	  loader.load(self.meshUrl, function (buffer) {
	    self.loadMesh(buffer);
	  });
	};

	Model.prototype.loadMesh = function (buffer) {
	  if (!buffer) {
	    console.error("Bad buffer for DataView");
	    return;
	  }

	  var self = this,
	      r = new DataView2(buffer),
	      i,
	      v,
	      idx;

	  try {
	    var magic = r.getUint32();

	    if (magic != 604210091) {
	      console.log("Bad magic value");
	      return;
	    }
	  } catch (err) {
	    alert("Model currently isn't loading! We're sorry and hope to have this fixed soon.");
	    console.log(err);
	    return;
	  }

	  self.version = r.getUint32();
	  var animFile = r.getString();
	  var textureFile = r.getString();

	  if (animFile && animFile.length > 0) {
	    var loader = new THREE.FileLoader();
	    loader.setResponseType('arraybuffer');
	    loader.load(self.animUrl, function (buffer) {
	      self.loadAnim(buffer);
	      self.dispatch.call('loadAnim');
	    });
	  }

	  if (textureFile && textureFile.length > 0) {
	    self.texture = new Texture(self, self.textureUrl);
	  }

	  var numMeshes = r.getUint32();

	  if (numMeshes > 0) {
	    self.meshes = new Array(numMeshes);

	    for (i = 0; i < numMeshes; ++i) {
	      var name = r.getString().toLowerCase();
	      var vStart = r.getUint32();
	      var vCount = r.getUint32();
	      var iStart = r.getUint32();
	      var iCount = r.getUint32();
	      self.meshes[i] = {
	        name: name,
	        vStart: vStart,
	        vCount: vCount,
	        iStart: iStart,
	        iCount: iCount
	      };
	    }
	  }

	  var numVerts = r.getUint32();

	  if (numVerts > 0) {
	    self.vertices = new Array(numVerts);
	    self.vbData = new Float32Array(numVerts * 8);
	    var position = [];
	    var normal = [];
	    var uv = [];

	    for (i = 0; i < numVerts; ++i) {
	      idx = i * 8;
	      self.vertices[i] = v = new Vertex(r);
	      self.vbData[idx] = v.position[0];
	      self.vbData[idx + 1] = v.position[1];
	      self.vbData[idx + 2] = v.position[2];
	      self.vbData[idx + 3] = v.normal[0];
	      self.vbData[idx + 4] = v.normal[1];
	      self.vbData[idx + 5] = v.normal[2];
	      self.vbData[idx + 6] = v.u;
	      self.vbData[idx + 7] = v.v;
	      position.push(v.position[0], v.position[1], v.position[2]);
	      normal.push(v.normal[0], v.normal[1], v.normal[2]);
	      uv.push(v.u, v.v);
	    }

	    self.geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(position), 3));
	    self.geometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(normal), 3));
	    self.geometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(uv), 2));
	  }

	  var numIndices = r.getUint32();

	  if (numIndices > 0) {
	    self.indices = new Array(numIndices);

	    for (i = 0; i < numIndices; ++i) {
	      self.indices[i] = r.getUint16();
	    }

	    self.geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(self.indices), 1));
	  }

	  var numBones = r.getUint32();

	  if (numBones > 0) {
	    self.transforms = new Array(numBones);
	    self.bones = new Array(numBones);

	    for (i = 0; i < numBones; ++i) {
	      self.bones[i] = new Bone(self, i, r);

	      if (self.boneLookup[self.bones[i].name] !== undefined) {
	        self.bones[i].name = self.bones[i].name + "2";
	      }

	      self.boneLookup[self.bones[i].name] = i;
	      self.transforms[i] = new mat4.create();
	    }
	  }

	  self.loaded = true;
	  self.dispatch.call('loadMesh');
	};

	Model.prototype.loadAnim = function (buffer) {
	  if (!buffer) {
	    console.error("Bad buffer for DataView");
	    return;
	  }

	  var self = this,
	      r = new DataView2(buffer),
	      i;
	  var magic = r.getUint32();

	  if (magic != 604210092) {
	    console.log("Bad magic value");
	    return;
	  }

	  var version = r.getUint32();

	  if (version >= 2) {
	    var compressedData = new Uint8Array(buffer, r.position);
	    var data = null;

	    try {
	      data = pako.inflate(compressedData);
	    } catch (err) {
	      console.log("Decompression error: " + err);
	      return;
	    }

	    r = new DataView2(data.buffer);
	  }

	  var numAnims = r.getUint32();

	  if (numAnims > 0) {
	    self.animations = new Array(numAnims);

	    for (i = 0; i < numAnims; ++i) {
	      self.animations[i] = new Animation(self, r, version);
	    }
	  }

	  self.animsLoaded = true;
	};

	Model.prototype.on = function (eventName, callback) {
	  this.dispatch.on(eventName, callback);
	};

	/**
	 * LOLLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function LOLLoader() {
	  BaseLoader.call(this);
	}

	LOLLoader.prototype = Object.create(BaseLoader.prototype);
	LOLLoader.prototype.constructor = LOLLoader;

	LOLLoader.prototype.load = function (url, options) {
	  if (!Array.isArray(url) || url.length < 3) {
	    console.warn(`LOLLoader: url must be an array, and contains .lmesh,.lanim and .png three urls.`);
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  var lmesh = url.filter(n => n.endsWith('.lmesh'))[0];
	  var lanim = url.filter(n => n.endsWith('.lanim'))[0];
	  var png = url.filter(n => n.endsWith('.png'))[0];

	  if (lmesh === undefined) {
	    console.warn(`LOLLoader: url doesn't contain .lmesh url.`);
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  if (lanim === undefined) {
	    console.warn(`LOLLoader: url doesn't contain .lanim url.`);
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  if (png === undefined) {
	    console.warn(`LOLLoader: url doesn't contain .png url.`);
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  var fileName = lmesh.split('/')[lmesh.split('/').length - 1];
	  var fileNameNoExt = fileName.split('.')[0];
	  var champion = fileNameNoExt.split('_')[0];
	  var skin = fileNameNoExt.split('_')[1];
	  return new Promise(resolve => {
	    this.require(['gl-matrix', 'pako']).then(() => {
	      var model = new Model({
	        champion: champion,
	        skin: parseInt(skin),
	        meshUrl: lmesh,
	        animUrl: lanim,
	        textureUrl: png
	      });
	      model.load();
	      model.on('load.LOLLoader', () => {
	        var geometry = model.geometry;
	        var material = model.material;
	        var mesh = new THREE.Mesh(geometry, material);
	        mesh.name = options.Name;
	        mesh.userData.type = 'lol';
	        mesh.userData.model = model;
	        mesh.userData.scripts = [{
	          id: null,
	          name: `${options.Name}${_t('Animation')}`,
	          type: 'javascript',
	          source: this.createScripts(options.Name, model),
	          uuid: THREE.Math.generateUUID()
	        }];
	        resolve(mesh);
	      });
	    });
	  });
	};

	LOLLoader.prototype.createScripts = function (name, model) {
	  var animations = model.getAnimations();
	  return `var mesh = this.getObjectByName('${name}');\n` + `var model = mesh.userData.model;\n\n` + `// animNames: ${animations.join(',')}\n` + `model.setAnimation('${animations[0]}');\n\n` + `function update(clock, deltaTime) { \n    model.update(clock.getElapsedTime() * 1000); \n}`;
	};

	/**
	 * MMDLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function MMDLoader() {
	  BaseLoader.call(this);
	}

	MMDLoader.prototype = Object.create(BaseLoader.prototype);
	MMDLoader.prototype.constructor = MMDLoader;

	MMDLoader.prototype.load = function (url, options, environment) {
	  return new Promise(resolve => {
	    this.require('MMD').then(() => {
	      var loader = new THREE.MMDLoader();
	      var promise1 = options.Animation && options.Animation.Url ? this.loadWithAnimation(url, options, environment, loader) : this.loadModel(url, options, environment, loader);
	      var promise2 = this.loadCameraAnimation(url, options, environment, loader);
	      var promise3 = this.loadAudio(url, options, environment, loader);
	      Promise.all([promise1, promise2, promise3]).then(obj => {
	        var mesh = obj[0].mesh;
	        var animation = obj[0].animation;
	        var cameraAnimation = obj[1];
	        var audio = obj[2];
	        Object.assign(mesh.userData, {
	          obj: {
	            animation: animation,
	            cameraAnimation: cameraAnimation,
	            audio: audio
	          }
	        });
	        resolve(mesh);
	      });
	    });
	  });
	};

	MMDLoader.prototype.loadModel = function (url, options, environment, loader) {
	  return new Promise(resolve => {
	    loader.load(url, mesh => {
	      resolve({
	        mesh: mesh,
	        animation: null
	      });
	    }, undefined, () => {// 某个图片下载失败会导致返回null
	      // resolve(null);
	    });
	  });
	};

	MMDLoader.prototype.loadWithAnimation = function (url, options, environment, loader) {
	  if (!options.Animation || !options.Animation.Url) {
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  return new Promise(resolve => {
	    loader.loadWithAnimation(url, [environment.server + options.Animation.Url], mmd => {
	      resolve(mmd);
	    }, undefined, () => {
	      resolve(null);
	    });
	  });
	};

	MMDLoader.prototype.loadCameraAnimation = function (url, options, environment, loader) {
	  if (!options.CameraAnimation || !options.CameraAnimation.Url) {
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  return new Promise(resolve => {
	    loader.loadAnimation([environment.server + options.CameraAnimation.Url], environment.camera, vmd => {
	      resolve(vmd);
	    }, undefined, () => {
	      resolve(null);
	    });
	  });
	};

	MMDLoader.prototype.loadAudio = function (url, options, environment, loader) {
	  if (!options.Audio || !options.Audio.Url) {
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  return new Promise(resolve => {
	    var loader = new THREE.AudioLoader();
	    loader.load(environment.server + options.Audio.Url, buffer => {
	      var audio = new THREE.Audio(environment.audioListener).setBuffer(buffer);
	      Object.assign(audio.userData, options.Audio);
	      resolve(audio);
	    });
	  });
	};

	/**
	 * JsonLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function JsonLoader() {
	  BaseLoader.call(this);
	}

	JsonLoader.prototype = Object.create(BaseLoader.prototype);
	JsonLoader.prototype.constructor = JsonLoader;

	JsonLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require(['LegacyJSONLoader']).then(() => {
	      var loader = new THREE.LegacyJSONLoader();
	      loader.load(url, (geometry, materials) => {
	        for (var i = 0; i < materials.length; i++) {
	          var m = materials[i];
	          m.skinning = true;
	          m.morphTargets = true;
	        }

	        var mesh = new THREE.SkinnedMesh(geometry, materials); // TODO: 最新版three.js不再支持了

	        if (!mesh.skeleton) {
	          mesh.skeleton = {
	            update: function () {}
	          };
	        }

	        Object.assign(mesh.userData, {
	          obj: [geometry, materials],
	          root: mesh,
	          scripts: [{
	            id: null,
	            name: `${options.Name}${_t('Animation')}`,
	            type: 'javascript',
	            source: this.createScripts(options.Name),
	            uuid: THREE.Math.generateUUID()
	          }]
	        });
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	JsonLoader.prototype.createScripts = function (name) {
	  return `var mesh = this.getObjectByName('${name}');\n` + `var mixer = new THREE.AnimationMixer(mesh)\n` + `mixer.clipAction(mesh.geometry.animations[0]).play();\n\n` + `function update(clock, deltaTime) { \n    mixer.update(deltaTime); \n}`;
	};

	/**
	 * 3DSLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function _3DSLoader() {
	  BaseLoader.call(this);
	}

	_3DSLoader.prototype = Object.create(BaseLoader.prototype);
	_3DSLoader.prototype.constructor = _3DSLoader;

	_3DSLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('TDSLoader').then(() => {
	      var loader = new THREE.TDSLoader();
	      loader.load(url, group => {
	        resolve(group);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * 3MFLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function _3MFLoader() {
	  BaseLoader.call(this);
	}

	_3MFLoader.prototype = Object.create(BaseLoader.prototype);
	_3MFLoader.prototype.constructor = _3MFLoader;

	_3MFLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('3MFLoader').then(() => {
	      var loader = new THREE.ThreeMFLoader();
	      loader.load(url, object => {
	        resolve(object);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * AssimpLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function AssimpLoader() {
	  BaseLoader.call(this);
	}

	AssimpLoader.prototype = Object.create(BaseLoader.prototype);
	AssimpLoader.prototype.constructor = AssimpLoader;

	AssimpLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require('AssimpLoader').then(() => {
	      var loader = new THREE.AssimpLoader();
	      loader.load(url, result => {
	        var obj = result.object;
	        Object.assign(obj.userData, {
	          obj: result,
	          root: obj
	        });

	        if (result.animation) {
	          Object.assign(obj.userData, {
	            animNames: 'Animation1',
	            scripts: [{
	              id: null,
	              name: `${options.Name}${_t('Animation')}`,
	              type: 'javascript',
	              source: this.createScripts(options.Name),
	              uuid: THREE.Math.generateUUID()
	            }]
	          });
	        }

	        resolve(obj);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	AssimpLoader.prototype.createScripts = function (name) {
	  return `var mesh = this.getObjectByName('${name}');\n\n` + `var animation = mesh.userData.obj.animation;\n\n` + `function update(clock, deltaTime) { \n  if(animation) {\n     animation.setTime( performance.now() / 1000 ); \n    } \n}`;
	};

	/**
	 * BVHLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function BVHLoader() {
	  BaseLoader.call(this);
	}

	BVHLoader.prototype = Object.create(BaseLoader.prototype);
	BVHLoader.prototype.constructor = BVHLoader;

	BVHLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require('BVHLoader').then(() => {
	      var loader = new THREE.BVHLoader();
	      loader.load(url, result => {
	        var skeletonHelper = new THREE.SkeletonHelper(result.skeleton.bones[0]);
	        skeletonHelper.skeleton = result.skeleton; // allow animation mixer to bind to SkeletonHelper directly

	        var boneContainer = new THREE.Group();
	        boneContainer.add(result.skeleton.bones[0]);
	        var obj3d = new THREE.Object3D();
	        obj3d.add(skeletonHelper);
	        obj3d.add(boneContainer);
	        Object.assign(obj3d.userData, {
	          obj: result,
	          root: skeletonHelper
	        });
	        Object.assign(obj3d.userData, {
	          animNames: 'Animation1',
	          scripts: [{
	            id: null,
	            name: `${options.Name}${_t('Animation')}`,
	            type: 'javascript',
	            source: this.createScripts(options.Name),
	            uuid: THREE.Math.generateUUID()
	          }]
	        });
	        resolve(obj3d);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	BVHLoader.prototype.createScripts = function (name) {
	  return `var mesh = this.getObjectByName('${name}');\n\n` + `var mixer = new THREE.AnimationMixer(mesh.userData.root);\n\n` + `mixer.clipAction(mesh.userData.obj.clip).setEffectiveWeight(1.0).play();` + `function update(clock, deltaTime) { \n     mixer.update(deltaTime); \n}`;
	};

	/**
	 * DRACOLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function DRACOLoader() {
	  BaseLoader.call(this);
	}

	DRACOLoader.prototype = Object.create(BaseLoader.prototype);
	DRACOLoader.prototype.constructor = DRACOLoader;

	DRACOLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('DRACOLoader').then(() => {
	      THREE.DRACOLoader.setDecoderPath('assets/js/libs/draco/');
	      THREE.DRACOLoader.setDecoderConfig({
	        type: 'js'
	      });
	      var loader = new THREE.DRACOLoader();
	      loader.load(url, geometry => {
	        geometry.computeVertexNormals();
	        var material = new THREE.MeshStandardMaterial();
	        var mesh = new THREE.Mesh(geometry, material); // Release decoder resources.

	        THREE.DRACOLoader.releaseDecoderModule();
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * GCodeLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function GCodeLoader() {
	  BaseLoader.call(this);
	}

	GCodeLoader.prototype = Object.create(BaseLoader.prototype);
	GCodeLoader.prototype.constructor = GCodeLoader;

	GCodeLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require('GCodeLoader').then(() => {
	      var loader = new THREE.GCodeLoader();
	      loader.load(url, obj3d => {
	        resolve(obj3d);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * NRRDLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function NRRDLoader() {
	  BaseLoader.call(this);
	}

	NRRDLoader.prototype = Object.create(BaseLoader.prototype);
	NRRDLoader.prototype.constructor = NRRDLoader;

	NRRDLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require('NRRDLoader').then(() => {
	      var loader = new THREE.NRRDLoader();
	      loader.load(url, result => {
	        var loader = new THREE.NRRDLoader();
	        loader.load(url, volume => {
	          var obj = new THREE.Object3D(); // x plane

	          var sliceX = volume.extractSlice('x', Math.floor(volume.RASDimensions[0] / 2));
	          obj.add(sliceX.mesh); //y plane

	          var sliceY = volume.extractSlice('y', Math.floor(volume.RASDimensions[1] / 2));
	          obj.add(sliceY.mesh); //z plane

	          var sliceZ = volume.extractSlice('z', Math.floor(volume.RASDimensions[2] / 4));
	          obj.add(sliceZ.mesh);
	          resolve(obj);
	        });
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * PCDLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function PCDLoader() {
	  BaseLoader.call(this);
	}

	PCDLoader.prototype = Object.create(BaseLoader.prototype);
	PCDLoader.prototype.constructor = PCDLoader;

	PCDLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require('PCDLoader').then(() => {
	      var loader = new THREE.PCDLoader();
	      loader.load(url, mesh => {
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * PDBLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function PDBLoader() {
	  BaseLoader.call(this);
	}

	PDBLoader.prototype = Object.create(BaseLoader.prototype);
	PDBLoader.prototype.constructor = PDBLoader;

	PDBLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require('PDBLoader').then(() => {
	      var loader = new THREE.PDBLoader();
	      var offset = new THREE.Vector3();
	      loader.load(url, pdb => {
	        var geometryAtoms = pdb.geometryAtoms;
	        var geometryBonds = pdb.geometryBonds;
	        var json = pdb.json;
	        var root = new THREE.Group();
	        var boxGeometry = new THREE.BoxBufferGeometry(1, 1, 1);
	        var sphereGeometry = new THREE.IcosahedronBufferGeometry(1, 2);
	        geometryAtoms.computeBoundingBox();
	        geometryAtoms.boundingBox.getCenter(offset).negate();
	        geometryAtoms.translate(offset.x, offset.y, offset.z);
	        geometryBonds.translate(offset.x, offset.y, offset.z);
	        var positions = geometryAtoms.getAttribute('position');
	        var colors = geometryAtoms.getAttribute('color');
	        var position = new THREE.Vector3();
	        var color = new THREE.Color();

	        for (var i = 0; i < positions.count; i++) {
	          position.x = positions.getX(i);
	          position.y = positions.getY(i);
	          position.z = positions.getZ(i);
	          color.r = colors.getX(i);
	          color.g = colors.getY(i);
	          color.b = colors.getZ(i);
	          var material = new THREE.MeshPhongMaterial({
	            color: color
	          });
	          var object = new THREE.Mesh(sphereGeometry, material);
	          object.position.copy(position);
	          object.position.multiplyScalar(75);
	          object.scale.multiplyScalar(25);
	          root.add(object);
	        }

	        positions = geometryBonds.getAttribute('position');
	        var start = new THREE.Vector3();
	        var end = new THREE.Vector3();

	        for (var i = 0; i < positions.count; i += 2) {
	          start.x = positions.getX(i);
	          start.y = positions.getY(i);
	          start.z = positions.getZ(i);
	          end.x = positions.getX(i + 1);
	          end.y = positions.getY(i + 1);
	          end.z = positions.getZ(i + 1);
	          start.multiplyScalar(75);
	          end.multiplyScalar(75);
	          var object = new THREE.Mesh(boxGeometry, new THREE.MeshPhongMaterial(0xffffff));
	          object.position.copy(start);
	          object.position.lerp(end, 0.5);
	          object.scale.set(5, 5, start.distanceTo(end));
	          object.lookAt(end);
	          root.add(object);
	        }

	        resolve(root);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * PRWMLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function PRWMLoader() {
	  BaseLoader.call(this);
	}

	PRWMLoader.prototype = Object.create(BaseLoader.prototype);
	PRWMLoader.prototype.constructor = PRWMLoader;

	PRWMLoader.prototype.load = function (url) {
	  return new Promise(resolve => {
	    this.require('PRWMLoader').then(() => {
	      var loader = new THREE.PRWMLoader();
	      loader.load(url, geometry => {
	        var material = new THREE.MeshPhongMaterial();
	        var mesh = new THREE.Mesh(geometry, material);
	        resolve(mesh);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * SEA3DLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function SEA3DLoader() {
	  BaseLoader.call(this);
	}

	SEA3DLoader.prototype = Object.create(BaseLoader.prototype);
	SEA3DLoader.prototype.constructor = SEA3DLoader;

	SEA3DLoader.prototype.load = function (url, options) {
	  var obj = new THREE.Object3D();
	  return new Promise(resolve => {
	    this.require('SEA3D').then(() => {
	      var loader = new THREE.SEA3D({
	        autoPlay: true,
	        // Auto play animations
	        container: obj,
	        // Container to add models
	        progressive: true // Progressive download

	      });

	      loader.onComplete = function () {
	        resolve(obj);
	      };

	      loader.load(url);
	      Object.assign(obj.userData, {
	        animNames: ['Animation1'],
	        scripts: [{
	          id: null,
	          name: `${options.Name}${_t('Animation')}`,
	          type: 'javascript',
	          source: this.createScripts(options.Name),
	          uuid: THREE.Math.generateUUID()
	        }]
	      });
	    });
	  });
	};

	SEA3DLoader.prototype.createScripts = function (name) {
	  return `function update(clock, deltaTime) { \n    THREE.SEA3D.AnimationHandler.update(deltaTime); \n}`;
	};

	/**
	 * VRMLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function VRMLoader() {
	  BaseLoader.call(this);
	}

	VRMLoader.prototype = Object.create(BaseLoader.prototype);
	VRMLoader.prototype.constructor = VRMLoader;

	VRMLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require(['GLTFLoader', 'VRMLoader']).then(() => {
	      var loader = new THREE.VRMLoader();
	      loader.load(url, vrm => {
	        // VRMLoader doesn't support VRM Unlit extension yet so
	        // converting all materials to MeshBasicMaterial here as workaround so far.
	        vrm.scene.traverse(function (object) {
	          if (object.material) {
	            if (Array.isArray(object.material)) {
	              for (var i = 0, il = object.material.length; i < il; i++) {
	                var material = new THREE.MeshBasicMaterial();
	                THREE.Material.prototype.copy.call(material, object.material[i]);
	                material.color.copy(object.material[i].color);
	                material.map = object.material[i].map;
	                material.lights = false;
	                material.skinning = object.material[i].skinning;
	                material.morphTargets = object.material[i].morphTargets;
	                material.morphNormals = object.material[i].morphNormals;
	                object.material[i] = material;
	              }
	            } else {
	              var material = new THREE.MeshBasicMaterial();
	              THREE.Material.prototype.copy.call(material, object.material);
	              material.color.copy(object.material.color);
	              material.map = object.material.map;
	              material.lights = false;
	              material.skinning = object.material.skinning;
	              material.morphTargets = object.material.morphTargets;
	              material.morphNormals = object.material.morphNormals;
	              object.material = material;
	            }
	          }
	        });
	        resolve(vrm.scene);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * VRMLLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function VRMLLoader() {
	  BaseLoader.call(this);
	}

	VRMLLoader.prototype = Object.create(BaseLoader.prototype);
	VRMLLoader.prototype.constructor = VRMLLoader;

	VRMLLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require(['chevrotain', 'VRMLLoader']).then(() => {
	      var loader = new THREE.VRMLLoader();
	      loader.load(url, obj => {
	        resolve(obj);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	/**
	 * XLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function XLoader() {
	  BaseLoader.call(this);
	}

	XLoader.prototype = Object.create(BaseLoader.prototype);
	XLoader.prototype.constructor = XLoader;

	XLoader.prototype.load = function (url, options) {
	  return new Promise(resolve => {
	    this.require('XLoader').then(() => {
	      var loader = new THREE.XLoader();
	      loader.load([url], object => {
	        var obj = new THREE.Object3D();

	        for (var i = 0; i < object.models.length; i++) {
	          var model = object.models[i];
	          obj.add(model);
	        }

	        resolve(obj);
	      }, undefined, () => {
	        resolve(null);
	      });
	    });
	  });
	};

	const Loaders = {
	  '_3ds': _3DSLoader,
	  '_3mf': _3MFLoader,
	  'amf': AMFLoader,
	  'assimp': AssimpLoader,
	  'awd': AWDLoader,
	  'babylon': BabylonLoader,
	  'binary': BinaryLoader,
	  'bvh': BVHLoader,
	  'ctm': CTMLoader,
	  'dae': ColladaLoader,
	  'fbx': FBXLoader,
	  'glb': GLTFLoader,
	  'gltf': GLTFLoader,
	  'kmz': KMZLoader,
	  'md2': MD2Loader,
	  'json': ObjectLoader,
	  'obj': OBJLoader,
	  'ply': PLYLoader,
	  'stl': STLLoader,
	  'vtk': VTKLoader,
	  'lol': LOLLoader,
	  'pmd': MMDLoader,
	  'pmx': MMDLoader,
	  'js': JsonLoader,
	  'drc': DRACOLoader,
	  'gcode': GCodeLoader,
	  'nrrd': NRRDLoader,
	  'pcd': PCDLoader,
	  'pdb': PDBLoader,
	  'prwm': PRWMLoader,
	  'sea3d': SEA3DLoader,
	  'vrm': VRMLoader,
	  'vrml': VRMLLoader,
	  'x': XLoader
	};
	/**
	 * ModelLoader
	 * @author tengge / https://github.com/tengge1
	 */

	function ModelLoader() {
	  BaseLoader.call(this);
	}

	ModelLoader.prototype = Object.create(BaseLoader.prototype);
	ModelLoader.prototype.constructor = ModelLoader;

	ModelLoader.prototype.load = function (url, options = {}, environment = {}) {
	  var type = options.Type;

	  if (type === undefined) {
	    console.warn(`ModelLoader: no type parameters, and cannot load.`);
	    return new Promise(resolve => {
	      resolve(null);
	    });
	  }

	  return new Promise(resolve => {
	    var loader = Loaders[type];

	    if (loader === undefined) {
	      console.warn(`ModelLoader: no ${type} loader.`);
	      resolve(null);
	      return;
	    }

	    new loader(app).load(url, options, environment).then(obj => {
	      if (!obj || !obj.userData) {
	        resolve(null);
	        return;
	      } // 由于每次加载模型，uuid会变，所以要记录原始模型的uuid，而且只能记录一次。


	      if (obj.children && !obj.userData._children) {
	        obj.userData._children = []; // 原始模型的uuid层次

	        this.serializeChildren(obj.children, obj.userData._children);
	      }

	      obj.userData.physics = obj.userData.physics || {
	        enabled: false,
	        type: 'rigidBody',
	        shape: 'btBoxShape',
	        mass: 1,
	        inertia: {
	          x: 0,
	          y: 0,
	          z: 0
	        }
	      };
	      resolve(obj);
	    });
	  });
	};
	/**
	 * 记录最原始的模型，每个组件的uuid。
	 * @param {Array} children 每个子元素
	 * @param {Array} list 数组
	 */


	ModelLoader.prototype.serializeChildren = function (children, list) {
	  for (let i = 0; i < children.length; i++) {
	    let child = children[i];
	    let list1 = [];

	    if (child.children && child.children.length > 0) {
	      this.serializeChildren(child.children, list1);
	    }

	    list.push({
	      uuid: child.uuid,
	      children: list1
	    });
	  }
	};

	/**
	 * ServerObject
	 * @author tengge / https://github.com/tengge1
	 */

	function ServerObject() {
	  BaseSerializer.call(this);
	}

	ServerObject.prototype = Object.create(BaseSerializer.prototype);
	ServerObject.prototype.constructor = ServerObject;

	ServerObject.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  json.userData = Object.assign({}, obj.userData);
	  delete json.userData.model;
	  delete json.userData.obj; // 以后下载对象缓存统一改为obj

	  delete json.userData.root; // 模型根节点

	  delete json.userData.helper; // 模型被调整了层次和顺序，所以要记录调整过的uuid。

	  json.userData.children = [];
	  this.serializeChildren(obj.children, json.userData.children);
	  return json;
	};
	/**
	 * 记录模型内部，调整过的每个组件的uuid。
	 * @param {Array} children 每个子元素
	 * @param {Array} list 数组
	 */


	ServerObject.prototype.serializeChildren = function (children, list) {
	  for (let i = 0; i < children.length; i++) {
	    let child = children[i];
	    let list1 = [];

	    if (child.children && child.children.length > 0) {
	      this.serializeChildren(child.children, list1);
	    }

	    list.push({
	      uuid: child.uuid,
	      children: list1
	    });
	  }
	};

	ServerObject.prototype.fromJSON = function (json, options, environment) {
	  let url = json.userData.Url;

	  if (url.indexOf(';') > -1) {
	    // 包含多个入口文件
	    url = url.split(';').map(n => options.server + n);
	  } else {
	    url = options.server + url;
	  } // 将server传递给MMDLoader，以便下载资源


	  environment.server = options.server;
	  const loader = new ModelLoader();
	  return new Promise(resolve => {
	    loader.load(url, json.userData, environment).then(obj => {
	      if (obj) {
	        Object3DSerializer.prototype.fromJSON.call(this, json, obj); // 还原原始模型的uuid

	        if (Array.isArray(json.userData._children)) {
	          this.revertUUID(obj.children, json.userData._children);
	        } // TODO: 新数据结构不需要还原原来的模型


	        if (environment.parts) {
	          this.revertObject(obj, environment.parts);
	        }

	        resolve(obj);
	      } else {
	        resolve(null);
	      }
	    });
	  });
	};
	/**
	 * 还原原始模型的uuid。
	 * @param {THREE.Object3D} children 部件
	 * @param {Array} list 原始的uuid列表
	 */


	ServerObject.prototype.revertUUID = function (children, list) {
	  for (let i = 0; i < children.length; i++) {
	    let child = children[i];

	    if (list[i]) {
	      child.uuid = list[i].uuid;
	    }

	    if (child.children && list[i] && list[i].children) {
	      this.revertUUID(child.children, list[i].children);
	    }
	  }
	};
	/**
	 * 还原调整过顺序的原始模型。
	 * @param {THREE.Object3D} obj 服务端模型
	 * @param {Array} parts 反序列化后的模型组件
	 */


	ServerObject.prototype.revertObject = function (obj, parts = []) {
	  let list = obj.userData.children;

	  if (!Array.isArray(list) || list.length === 0) {
	    return;
	  }

	  let children = [];
	  this.traverseChildren(obj, children);
	  this.revertLayer(obj, list, children, parts);
	};
	/**
	 * 将模型所有子元素展开成一维数组
	 * @param {THREE.Object} obj 服务端模型
	 * @param {Array} list 模型子组件列表
	 */


	ServerObject.prototype.traverseChildren = function (obj, list) {
	  if (!Array.isArray(obj.children) || obj.children.length === 0) {
	    return;
	  }

	  while (obj.children.length) {
	    let child = obj.children[0];

	    if (child.parent) {
	      child.parent.remove(child);
	    }

	    list.push(child);
	    this.traverseChildren(child, list);
	  }
	};
	/**
	 * 还原服务端模型原来的层次结构
	 * @param {*} obj 
	 * @param {*} list 
	 * @param {*} children 
	 * @param {*} parts 
	 */


	ServerObject.prototype.revertLayer = function (obj, list, children, parts) {
	  for (let i = 0; i < list.length; i++) {
	    let item = list[i];
	    const child1 = children.filter(n => n.uuid === item.uuid)[0];
	    const child2 = parts.filter(n => n.uuid === item.uuid)[0];
	    let child = null;

	    if (child1) {
	      obj.add(child1);
	      child = child1;

	      if (child2) {
	        // TODO: 服务端原始模型组件，需要复制反序列化后的组件的属性。
	        child1.name = child2.name;

	        if (child1.position && child2.position) {
	          child1.position.copy(child2.position);
	        }

	        if (child1.rotation && child2.rotation) {
	          child1.rotation.copy(child2.rotation);
	        }

	        if (child1.scale && child2.scale) {
	          child1.scale.copy(child2.scale);
	        }

	        if (child1.material && child2.material) {
	          child1.material = child2.material;
	        }
	      }
	    } else if (child2) {
	      obj.add(child2);
	      child = child2;
	    } else {
	      console.warn(`ServerObject: no object with uuid ${item.uuid}.`);
	    }

	    if (child && Array.isArray(item.children) && item.children.length > 0) {
	      this.revertLayer(child, item.children, children, parts);
	    }
	  }
	};

	/**
	 * WebGLShadowMapSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function WebGLShadowMapSerializer() {
	  BaseSerializer.call(this);
	}

	WebGLShadowMapSerializer.prototype = Object.create(BaseSerializer.prototype);
	WebGLShadowMapSerializer.prototype.constructor = WebGLShadowMapSerializer;

	WebGLShadowMapSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.autoUpdate = obj.autoUpdate;
	  json.enabled = obj.enabled;
	  json.needsUpdate = obj.needsUpdate;
	  json.type = obj.type;
	  return json;
	};

	WebGLShadowMapSerializer.prototype.fromJSON = function (json, parent) {
	  if (parent === undefined) {
	    console.warn(`WebGLShadowMapSerializer: parent is empty.`);
	    return null;
	  }

	  var obj = parent;
	  obj.autoUpdate = json.autoUpdate;
	  obj.enabled = json.enabled;
	  obj.needsUpdate = true;
	  obj.type = json.type;
	  return obj;
	};

	/**
	 * WebGLRendererSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function WebGLRendererSerializer() {
	  BaseSerializer.call(this);
	}

	WebGLRendererSerializer.prototype = Object.create(BaseSerializer.prototype);
	WebGLRendererSerializer.prototype.constructor = WebGLRendererSerializer;

	WebGLRendererSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.antialias = true;
	  json.autoClear = obj.autoClear;
	  json.autoClearColor = obj.autoClearColor;
	  json.autoClearDepth = obj.autoClearDepth;
	  json.autoClearStencil = obj.autoClearStencil;
	  json.autoUpdateScene = obj.autoUpdateScene;
	  json.clippingPlanes = obj.clippingPlanes;
	  json.gammaFactor = obj.gammaFactor;
	  json.gammaInput = obj.gammaInput;
	  json.gammaOutput = obj.gammaOutput;
	  json.localClippingEnabled = obj.localClippingEnabled;
	  json.physicallyCorrectLights = obj.physicallyCorrectLights;
	  json.shadowMap = new WebGLShadowMapSerializer().toJSON(obj.shadowMap);
	  json.sortObjects = obj.sortObjects;
	  json.toneMapping = obj.toneMapping;
	  json.toneMappingExposure = obj.toneMappingExposure;
	  json.toneMappingWhitePoint = obj.toneMappingWhitePoint;
	  return json;
	};

	WebGLRendererSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.WebGLRenderer({
	    antialias: json.antialias
	  }) : parent;
	  obj.autoClear = json.autoClear;
	  obj.autoClearColor = json.autoClearColor;
	  obj.autoClearDepth = json.autoClearDepth;
	  obj.autoClearStencil = json.autoClearStencil;
	  obj.autoUpdateScene = json.autoUpdateScene;
	  obj.clippingPlanes = json.clippingPlanes;
	  obj.gammaFactor = json.gammaFactor;
	  obj.gammaInput = json.gammaInput;
	  obj.gammaOutput = json.gammaOutput;
	  obj.localClippingEnabled = json.localClippingEnabled;
	  obj.physicallyCorrectLights = json.physicallyCorrectLights;
	  new WebGLShadowMapSerializer().fromJSON(json.shadowMap, obj.shadowMap);
	  obj.sortObjects = json.sortObjects;
	  obj.toneMapping = json.toneMapping;
	  obj.toneMappingExposure = json.toneMappingExposure;
	  obj.toneMappingWhitePoint = json.toneMappingWhitePoint;
	  return obj;
	};

	/**
	 * OptionsSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function OptionsSerializer() {
	  BaseSerializer.call(this);
	}

	OptionsSerializer.prototype = Object.create(BaseSerializer.prototype);
	OptionsSerializer.prototype.constructor = OptionsSerializer;

	OptionsSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  Object.assign(json, obj);
	  return json;
	};

	OptionsSerializer.prototype.fromJSON = function (json) {
	  var obj = {};
	  Object.keys(json).forEach(n => {
	    if (n === '_id' || n === 'metadata' || n === 'server') {
	      // 由于不同服务器的服务端不一样，所以不能反序列化server配置
	      return;
	    }

	    obj[n] = json[n];
	  });
	  return obj;
	};

	/**
	 * ScriptSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ScriptSerializer() {
	  BaseSerializer.call(this);
	}

	ScriptSerializer.prototype = Object.create(BaseSerializer.prototype);
	ScriptSerializer.prototype.constructor = ScriptSerializer;

	ScriptSerializer.prototype.toJSON = function (scripts) {
	  var list = [];
	  Object.keys(scripts).forEach(uuid => {
	    var json = BaseSerializer.prototype.toJSON.call(this);
	    var script = scripts[uuid];
	    Object.assign(json, {
	      id: script.id,
	      name: script.name,
	      type: script.type,
	      source: script.source,
	      uuid: script.uuid
	    });
	    list.push(json);
	  });
	  return list;
	};

	ScriptSerializer.prototype.fromJSON = function (jsons, parent) {
	  parent = parent || {};
	  jsons.forEach(json => {
	    parent[json.uuid] = {
	      id: json.id,
	      name: json.name,
	      type: json.type,
	      source: json.source,
	      uuid: json.uuid
	    };
	  });
	  return parent;
	};

	/**
	 * AnimationSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function AnimationSerializer() {
	  BaseSerializer.call(this);
	}

	AnimationSerializer.prototype = Object.create(BaseSerializer.prototype);
	AnimationSerializer.prototype.constructor = AnimationSerializer;

	AnimationSerializer.prototype.toJSON = function (list) {
	  var jsons = [];
	  list.forEach(n => {
	    var json = BaseSerializer.prototype.toJSON.call(this, n);
	    Object.assign(json, n);
	    jsons.push(json);
	  });
	  return jsons;
	};

	AnimationSerializer.prototype.fromJSON = function (jsons) {
	  var list = [];
	  jsons.forEach(n => {
	    var obj = Object.assign({}, n);
	    delete obj.metadata;
	    list.push(obj);
	  });
	  return list;
	};

	/**
	 * CameraSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CameraSerializer() {
	  BaseSerializer.call(this);
	}

	CameraSerializer.prototype = Object.create(BaseSerializer.prototype);
	CameraSerializer.prototype.constructor = CameraSerializer;

	CameraSerializer.prototype.filter = function (obj) {
	  if (obj instanceof THREE.Camera) {
	    return true;
	  } else if (obj.metadata && obj.metadata.generator === this.constructor.name) {
	    return true;
	  } else {
	    return false;
	  }
	};

	CameraSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  json.matrixWorldInverse = obj.matrixWorldInverse;
	  json.projectionMatrix = obj.projectionMatrix;
	  return json;
	};

	CameraSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.Camera() : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.matrixWorldInverse.copy(json.matrixWorldInverse);
	  obj.projectionMatrix.copy(json.projectionMatrix);
	  return obj;
	};

	/**
	 * OrthographicCameraSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function OrthographicCameraSerializer() {
	  BaseSerializer.call(this);
	}

	OrthographicCameraSerializer.prototype = Object.create(BaseSerializer.prototype);
	OrthographicCameraSerializer.prototype.constructor = OrthographicCameraSerializer;

	OrthographicCameraSerializer.prototype.toJSON = function (obj) {
	  var json = CameraSerializer.prototype.toJSON.call(this, obj);
	  json.bottom = obj.bottom;
	  json.far = obj.far;
	  json.left = obj.left;
	  json.near = obj.near;
	  json.right = obj.right;
	  json.top = obj.top;
	  json.view = obj.view;
	  json.zoom = obj.zoom;
	  return json;
	};

	OrthographicCameraSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.OrthographicCamera() : parent;
	  CameraSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.bottom = json.bottom;
	  obj.far = json.far;
	  obj.left = json.left;
	  obj.near = json.near;
	  obj.right = json.right;
	  obj.top = json.top;
	  obj.view = json.view;
	  obj.zoom = json.zoom;
	  return obj;
	};

	/**
	 * PerspectiveCameraSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function PerspectiveCameraSerializer() {
	  BaseSerializer.call(this);
	}

	PerspectiveCameraSerializer.prototype = Object.create(BaseSerializer.prototype);
	PerspectiveCameraSerializer.prototype.constructor = PerspectiveCameraSerializer;

	PerspectiveCameraSerializer.prototype.toJSON = function (obj) {
	  var json = CameraSerializer.prototype.toJSON.call(this, obj);
	  json.aspect = obj.aspect;
	  json.far = obj.far;
	  json.filmGauge = obj.filmGauge;
	  json.filmOffset = obj.filmOffset;
	  json.focus = obj.focus;
	  json.fov = obj.fov;
	  json.near = obj.near;
	  json.view = obj.view;
	  json.zoom = obj.zoom;
	  return json;
	};

	PerspectiveCameraSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.PerspectiveCamera() : parent;
	  CameraSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.aspect = json.aspect;
	  obj.far = json.far;
	  obj.filmGauge = json.filmGauge;
	  obj.filmOffset = json.filmOffset;
	  obj.focus = json.focus;
	  obj.fov = json.fov;
	  obj.near = json.near;
	  obj.view = json.view;
	  obj.zoom = json.zoom;
	  return obj;
	};

	var Serializers$3 = {
	  'OrthographicCamera': OrthographicCameraSerializer,
	  'PerspectiveCamera': PerspectiveCameraSerializer,
	  'Camera': CameraSerializer
	};
	/**
	 * CamerasSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CamerasSerializer() {
	  BaseSerializer.call(this);
	}

	CamerasSerializer.prototype = Object.create(BaseSerializer.prototype);
	CamerasSerializer.prototype.constructor = CamerasSerializer;

	CamerasSerializer.prototype.toJSON = function (obj) {
	  var serializer = Serializers$3[obj.constructor.name];

	  if (serializer === undefined) {
	    console.warn(`CamerasSerializer: No serializer with ${obj.constructor.name}.`);
	    return null;
	  }

	  return new serializer().toJSON(obj);
	};

	CamerasSerializer.prototype.fromJSON = function (json, parent) {
	  var generator = json.metadata.generator;
	  var serializer = Serializers$3[generator.replace('Serializer', '')];

	  if (serializer === undefined) {
	    console.warn(`CamerasSerializer: No deserializer with ${generator}.`);
	    return null;
	  }

	  return new serializer().fromJSON(json, parent);
	};

	/**
	 * WebGLRenderTargetSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function WebGLRenderTargetSerializer() {
	  BaseSerializer.call(this);
	}

	WebGLRenderTargetSerializer.prototype = Object.create(BaseSerializer.prototype);
	WebGLRenderTargetSerializer.prototype.constructor = WebGLRenderTargetSerializer;

	WebGLRenderTargetSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.depthBuffer = obj.depthBuffer;
	  json.depthTexture = obj.depthTexture == null ? null : new TexturesSerializer().toJSON(obj.depthTexture);
	  json.height = obj.height;
	  json.scissor = obj.scissor;
	  json.scissorTest = obj.scissorTest;
	  json.stencilBuffer = obj.stencilBuffer;
	  json.texture = obj.texture == null ? null : new TexturesSerializer().toJSON(obj.texture);
	  json.viewport = obj.viewport;
	  json.width = obj.width;
	  json.isWebGLRenderTarget = obj.isWebGLRenderTarget;
	  return json;
	};

	WebGLRenderTargetSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.WebGLRenderTarget(json.width, json.height) : parent;
	  obj.depthBuffer = json.depthBuffer;
	  obj.depthTexture = json.depthTexture == null ? null : new TexturesSerializer().fromJSON(json.depthTexture);
	  obj.height = json.height;
	  obj.scissor.copy(json.scissor);
	  obj.scissorTest = json.scissorTest;
	  obj.stencilBuffer = json.stencilBuffer;
	  obj.texture = json.texture == null ? null : new TexturesSerializer().fromJSON(json.texture);
	  obj.viewport.copy(json.viewport);
	  obj.width = json.width;
	  obj.isWebGLRenderTarget = json.isWebGLRenderTarget;
	  return obj;
	};

	/**
	 * LightShadowSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function LightShadowSerializer() {
	  BaseSerializer.call(this);
	}

	LightShadowSerializer.prototype = Object.create(BaseSerializer.prototype);
	LightShadowSerializer.prototype.constructor = LightShadowSerializer;

	LightShadowSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.bias = obj.bias;
	  json.camera = new CamerasSerializer().toJSON(obj.camera);
	  json.map = obj.map == null ? null : new WebGLRenderTargetSerializer().toJSON(obj.map);
	  json.mapSize = obj.mapSize;
	  json.matrix = obj.matrix;
	  json.radius = obj.radius;
	  return json;
	};

	LightShadowSerializer.prototype.fromJSON = function (json, parent) {
	  var camera = new CamerasSerializer().fromJSON(json.camera);
	  var obj = parent === undefined ? new THREE.LightShadow(camera) : parent;
	  obj.bias = json.bias;
	  obj.camera.copy(camera); // 纹理时自动生成的，不要反序列化
	  // obj.map = json.map == null ? null : (new WebGLRenderTargetSerializer()).fromJSON(json.map);

	  obj.mapSize.copy(json.mapSize);
	  obj.matrix.copy(json.matrix);
	  obj.radius = json.radius;
	  return obj;
	};

	/**
	 * DirectionalLightShadowSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function DirectionalLightShadowSerializer() {
	  BaseSerializer.call(this);
	}

	DirectionalLightShadowSerializer.prototype = Object.create(BaseSerializer.prototype);
	DirectionalLightShadowSerializer.prototype.constructor = DirectionalLightShadowSerializer;

	DirectionalLightShadowSerializer.prototype.toJSON = function (obj) {
	  var json = LightShadowSerializer.prototype.toJSON.call(this, obj);
	  json.isDirectionalLightShadow = obj.isDirectionalLightShadow;
	  return json;
	};

	DirectionalLightShadowSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.DirectionalLightShadow() : parent;
	  LightShadowSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * SpotLightShadowSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SpotLightShadowSerializer() {
	  BaseSerializer.call(this);
	}

	SpotLightShadowSerializer.prototype = Object.create(BaseSerializer.prototype);
	SpotLightShadowSerializer.prototype.constructor = SpotLightShadowSerializer;

	SpotLightShadowSerializer.prototype.toJSON = function (obj) {
	  var json = LightShadowSerializer.prototype.toJSON.call(this, obj);
	  json.isSpotLightShadow = obj.isSpotLightShadow;
	  return json;
	};

	SpotLightShadowSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.SpotLightShadow() : parent;
	  LightShadowSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	var Serializers$4 = {
	  'LightShadow': LightShadowSerializer,
	  'DirectionalLightShadow': DirectionalLightShadowSerializer,
	  'SpotLightShadow': SpotLightShadowSerializer
	};
	/**
	 * LightShadowsSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function LightShadowsSerializer() {
	  BaseSerializer.call(this);
	}

	LightShadowsSerializer.prototype = Object.create(BaseSerializer.prototype);
	LightShadowsSerializer.prototype.constructor = LightShadowsSerializer;

	LightShadowsSerializer.prototype.toJSON = function (obj) {
	  var serializer = Serializers$4[obj.constructor.name];

	  if (serializer === undefined) {
	    console.warn(`LightShadowsSerializer: No serializer with  ${obj.constructor.name}.`);
	    return null;
	  }

	  return new serializer().toJSON(obj);
	};

	LightShadowsSerializer.prototype.fromJSON = function (json) {
	  var generator = json.metadata.generator;
	  var serializer = Serializers$4[generator.replace('Serializer', '')];

	  if (serializer === undefined) {
	    console.warn(`LightShadowsSerializer: No deserializer with ${generator}.`);
	    return null;
	  }

	  return new serializer().fromJSON(json);
	};

	/**
	 * LightSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function LightSerializer() {
	  BaseSerializer.call(this);
	}

	LightSerializer.prototype = Object.create(BaseSerializer.prototype);
	LightSerializer.prototype.constructor = LightSerializer;

	LightSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  json.color = obj.color;
	  json.intensity = obj.intensity;
	  json.isLight = obj.isLight;
	  json.shadow = obj.shadow == null ? null : new LightShadowsSerializer().toJSON(obj.shadow);
	  return json;
	};

	LightSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.Light() : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.color = new THREE.Color(json.color);
	  obj.intensity = json.intensity;
	  obj.isLight = json.isLight;

	  if (json.shadow) {
	    obj.shadow = new LightShadowsSerializer().fromJSON(json.shadow);
	  }

	  return obj;
	};

	/**
	 * AmbientLightSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function AmbientLightSerializer() {
	  BaseSerializer.call(this);
	}

	AmbientLightSerializer.prototype = Object.create(BaseSerializer.prototype);
	AmbientLightSerializer.prototype.constructor = AmbientLightSerializer;

	AmbientLightSerializer.prototype.toJSON = function (obj) {
	  var json = LightSerializer.prototype.toJSON.call(this, obj);
	  json.isAmbientLight = obj.isAmbientLight;
	  return json;
	};

	AmbientLightSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.AmbientLight(json.color, json.intensity) : parent;
	  LightSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.isAmbientLight = json.isAmbientLight;
	  return obj;
	};

	/**
	 * DirectionalLightSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function DirectionalLightSerializer() {
	  BaseSerializer.call(this);
	}

	DirectionalLightSerializer.prototype = Object.create(BaseSerializer.prototype);
	DirectionalLightSerializer.prototype.constructor = DirectionalLightSerializer;

	DirectionalLightSerializer.prototype.toJSON = function (obj) {
	  var json = LightSerializer.prototype.toJSON.call(this, obj);
	  json.isDirectionalLight = obj.isDirectionalLight;
	  return json;
	};

	DirectionalLightSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.DirectionalLight(json.color, json.intensity) : parent;
	  LightSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.isDirectionalLight = json.isDirectionalLight;
	  return obj;
	};

	/**
	 * HemisphereLightSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function HemisphereLightSerializer() {
	  BaseSerializer.call(this);
	}

	HemisphereLightSerializer.prototype = Object.create(BaseSerializer.prototype);
	HemisphereLightSerializer.prototype.constructor = HemisphereLightSerializer;

	HemisphereLightSerializer.prototype.toJSON = function (obj) {
	  var json = LightSerializer.prototype.toJSON.call(this, obj);
	  json.isHemisphereLight = obj.isHemisphereLight;
	  json.skyColor = obj.skyColor;
	  json.groundColor = obj.groundColor;
	  return json;
	};

	HemisphereLightSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.HemisphereLight(json.skyColor, json.groundColor, json.intensity) : parent;
	  LightSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.isHemisphereLight = json.isHemisphereLight;
	  return obj;
	};

	/**
	 * PointLightSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function PointLightSerializer() {
	  BaseSerializer.call(this);
	}

	PointLightSerializer.prototype = Object.create(BaseSerializer.prototype);
	PointLightSerializer.prototype.constructor = PointLightSerializer;

	PointLightSerializer.prototype.toJSON = function (obj) {
	  var json = LightSerializer.prototype.toJSON.call(this, obj);
	  json.isPointLight = obj.isPointLight;
	  json.distance = obj.distance;
	  json.decay = obj.decay;
	  return json;
	};

	PointLightSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.PointLight(json.color, json.intensity, json.distance, json.decay) : parent;
	  LightSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.isPointLight = json.isPointLight;
	  return obj;
	};

	/**
	 * SpotLightSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SpotLightSerializer() {
	  BaseSerializer.call(this);
	}

	SpotLightSerializer.prototype = Object.create(BaseSerializer.prototype);
	SpotLightSerializer.prototype.constructor = SpotLightSerializer;

	SpotLightSerializer.prototype.toJSON = function (obj) {
	  var json = LightSerializer.prototype.toJSON.call(this, obj);
	  json.isSpotLight = obj.isSpotLight;
	  json.distance = obj.distance;
	  json.angle = obj.angle;
	  json.penumbra = obj.penumbra;
	  json.decay = obj.decay;
	  return json;
	};

	SpotLightSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.SpotLight(json.color, json.intensity, json.distance, json.angle, json.penumbra, json.decay) : parent;
	  LightSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.isSpotLight = json.isSpotLight;
	  obj.distance = json.distance;
	  obj.angle = json.angle;
	  obj.penumbra = json.penumbra;
	  obj.decay = json.decay;
	  return obj;
	};

	/**
	 * RectAreaLightSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function RectAreaLightSerializer() {
	  BaseSerializer.call(this);
	}

	RectAreaLightSerializer.prototype = Object.create(BaseSerializer.prototype);
	RectAreaLightSerializer.prototype.constructor = RectAreaLightSerializer;

	RectAreaLightSerializer.prototype.toJSON = function (obj) {
	  var json = LightSerializer.prototype.toJSON.call(this, obj);
	  json.width = obj.width;
	  json.height = obj.height;
	  return json;
	};

	RectAreaLightSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.RectAreaLight(json.color, json.intensity, json.width, json.height) : parent;
	  LightSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.isRectAreaLight = true;
	  return obj;
	};

	/**
	 * AudioSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function AudioSerializer() {
	  BaseSerializer.call(this);
	}

	AudioSerializer.prototype = Object.create(BaseSerializer.prototype);
	AudioSerializer.prototype.constructor = AudioSerializer;

	AudioSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  json.autoplay = obj.autoplay;
	  json.loop = obj.getLoop();
	  json.volume = obj.getVolume();
	  return json;
	};

	AudioSerializer.prototype.fromJSON = function (json, parent, audioListener) {
	  if (audioListener === undefined) {
	    audioListener = new THREE.AudioListener();
	  }

	  var obj = parent === undefined ? new THREE.Audio(audioListener) : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.autoplay = json.autoplay;
	  obj.setLoop(json.loop);
	  obj.setVolume(json.volume);
	  return obj;
	};

	/**
	 * AudioListenerSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function AudioListenerSerializer() {
	  BaseSerializer.call(this);
	}

	AudioListenerSerializer.prototype = Object.create(BaseSerializer.prototype);
	AudioListenerSerializer.prototype.constructor = AudioListenerSerializer;

	AudioListenerSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  json.masterVolume = obj.getMasterVolume();
	  return json;
	};

	AudioListenerSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.AudioListener() : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.setMasterVolume(json.masterVolume);
	  return obj;
	};

	/**
	 * ReflectorSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ReflectorSerializer() {
	  BaseSerializer.call(this);
	}

	ReflectorSerializer.prototype = Object.create(BaseSerializer.prototype);
	ReflectorSerializer.prototype.constructor = ReflectorSerializer;

	ReflectorSerializer.prototype.toJSON = function (obj) {
	  var json = MeshSerializer.prototype.toJSON.call(this, obj);

	  if (json.userData.mesh) {
	    json.userData.mesh = new MeshSerializer().toJSON(json.userData.mesh);
	  }

	  return json;
	};

	ReflectorSerializer.prototype.fromJSON = function (json) {
	  var geometry = new GeometriesSerializer().fromJSON(json.geometry);
	  var obj = new THREE.Reflector(geometry, {
	    color: json.userData.color,
	    textureWidth: parseInt(json.userData.size),
	    textureHeight: parseInt(json.userData.size),
	    clipBias: json.userData.clipBias,
	    recursion: json.userData.recursion ? 1 : 0
	  });
	  MeshSerializer.prototype.fromJSON.call(this, json, obj);

	  if (obj.userData.mesh) {
	    obj.userData.mesh = new MeshSerializer().fromJSON(obj.userData.mesh);
	  }

	  return obj;
	};

	/**
	 * 火焰
	 */
	function Fire(camera, options = {}) {
	  THREE.Object3D.call(this);
	  VolumetricFire.texturePath = 'assets/textures/VolumetricFire/';
	  var width = options.width || 2;
	  var height = options.height || 4;
	  var depth = options.depth || 2;
	  var sliceSpacing = options.sliceSpacing || 0.5;
	  var fire = new VolumetricFire(width, height, depth, sliceSpacing, camera);
	  this.add(fire.mesh);
	  fire.mesh.name = _t('Fire');
	  this.name = _t('Fire');
	  this.position.y = 2;
	  Object.assign(this.userData, {
	    type: 'Fire',
	    fire: fire,
	    width: width,
	    height: height,
	    depth: depth,
	    sliceSpacing: sliceSpacing
	  });
	}

	Fire.prototype = Object.create(THREE.Object3D.prototype);
	Fire.prototype.constructor = Fire;

	/**
	 * FireSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function FireSerializer() {
	  BaseSerializer.call(this);
	}

	FireSerializer.prototype = Object.create(BaseSerializer.prototype);
	FireSerializer.prototype.constructor = FireSerializer;

	FireSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  delete json.userData.fire;
	  return json;
	};

	FireSerializer.prototype.fromJSON = function (json, parent, camera) {
	  var fire = new Fire(camera, {
	    width: json.userData.width,
	    height: json.userData.height,
	    depth: json.userData.depth,
	    sliceSpacing: json.userData.sliceSpacing
	  });
	  Object3DSerializer.prototype.fromJSON.call(this, json, fire);
	  fire.userData.fire.update(0);
	  return fire;
	};

	var vertexShader = "attribute float shift;\r\nuniform float time;\r\nuniform float size;\r\nuniform float lifetime;\r\nuniform float projection;\r\nvarying float progress;\r\n\r\nfloat cubicOut( float t ) {\r\n\r\n  float f = t - 1.0;\r\n  return f * f * f + 1.0;\r\n\r\n}\r\n\r\nvoid main () {\r\n\r\n  progress = fract( time * 2. / lifetime + shift );\r\n  float eased = cubicOut( progress );\r\n  vec3 pos = vec3( position.x * eased, position.y * eased, position.z );\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1. );\r\n  gl_PointSize = ( projection * size ) / gl_Position.w;\r\n\r\n}";

	var fragmentShader = "uniform sampler2D texture;\r\nvarying float progress;\r\n\r\nvoid main() {\r\n\r\n  vec3 color = vec3( 1. );\r\n  gl_FragColor = texture2D( texture, gl_PointCoord ) * vec4( color, .3 * ( 1. - progress ) );\r\n\r\n}";

	/**
	 * 烟
	 * @author yomotsu / http://yomotsu.net
	 * ported from http://webgl-fire.appspot.com/html/fire.html
	 *
	 * https://www.youtube.com/watch?v=jKRHmQmduDI
	 * https://graphics.ethz.ch/teaching/former/imagesynthesis_06/miniprojects/p3/
	 * https://www.iusb.edu/math-compsci/_prior-thesis/YVanzine_thesis.pdf
	 * @param {*} camera 相机
	 * @param {*} renderer 渲染器
	 * @param {*} options 选项
	 */

	function Smoke(camera, renderer, options = {}) {
	  var particleCount = options.particleCount || 32;
	  var size = options.size || 3;
	  var lifetime = options.lifetime || 10; // 几何体

	  var geometry = new THREE.BufferGeometry();
	  var position = new Float32Array(particleCount * 3);
	  var shift = new Float32Array(particleCount);

	  for (var i = 0; i < particleCount; i++) {
	    position[i * 3 + 0] = THREE.Math.randFloat(-0.5, 0.5);
	    position[i * 3 + 1] = 2.4;
	    position[i * 3 + 3] = THREE.Math.randFloat(-0.5, 0.5);
	    shift[i] = Math.random() * 1;
	  }

	  geometry.addAttribute('position', new THREE.BufferAttribute(position, 3));
	  geometry.addAttribute('shift', new THREE.BufferAttribute(shift, 1)); // 材质

	  var texture = new THREE.TextureLoader().load('assets/textures/VolumetricFire/smoke.png');
	  var uniforms = {
	    time: {
	      type: 'f',
	      value: 0
	    },
	    size: {
	      type: 'f',
	      value: size
	    },
	    texture: {
	      type: 't',
	      value: texture
	    },
	    lifetime: {
	      type: 'f',
	      value: lifetime
	    },
	    projection: {
	      type: 'f',
	      value: Math.abs(renderer.domElement.height / (2 * Math.tan(THREE.Math.degToRad(camera.fov))))
	    }
	  };
	  var material = new THREE.ShaderMaterial({
	    vertexShader: vertexShader,
	    fragmentShader: fragmentShader,
	    uniforms: uniforms,
	    blending: THREE.AdditiveBlending,
	    transparent: true,
	    depthWrite: false
	  });
	  THREE.Points.call(this, geometry, material);
	  this.sortParticles = true;
	  this.name = _t('Smoke');
	  Object.assign(this.userData, {
	    type: 'Smoke',
	    particleCount: particleCount,
	    size: size,
	    lifetime: lifetime
	  });
	}

	Smoke.prototype = Object.create(THREE.Points.prototype);
	Smoke.prototype.constructor = Smoke;

	Smoke.prototype.update = function (elapsed) {
	  this.material.uniforms.time.value = elapsed;
	};

	/**
	 * SmokeSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SmokeSerializer() {
	  BaseSerializer.call(this);
	}

	SmokeSerializer.prototype = Object.create(BaseSerializer.prototype);
	SmokeSerializer.prototype.constructor = SmokeSerializer;

	SmokeSerializer.prototype.toJSON = function (obj) {
	  var json = MeshSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	SmokeSerializer.prototype.fromJSON = function (json, parent, camera, renderer) {
	  var obj = parent || new Smoke(camera, renderer, json.userData);
	  MeshSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.update(0);
	  return obj;
	};

	/**
	 * 天空
	 * @param {*} options 选项
	 */
	function Sky(options = {}) {
	  THREE.Object3D.call(this);
	  var turbidity = options.turbidity || 10; // 浑浊度

	  var rayleigh = options.rayleigh || 2; // 瑞利

	  var luminance = options.luminance || 1; // 亮度

	  var mieCoefficient = options.mieCoefficient || 0.005;
	  var mieDirectionalG = options.mieDirectionalG || 0.8;
	  var distance = 400000;
	  var sky = new THREE.Sky();
	  sky.scale.setScalar(450000);
	  this.add(sky);
	  var sunSphere = new THREE.Mesh(new THREE.SphereBufferGeometry(20000, 16, 8), new THREE.MeshBasicMaterial({
	    color: 0xffffff
	  }));
	  sunSphere.position.y = -700000;
	  sunSphere.visible = false;
	  this.add(sunSphere);
	  var uniforms = sky.material.uniforms;
	  uniforms.turbidity.value = turbidity;
	  uniforms.rayleigh.value = rayleigh;
	  uniforms.luminance.value = luminance;
	  uniforms.mieCoefficient.value = mieCoefficient;
	  uniforms.mieDirectionalG.value = mieDirectionalG;
	  var theta = Math.PI * (0.49 - 0.5);
	  var phi = 2 * Math.PI * (0.25 - 0.5);
	  sunSphere.position.x = distance * Math.cos(phi);
	  sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta);
	  sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta);
	  sunSphere.visible = true;
	  uniforms.sunPosition.value.copy(sunSphere.position);
	  this.userData = {
	    type: 'Sky',
	    turbidity: turbidity,
	    rayleigh: rayleigh,
	    luminance: luminance,
	    mieCoefficient: mieCoefficient,
	    mieDirectionalG: mieDirectionalG
	  };
	}

	Sky.prototype = Object.create(THREE.Object3D.prototype);
	Sky.prototype.constructor = Sky;

	/**
	 * SkySerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function SkySerializer() {
	  BaseSerializer.call(this);
	}

	SkySerializer.prototype = Object.create(BaseSerializer.prototype);
	SkySerializer.prototype.constructor = SkySerializer;

	SkySerializer.prototype.toJSON = function (obj) {
	  return Object3DSerializer.prototype.toJSON.call(this, obj);
	};

	SkySerializer.prototype.fromJSON = function (json, parent, camera) {
	  var obj = new Sky(json);
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * 粒子发射器
	 */
	function ParticleEmitter(group, emitter) {
	  THREE.Object3D.call(this);
	  group = group || new SPE.Group({
	    texture: {
	      value: new THREE.TextureLoader().load('assets/textures/SPE/smokeparticle.png')
	    },
	    maxParticleCount: 2000
	  });
	  emitter = emitter || new SPE.Emitter({
	    maxAge: {
	      value: 2
	    },
	    position: {
	      value: new THREE.Vector3(0, 0, 0),
	      spread: new THREE.Vector3(0, 0, 0)
	    },
	    acceleration: {
	      value: new THREE.Vector3(0, -10, 0),
	      spread: new THREE.Vector3(10, 0, 10)
	    },
	    velocity: {
	      value: new THREE.Vector3(0, 25, 0),
	      spread: new THREE.Vector3(10, 7.5, 10)
	    },
	    color: {
	      value: [new THREE.Color('white'), new THREE.Color('red')]
	    },
	    size: {
	      value: 1
	    },
	    particleCount: 2000
	  });
	  group.addEmitter(emitter);
	  group.mesh.name = _t('Particle');
	  this.add(group.mesh);
	  this.name = _t('ParticleEmitter');
	  Object.assign(this.userData, {
	    type: 'ParticleEmitter',
	    group: group,
	    emitter: emitter
	  });
	}

	ParticleEmitter.prototype = Object.create(THREE.Object3D.prototype);
	ParticleEmitter.prototype.constructor = ParticleEmitter;

	/**
	 * ParticleEmitterSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ParticleEmitterSerializer() {
	  BaseSerializer.call(this);
	}

	ParticleEmitterSerializer.prototype = Object.create(BaseSerializer.prototype);
	ParticleEmitterSerializer.prototype.constructor = ParticleEmitterSerializer;

	ParticleEmitterSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  json.children.length = 0;
	  var group = json.userData.group;
	  var emitter = json.userData.emitter;
	  json.userData.group = {
	    texture: new TexturesSerializer().toJSON(group.texture),
	    maxParticleCount: group.maxParticleCount
	  };
	  json.userData.emitter = {
	    position: {
	      value: {
	        x: emitter.position.value.x,
	        y: emitter.position.value.y,
	        z: emitter.position.value.z
	      },
	      spread: {
	        x: emitter.position.spread.x,
	        y: emitter.position.spread.y,
	        z: emitter.position.spread.z
	      }
	    },
	    velocity: {
	      value: {
	        x: emitter.velocity.value.x,
	        y: emitter.velocity.value.y,
	        z: emitter.velocity.value.z
	      },
	      spread: {
	        x: emitter.velocity.spread.x,
	        y: emitter.velocity.spread.y,
	        z: emitter.velocity.spread.z
	      }
	    },
	    acceleration: {
	      value: {
	        x: emitter.acceleration.value.x,
	        y: emitter.acceleration.value.y,
	        z: emitter.acceleration.value.z
	      },
	      spread: {
	        x: emitter.acceleration.spread.x,
	        y: emitter.acceleration.spread.y,
	        z: emitter.acceleration.spread.z
	      }
	    },
	    color: {
	      value: [emitter.color.value[0].getHex(), emitter.color.value[1].getHex(), emitter.color.value[2].getHex(), emitter.color.value[3].getHex()]
	    },
	    size: {
	      value: emitter.size.value,
	      spread: emitter.size.spread
	    },
	    particleCount: emitter.particleCount,
	    maxAge: {
	      value: emitter.maxAge.value,
	      spread: emitter.maxAge.spread
	    }
	  };
	  return json;
	};

	ParticleEmitterSerializer.prototype.fromJSON = function (json, parent, server) {
	  var groupJson = json.userData.group;
	  var emitterJson = json.userData.emitter;
	  var group = new SPE.Group({
	    texture: {
	      value: new TexturesSerializer().fromJSON(groupJson.texture, undefined, server)
	    },
	    maxParticleCount: groupJson.maxParticleCount
	  });
	  var emitter = new SPE.Emitter({
	    maxAge: {
	      value: emitterJson.maxAge.value
	    },
	    position: {
	      value: new THREE.Vector3().copy(emitterJson.position.value),
	      spread: new THREE.Vector3().copy(emitterJson.position.spread)
	    },
	    acceleration: {
	      value: new THREE.Vector3().copy(emitterJson.acceleration.value),
	      spread: new THREE.Vector3().copy(emitterJson.acceleration.spread)
	    },
	    velocity: {
	      value: new THREE.Vector3().copy(emitterJson.velocity.value),
	      spread: new THREE.Vector3().copy(emitterJson.velocity.spread)
	    },
	    color: {
	      value: [new THREE.Color(emitterJson.color.value[0]), new THREE.Color(emitterJson.color.value[1]), new THREE.Color(emitterJson.color.value[2]), new THREE.Color(emitterJson.color.value[3])]
	    },
	    size: {
	      value: emitterJson.size.value.slice(),
	      spread: emitterJson.size.spread.slice()
	    },
	    particleCount: emitterJson.particleCount
	  });
	  var obj = new ParticleEmitter(group, emitter);
	  delete json.userData.group;
	  delete json.userData.emitter;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.userData.group.tick(0);
	  return obj;
	};

	/**
	 * 柏林地形
	 * @param {*} width 地形宽度
	 * @param {*} depth 地形深度
	 * @param {*} widthSegments 宽度分段
	 * @param {*} depthSegments 深度分段
	 * @param {*} quality 地形质量
	 */
	function PerlinTerrain(width = 1000, depth = 1000, widthSegments = 256, depthSegments = 256, quality = 80) {
	  // 创建地形几何体
	  var geometry = new THREE.PlaneBufferGeometry(width, depth, widthSegments - 1, depthSegments - 1);
	  geometry.rotateX(-Math.PI / 2);
	  var vertices = geometry.attributes.position.array;
	  var data = this.generateHeight(widthSegments, depthSegments, quality);

	  for (var i = 0, l = vertices.length; i < l; i++) {
	    vertices[i * 3 + 1] = data[i]; // 给顶点数组y分量赋值（地面高度）
	  }

	  geometry.computeFaceNormals(); // 创建光照贴图

	  var texture = new THREE.CanvasTexture(this.generateTexture(data, widthSegments, depthSegments));
	  texture.wrapS = THREE.ClampToEdgeWrapping;
	  texture.wrapT = THREE.ClampToEdgeWrapping; // 创建网格

	  THREE.Mesh.call(this, geometry, new THREE.MeshLambertMaterial({
	    map: texture
	  }));
	  this.name = _t('Terrain');
	  this.position.y = -50;
	  Object.assign(this.userData, {
	    type: 'PerlinTerrain',
	    width: width,
	    depth: depth,
	    widthSegments: widthSegments,
	    depthSegments: depthSegments,
	    quality: quality
	  });
	}

	PerlinTerrain.prototype = Object.create(THREE.Mesh.prototype);
	PerlinTerrain.prototype.constructor = PerlinTerrain;
	/**
	 * 生成高程数据
	 * @param {*} width 宽度
	 * @param {*} height 高度
	 * @param {*} quality 质量
	 */

	PerlinTerrain.prototype.generateHeight = function (width, height, quality) {
	  var data = new Uint8Array(width * height);
	  var perlin = new THREE.ImprovedNoise();

	  for (var i = 0; i < width; i++) {
	    for (var j = 0; j < height; j++) {
	      data[i * height + j] = Math.abs(perlin.noise(i / quality, j / quality, 0) * quality);
	    }
	  }

	  return data;
	};
	/**
	 * 将光照烘培到贴图上
	 * @param {*} data 高程数据
	 * @param {*} width 宽度
	 * @param {*} height 高度
	 */


	PerlinTerrain.prototype.generateTexture = function (data, width, height) {
	  // 创建ImageData
	  var canvas = document.createElement('canvas');
	  canvas.width = width;
	  canvas.height = height;
	  var context = canvas.getContext('2d');
	  context.fillStyle = '#000';
	  context.fillRect(0, 0, width, height);
	  var image = context.getImageData(0, 0, canvas.width, canvas.height);
	  var imageData = image.data; // 计算光照强度

	  var sun = new THREE.Vector3(1, 1, 1);
	  sun.normalize();
	  var vector3 = new THREE.Vector3(0, 0, 0);
	  var shade;

	  for (var i = 0, j = 0, l = imageData.length; i < l; i += 4, j++) {
	    // i-像素RGBA分量索引，j-高程数据索引
	    vector3.x = data[j - 2] - data[j + 2];
	    vector3.y = 2;
	    vector3.z = data[j - width * 2] - data[j + width * 2];
	    vector3.normalize();
	    shade = vector3.dot(sun);
	    imageData[i] = (96 + shade * 128) * (0.5 + data[j] * 0.007);
	    imageData[i + 1] = (32 + shade * 96) * (0.5 + data[j] * 0.007);
	    imageData[i + 2] = shade * 96 * (0.5 + data[j] * 0.007);
	  } // 将光照强度写入canvas


	  context.putImageData(image, 0, 0);
	  return canvas;
	};

	/**
	 * PerlinTerrainSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function PerlinTerrainSerializer() {
	  BaseSerializer.call(this);
	}

	PerlinTerrainSerializer.prototype = Object.create(BaseSerializer.prototype);
	PerlinTerrainSerializer.prototype.constructor = PerlinTerrainSerializer;

	PerlinTerrainSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	PerlinTerrainSerializer.prototype.fromJSON = function (json, parent) {
	  var terrain = new PerlinTerrain(json.userData.width, json.userData.depth, json.userData.widthSegments, json.userData.depthSegments, json.userData.quality);
	  Object3DSerializer.prototype.fromJSON.call(this, json, terrain);
	  return terrain;
	};

	var HeightmapFragmentShader = "#include <common>\r\nuniform vec2 mousePos;\r\nuniform float mouseSize;\r\nuniform float viscosityConstant;\r\n#define deltaTime ( 1.0 / 60.0 )\r\n#define GRAVITY_CONSTANT ( resolution.x * deltaTime * 3.0 )\r\nvoid main()\t{\r\n\tvec2 cellSize = 1.0 / resolution.xy;\r\n\tvec2 uv = gl_FragCoord.xy * cellSize;\r\n\t// heightmapValue.x == height\r\n\t// heightmapValue.y == velocity\r\n\t// heightmapValue.z, heightmapValue.w not used\r\n\tvec4 heightmapValue = texture2D( heightmap, uv );\r\n\t// Get neighbours\r\n\tvec4 north = texture2D( heightmap, uv + vec2( 0.0, cellSize.y ) );\r\n\tvec4 south = texture2D( heightmap, uv + vec2( 0.0, - cellSize.y ) );\r\n\tvec4 east = texture2D( heightmap, uv + vec2( cellSize.x, 0.0 ) );\r\n\tvec4 west = texture2D( heightmap, uv + vec2( - cellSize.x, 0.0 ) );\r\n\tfloat sump = north.x + south.x + east.x + west.x - 4.0 * heightmapValue.x;\r\n\tfloat accel = sump * GRAVITY_CONSTANT;\r\n\t// Dynamics\r\n\theightmapValue.y += accel;\r\n\theightmapValue.x += heightmapValue.y * deltaTime;\r\n\t// Viscosity\r\n\theightmapValue.x += sump * viscosityConstant;\r\n\t// Mouse influence\r\n\tfloat mousePhase = clamp( length( ( uv - vec2( 0.5 ) ) * BOUNDS - vec2( mousePos.x, - mousePos.y ) ) * PI / mouseSize, 0.0, PI );\r\n\theightmapValue.x += cos( mousePhase ) + 1.0;\r\n\tgl_FragColor = heightmapValue;\r\n}";

	var SmoothFragmentShader = "uniform sampler2D texture;\r\n\r\nvoid main()\t{\r\n\tvec2 cellSize = 1.0 / resolution.xy;\r\n\tvec2 uv = gl_FragCoord.xy * cellSize;\r\n\t// Computes the mean of texel and 4 neighbours\r\n\tvec4 textureValue = texture2D( texture, uv );\r\n\ttextureValue += texture2D( texture, uv + vec2( 0.0, cellSize.y ) );\r\n\ttextureValue += texture2D( texture, uv + vec2( 0.0, - cellSize.y ) );\r\n\ttextureValue += texture2D( texture, uv + vec2( cellSize.x, 0.0 ) );\r\n\ttextureValue += texture2D( texture, uv + vec2( - cellSize.x, 0.0 ) );\r\n\ttextureValue /= 5.0;\r\n\tgl_FragColor = textureValue;\r\n}";

	var WaterVertexShader = "uniform sampler2D heightmap;\r\n#define PHONG\r\nvarying vec3 vViewPosition;\r\n#ifndef FLAT_SHADED\r\n\tvarying vec3 vNormal;\r\n#endif\r\n#include <common>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\tvec2 cellSize = vec2( 1.0 / WIDTH, 1.0 / WIDTH );\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\t// # include <beginnormal_vertex>\r\n\t// Compute normal from heightmap\r\n\tvec3 objectNormal = vec3(\r\n\t\t( texture2D( heightmap, uv + vec2( - cellSize.x, 0 ) ).x - texture2D( heightmap, uv + vec2( cellSize.x, 0 ) ).x ) * WIDTH / BOUNDS,\r\n\t\t( texture2D( heightmap, uv + vec2( 0, - cellSize.y ) ).x - texture2D( heightmap, uv + vec2( 0, cellSize.y ) ).x ) * WIDTH / BOUNDS,\r\n\t\t1.0 );\r\n\t//<beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\tvNormal = normalize( transformedNormal );\r\n#endif\r\n\t//# include <begin_vertex>\r\n\tfloat heightValue = texture2D( heightmap, uv ).x;\r\n\tvec3 transformed = vec3( position.x, position.y, heightValue );\r\n\t//<begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\tvViewPosition = - mvPosition.xyz;\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <shadowmap_vertex>\r\n}";

	/**
	 * 水
	 */

	function Water(renderer) {
	  var BOUNDS = 512;
	  var WIDTH = 128;
	  var materialColor = 0x0040C0; // 创建几何体

	  var geometry = new THREE.PlaneBufferGeometry(BOUNDS, BOUNDS, WIDTH - 1, WIDTH - 1); // 创建材质

	  var material = new THREE.ShaderMaterial({
	    uniforms: THREE.UniformsUtils.merge([THREE.ShaderLib['phong'].uniforms, {
	      heightmap: {
	        value: null
	      }
	    }]),
	    vertexShader: WaterVertexShader,
	    fragmentShader: THREE.ShaderChunk['meshphong_frag']
	  });
	  material.lights = true; // 来自MeshPhongMaterial的属性

	  material.color = new THREE.Color(materialColor);
	  material.specular = new THREE.Color(0x111111);
	  material.shininess = 50; // 根据材质的值设置uniforms

	  material.uniforms.diffuse.value = material.color;
	  material.uniforms.specular.value = material.specular;
	  material.uniforms.shininess.value = Math.max(material.shininess, 1e-4);
	  material.uniforms.opacity.value = material.opacity; // 设置Defines

	  material.defines.WIDTH = WIDTH.toFixed(1);
	  material.defines.BOUNDS = BOUNDS.toFixed(1);
	  var waterUniforms = material.uniforms; // 创建网格

	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Water');
	  this.rotation.x = -Math.PI / 2;
	  this.matrixAutoUpdate = false;
	  this.updateMatrix();
	  var gpuCompute = new THREE.GPUComputationRenderer(WIDTH, WIDTH, renderer);
	  var heightmap0 = gpuCompute.createTexture();
	  this.fillTexture(heightmap0, WIDTH);
	  var heightmapVariable = gpuCompute.addVariable('heightmap', HeightmapFragmentShader, heightmap0);
	  gpuCompute.setVariableDependencies(heightmapVariable, [heightmapVariable]);
	  heightmapVariable.material.uniforms.mousePos = {
	    value: new THREE.Vector2(10000, 10000)
	  };
	  heightmapVariable.material.uniforms.mouseSize = {
	    value: 20.0
	  };
	  heightmapVariable.material.uniforms.viscosityConstant = {
	    value: 0
	  };
	  heightmapVariable.material.defines.BOUNDS = BOUNDS.toFixed(1);
	  var error = gpuCompute.init();

	  if (error !== null) {
	    console.error(error);
	  }

	  var smoothShader = gpuCompute.createShaderMaterial(SmoothFragmentShader, {
	    texture: {
	      value: null
	    }
	  });
	  this.heightmapVariable = heightmapVariable;
	  this.gpuCompute = gpuCompute;
	  this.waterUniforms = waterUniforms;
	  Object.assign(this.userData, {
	    type: 'Water'
	  });
	}

	Water.prototype = Object.create(THREE.Mesh.prototype);
	Water.prototype.constructor = Water;

	Water.prototype.fillTexture = function (texture, WIDTH) {
	  var simplex = new THREE.SimplexNoise();
	  var waterMaxHeight = 30;

	  function noise(x, y, z) {
	    var multR = waterMaxHeight;
	    var mult = 0.025;
	    var r = 0;

	    for (var i = 0; i < 15; i++) {
	      r += multR * simplex.noise(x * mult, y * mult);
	      multR *= 0.53 + 0.025 * i;
	      mult *= 1.25;
	    }

	    return r;
	  }

	  var pixels = texture.image.data;
	  var p = 0;

	  for (var j = 0; j < WIDTH; j++) {
	    for (var i = 0; i < WIDTH; i++) {
	      var x = i * 128 / WIDTH;
	      var y = j * 128 / WIDTH;
	      pixels[p + 0] = noise(x, y, 123.4);
	      pixels[p + 1] = 0;
	      pixels[p + 2] = 0;
	      pixels[p + 3] = 1;
	      p += 4;
	    }
	  }
	};

	Water.prototype.update = function () {
	  var heightmapVariable = this.heightmapVariable;
	  var gpuCompute = this.gpuCompute;
	  var waterUniforms = this.waterUniforms;
	  var uniforms = heightmapVariable.material.uniforms;
	  uniforms.mousePos.value.set(10000, 10000);
	  gpuCompute.compute();
	  waterUniforms.heightmap.value = gpuCompute.getCurrentRenderTarget(heightmapVariable).texture;
	};

	/**
	 * WaterSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function WaterSerializer() {
	  BaseSerializer.call(this);
	}

	WaterSerializer.prototype = Object.create(BaseSerializer.prototype);
	WaterSerializer.prototype.constructor = WaterSerializer;

	WaterSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	WaterSerializer.prototype.fromJSON = function (json, parent, renderer) {
	  var obj = new Water(renderer);
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  obj.update();
	  return obj;
	};

	/*
	 * Cloth Simulation using a relaxed constraints solver
	 */
	// Suggested Readings
	// Advanced Character Physics by Thomas Jakobsen Character
	// http://freespace.virgin.net/hugo.elias/models/m_cloth.htm
	// http://en.wikipedia.org/wiki/Cloth_modeling
	// http://cg.alexandra.dk/tag/spring-mass-system/
	// Real-time Cloth Animation http://www.darwin3d.com/gamedev/articles/col0599.pdf
	var DAMPING = 0.03;
	var DRAG = 1 - DAMPING;
	var MASS = 0.1;
	var restDistance = 25;
	var xSegs = 10;
	var ySegs = 10;

	function plane(width, height) {
	  return function (u, v, optionalTarget) {
	    var result = optionalTarget || new THREE.Vector3();
	    var x = (u - 0.5) * width;
	    var y = (v + 0.5) * height;
	    var z = 0;
	    return result.set(x, y, z);
	  };
	}

	var clothFunction = plane(restDistance * xSegs, restDistance * ySegs);
	var GRAVITY = 981 * 1.4;
	var gravity = new THREE.Vector3(0, -GRAVITY, 0).multiplyScalar(MASS);
	var TIMESTEP = 18 / 1000;
	var TIMESTEP_SQ = TIMESTEP * TIMESTEP;
	var windForce = new THREE.Vector3(0, 0, 0);
	var tmpForce = new THREE.Vector3();
	var lastTime;

	function Particle(x, y, z, mass) {
	  this.position = clothFunction(x, y); // position

	  this.previous = clothFunction(x, y); // previous

	  this.original = clothFunction(x, y);
	  this.a = new THREE.Vector3(0, 0, 0); // acceleration

	  this.mass = mass;
	  this.invMass = 1 / mass;
	  this.tmp = new THREE.Vector3();
	  this.tmp2 = new THREE.Vector3();
	} // Force -> Acceleration


	Particle.prototype.addForce = function (force) {
	  this.a.add(this.tmp2.copy(force).multiplyScalar(this.invMass));
	}; // Performs Verlet integration


	Particle.prototype.integrate = function (timesq) {
	  var newPos = this.tmp.subVectors(this.position, this.previous);
	  newPos.multiplyScalar(DRAG).add(this.position);
	  newPos.add(this.a.multiplyScalar(timesq));
	  this.tmp = this.previous;
	  this.previous = this.position;
	  this.position = newPos;
	  this.a.set(0, 0, 0);
	};

	var diff = new THREE.Vector3();

	function satisfyConstraints(p1, p2, distance) {
	  diff.subVectors(p2.position, p1.position);
	  var currentDist = diff.length();
	  if (currentDist === 0) return; // prevents division by 0

	  var correction = diff.multiplyScalar(1 - distance / currentDist);
	  var correctionHalf = correction.multiplyScalar(0.5);
	  p1.position.add(correctionHalf);
	  p2.position.sub(correctionHalf);
	}
	/**
	 * 布料
	 */


	function Cloth() {
	  var pins = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
	  var w = xSegs;
	  var h = ySegs;
	  this.w = w;
	  this.h = h;
	  var particles = [];
	  var constraints = [];
	  var u, v; // Create particles

	  for (v = 0; v <= h; v++) {
	    for (u = 0; u <= w; u++) {
	      particles.push(new Particle(u / w, v / h, 0, MASS));
	    }
	  } // Structural


	  for (v = 0; v < h; v++) {
	    for (u = 0; u < w; u++) {
	      constraints.push([particles[index(u, v)], particles[index(u, v + 1)], restDistance]);
	      constraints.push([particles[index(u, v)], particles[index(u + 1, v)], restDistance]);
	    }
	  }

	  for (u = w, v = 0; v < h; v++) {
	    constraints.push([particles[index(u, v)], particles[index(u, v + 1)], restDistance]);
	  }

	  for (v = h, u = 0; u < w; u++) {
	    constraints.push([particles[index(u, v)], particles[index(u + 1, v)], restDistance]);
	  }

	  this.particles = particles;
	  this.constraints = constraints;

	  function index(u, v) {
	    return u + v * (w + 1);
	  }

	  this.index = index; // 材质

	  var loader = new THREE.TextureLoader();
	  var clothTexture = loader.load('assets/textures/patterns/circuit_pattern.png');
	  clothTexture.anisotropy = 16;
	  var clothGeometry = new THREE.ParametricGeometry(clothFunction, w, h);
	  var clothMaterial = new THREE.MeshLambertMaterial({
	    map: clothTexture,
	    side: THREE.DoubleSide,
	    alphaTest: 0.5
	  });
	  THREE.Mesh.call(this, clothGeometry, clothMaterial);
	  this.scale.multiplyScalar(0.02);
	  this.castShadow = true;
	  Object.assign(this.userData, {
	    type: 'Cloth'
	  });
	  this.pins = pins;
	  this.clothGeometry = clothGeometry;
	}

	Cloth.prototype = Object.create(THREE.Mesh.prototype);
	Cloth.prototype.constructor = Cloth;

	Cloth.prototype.update = function (clock, deltaTime) {
	  var time = Date.now();
	  var windStrength = Math.cos(time / 7000) * 20 + 40;
	  windForce.set(Math.sin(time / 2000), Math.cos(time / 3000), Math.sin(time / 1000));
	  windForce.normalize();
	  windForce.multiplyScalar(windStrength);
	  this.simulate(time, this.clothGeometry, this.pins);
	  var p = this.particles;
	  var clothGeometry = this.clothGeometry;

	  for (var i = 0, il = p.length; i < il; i++) {
	    clothGeometry.vertices[i].copy(p[i].position);
	  }

	  clothGeometry.verticesNeedUpdate = true;
	  clothGeometry.computeFaceNormals();
	  clothGeometry.computeVertexNormals();
	};

	Cloth.prototype.simulate = function (time) {
	  if (!lastTime) {
	    lastTime = time;
	    return;
	  }

	  var i, il, particles, particle, constraints, constraint; // Aerodynamics forces

	  {
	    var face,
	        faces = this.clothGeometry.faces,
	        normal;
	    particles = this.particles;

	    for (i = 0, il = faces.length; i < il; i++) {
	      face = faces[i];
	      normal = face.normal;
	      tmpForce.copy(normal).normalize().multiplyScalar(normal.dot(windForce));
	      particles[face.a].addForce(tmpForce);
	      particles[face.b].addForce(tmpForce);
	      particles[face.c].addForce(tmpForce);
	    }
	  }

	  for (particles = this.particles, i = 0, il = particles.length; i < il; i++) {
	    particle = particles[i];
	    particle.addForce(gravity);
	    particle.integrate(TIMESTEP_SQ);
	  } // Start Constraints


	  constraints = this.constraints;
	  il = constraints.length;

	  for (i = 0; i < il; i++) {
	    constraint = constraints[i];
	    satisfyConstraints(constraint[0], constraint[1], constraint[2]);
	  } // Floor Constraints


	  for (particles = this.particles, i = 0, il = particles.length; i < il; i++) {
	    particle = particles[i];
	    var pos = particle.position;

	    if (pos.y < -250) {
	      pos.y = -250;
	    }
	  } // Pin Constraints


	  var pins = this.pins;

	  for (i = 0, il = pins.length; i < il; i++) {
	    var xy = pins[i];
	    var p = particles[xy];
	    p.position.copy(p.original);
	    p.previous.copy(p.original);
	  }
	};

	/**
	 * ClothSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function ClothSerializer() {
	  BaseSerializer.call(this);
	}

	ClothSerializer.prototype = Object.create(BaseSerializer.prototype);
	ClothSerializer.prototype.constructor = ClothSerializer;

	ClothSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	ClothSerializer.prototype.fromJSON = function (json, parent, camera) {
	  var cloth = new Cloth();
	  Object3DSerializer.prototype.fromJSON.call(this, json, cloth);
	  return cloth;
	};

	var ARC_SEGMENTS = 200;
	/**
	 * 线段
	 * @param {*} options 
	 */

	function LineCurve(options = {}) {
	  var geometry = new THREE.BufferGeometry();
	  geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(ARC_SEGMENTS * 3), 3));
	  var material = new THREE.LineBasicMaterial({
	    color: 0xff0000,
	    opacity: 0.35
	  });
	  THREE.Line.call(this, geometry, material);
	  this.name = _t('Line Curve');
	  this.castShadow = true;
	  Object.assign(this.userData, {
	    type: 'LineCurve',
	    points: options.points || [new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 10, 10)]
	  });
	  this.update();
	}

	LineCurve.prototype = Object.create(THREE.Line.prototype);
	LineCurve.prototype.constructor = LineCurve;

	LineCurve.prototype.update = function () {
	  var curve = new THREE.LineCurve3(this.userData.points[0], this.userData.points[1]);
	  var position = this.geometry.attributes.position;
	  var point = new THREE.Vector3();

	  for (var i = 0; i < ARC_SEGMENTS; i++) {
	    var t = i / (ARC_SEGMENTS - 1);
	    curve.getPoint(t, point);
	    position.setXYZ(i, point.x, point.y, point.z);
	  }

	  position.needsUpdate = true;
	};

	/**
	 * LineCurveSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function LineCurveSerializer() {
	  BaseSerializer.call(this);
	}

	LineCurveSerializer.prototype = Object.create(BaseSerializer.prototype);
	LineCurveSerializer.prototype.constructor = LineCurveSerializer;

	LineCurveSerializer.prototype.toJSON = function (obj) {
	  var json = MeshSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	LineCurveSerializer.prototype.fromJSON = function (json, parent) {
	  json.userData.points = json.userData.points.map(n => {
	    return new THREE.Vector3().copy(n);
	  });
	  var obj = parent || new LineCurve(json.userData);
	  MeshSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	var ARC_SEGMENTS$1 = 200;
	/**
	 * CatmullRom曲线
	 * @param {*} options 
	 */

	function CatmullRomCurve(options = {}) {
	  var geometry = new THREE.BufferGeometry();
	  geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(ARC_SEGMENTS$1 * 3), 3));
	  var material = new THREE.LineBasicMaterial({
	    color: 0xff0000,
	    opacity: 0.35
	  });
	  THREE.Line.call(this, geometry, material);
	  this.name = _t('CatmullRom Curve');
	  this.castShadow = true;
	  Object.assign(this.userData, {
	    type: 'CatmullRomCurve',
	    points: options.points || [new THREE.Vector3(4, 8, 16), new THREE.Vector3(0, 12, -4), new THREE.Vector3(-16, 4, -8)],
	    closed: options.closed || false,
	    curveType: options.curveType || 'catmullrom',
	    // centripetal, chordal and catmullrom
	    tension: options.tension || 0.5
	  });
	  this.update();
	}

	CatmullRomCurve.prototype = Object.create(THREE.Line.prototype);
	CatmullRomCurve.prototype.constructor = CatmullRomCurve;

	CatmullRomCurve.prototype.update = function () {
	  var curve = new THREE.CatmullRomCurve3(this.userData.points, this.userData.closed, this.userData.curveType, this.userData.tension);
	  var position = this.geometry.attributes.position;
	  var point = new THREE.Vector3();

	  for (var i = 0; i < ARC_SEGMENTS$1; i++) {
	    var t = i / (ARC_SEGMENTS$1 - 1);
	    curve.getPoint(t, point);
	    position.setXYZ(i, point.x, point.y, point.z);
	  }

	  position.needsUpdate = true;
	};

	/**
	 * CatmullRomCurveSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CatmullRomCurveSerializer() {
	  BaseSerializer.call(this);
	}

	CatmullRomCurveSerializer.prototype = Object.create(BaseSerializer.prototype);
	CatmullRomCurveSerializer.prototype.constructor = CatmullRomCurveSerializer;

	CatmullRomCurveSerializer.prototype.toJSON = function (obj) {
	  var json = MeshSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	CatmullRomCurveSerializer.prototype.fromJSON = function (json, parent) {
	  json.userData.points = json.userData.points.map(n => {
	    return new THREE.Vector3().copy(n);
	  });
	  var obj = parent || new CatmullRomCurve(json.userData);
	  MeshSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	var ARC_SEGMENTS$2 = 200;
	/**
	 * 二次贝塞尔曲线
	 * @param {*} options 
	 */

	function QuadraticBezierCurve(options = {}) {
	  var geometry = new THREE.BufferGeometry();
	  geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(ARC_SEGMENTS$2 * 3), 3));
	  var material = new THREE.LineBasicMaterial({
	    color: 0xff0000,
	    opacity: 0.35
	  });
	  THREE.Line.call(this, geometry, material);
	  this.name = _t('Quadratic Bezier Curve');
	  this.castShadow = true;
	  Object.assign(this.userData, {
	    type: 'QuadraticBezierCurve',
	    points: options.points || [new THREE.Vector3(-10, 0, 0), new THREE.Vector3(20, 15, 0), new THREE.Vector3(10, 0, 0)]
	  });
	  this.update();
	}

	QuadraticBezierCurve.prototype = Object.create(THREE.Line.prototype);
	QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

	QuadraticBezierCurve.prototype.update = function () {
	  var curve = new THREE.QuadraticBezierCurve3(this.userData.points[0], this.userData.points[1], this.userData.points[2]);
	  var position = this.geometry.attributes.position;
	  var point = new THREE.Vector3();

	  for (var i = 0; i < ARC_SEGMENTS$2; i++) {
	    var t = i / (ARC_SEGMENTS$2 - 1);
	    curve.getPoint(t, point);
	    position.setXYZ(i, point.x, point.y, point.z);
	  }

	  position.needsUpdate = true;
	};

	/**
	 * QuadraticBezierCurveSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function QuadraticBezierCurveSerializer() {
	  BaseSerializer.call(this);
	}

	QuadraticBezierCurveSerializer.prototype = Object.create(BaseSerializer.prototype);
	QuadraticBezierCurveSerializer.prototype.constructor = QuadraticBezierCurveSerializer;

	QuadraticBezierCurveSerializer.prototype.toJSON = function (obj) {
	  var json = MeshSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	QuadraticBezierCurveSerializer.prototype.fromJSON = function (json, parent) {
	  json.userData.points = json.userData.points.map(n => {
	    return new THREE.Vector3().copy(n);
	  });
	  var obj = parent || new QuadraticBezierCurve(json.userData);
	  MeshSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	var ARC_SEGMENTS$3 = 200;
	/**
	 * 三次贝塞尔曲线
	 * @param {*} options 
	 */

	function CubicBezierCurve(options = {}) {
	  var geometry = new THREE.BufferGeometry();
	  geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(ARC_SEGMENTS$3 * 3), 3));
	  var material = new THREE.LineBasicMaterial({
	    color: 0xff0000,
	    opacity: 0.35
	  });
	  THREE.Line.call(this, geometry, material);
	  this.name = _t('CubicBezier Curve');
	  this.castShadow = true;
	  Object.assign(this.userData, {
	    type: 'CubicBezierCurve',
	    points: options.points || [new THREE.Vector3(-10, 0, 0), new THREE.Vector3(-5, 15, 0), new THREE.Vector3(20, 15, 0), new THREE.Vector3(10, 0, 0)]
	  });
	  this.update();
	}

	CubicBezierCurve.prototype = Object.create(THREE.Line.prototype);
	CubicBezierCurve.prototype.constructor = CubicBezierCurve;

	CubicBezierCurve.prototype.update = function () {
	  var curve = new THREE.CubicBezierCurve3(this.userData.points[0], this.userData.points[1], this.userData.points[2], this.userData.points[3]);
	  var position = this.geometry.attributes.position;
	  var point = new THREE.Vector3();

	  for (var i = 0; i < ARC_SEGMENTS$3; i++) {
	    var t = i / (ARC_SEGMENTS$3 - 1);
	    curve.getPoint(t, point);
	    position.setXYZ(i, point.x, point.y, point.z);
	  }

	  position.needsUpdate = true;
	};

	/**
	 * CubicBezierCurveSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function CubicBezierCurveSerializer() {
	  BaseSerializer.call(this);
	}

	CubicBezierCurveSerializer.prototype = Object.create(BaseSerializer.prototype);
	CubicBezierCurveSerializer.prototype.constructor = CubicBezierCurveSerializer;

	CubicBezierCurveSerializer.prototype.toJSON = function (obj) {
	  var json = MeshSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	CubicBezierCurveSerializer.prototype.fromJSON = function (json, parent) {
	  json.userData.points = json.userData.points.map(n => {
	    return new THREE.Vector3().copy(n);
	  });
	  var obj = parent || new CubicBezierCurve(json.userData);
	  MeshSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	var ARC_SEGMENTS$4 = 200;
	/**
	 * 椭圆曲线
	 * @param {*} options 
	 */

	function EllipseCurve(options = {}) {
	  var geometry = new THREE.BufferGeometry();
	  geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(ARC_SEGMENTS$4 * 3), 3));
	  var material = new THREE.LineBasicMaterial({
	    color: 0xff0000,
	    opacity: 0.35
	  });
	  THREE.Line.call(this, geometry, material);
	  this.name = _t('Ellipse Curve');
	  this.castShadow = true;
	  Object.assign(this.userData, {
	    type: 'EllipseCurve',
	    aX: options.aX || 0,
	    aY: options.aY || 0,
	    xRadius: options.xRadius || 10,
	    yRadius: options.yRadius || 5,
	    aStartAngle: options.aStartAngle || 0,
	    aEndAngle: options.aEndAngle || 2 * Math.PI,
	    aClockwise: options.aClockwise || false,
	    aRotation: options.aRotation || 0
	  });
	  this.update();
	}

	EllipseCurve.prototype = Object.create(THREE.Line.prototype);
	EllipseCurve.prototype.constructor = EllipseCurve;

	EllipseCurve.prototype.update = function () {
	  var curve = new THREE.EllipseCurve(this.userData.aX, this.userData.aY, this.userData.xRadius, this.userData.yRadius, this.userData.aStartAngle, this.userData.aEndAngle, this.userData.aClockwise, this.userData.aRotation);
	  var position = this.geometry.attributes.position;
	  var point = new THREE.Vector3();

	  for (var i = 0; i < ARC_SEGMENTS$4; i++) {
	    var t = i / (ARC_SEGMENTS$4 - 1);
	    curve.getPoint(t, point);
	    position.setXYZ(i, point.x, point.y, 0); // 椭圆曲线只能输出二维点
	  }

	  position.needsUpdate = true;
	};

	/**
	 * EllipseCurveSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function EllipseCurveSerializer() {
	  BaseSerializer.call(this);
	}

	EllipseCurveSerializer.prototype = Object.create(BaseSerializer.prototype);
	EllipseCurveSerializer.prototype.constructor = EllipseCurveSerializer;

	EllipseCurveSerializer.prototype.toJSON = function (obj) {
	  var json = MeshSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	EllipseCurveSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent || new EllipseCurve(json.userData);
	  MeshSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * GlobeSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function GlobeSerializer() {
	  BaseSerializer.call(this);
	}

	GlobeSerializer.prototype = Object.create(BaseSerializer.prototype);
	GlobeSerializer.prototype.constructor = GlobeSerializer;

	GlobeSerializer.prototype.toJSON = function (obj) {
	  var json = Object3DSerializer.prototype.toJSON.call(this, obj);
	  return json;
	};

	GlobeSerializer.prototype.fromJSON = function (json, parent) {
	  var obj = parent === undefined ? new THREE.Bone() : parent;
	  Object3DSerializer.prototype.fromJSON.call(this, json, obj);
	  return obj;
	};

	/**
	 * VisualSerializer
	 * @author tengge / https://github.com/tengge1
	 */

	function VisualSerializer() {
	  BaseSerializer.call(this);
	}

	VisualSerializer.prototype = Object.create(BaseSerializer.prototype);
	VisualSerializer.prototype.constructor = VisualSerializer;

	VisualSerializer.prototype.toJSON = function (obj) {
	  var json = BaseSerializer.prototype.toJSON.call(this, obj);
	  json.data = obj.toJSON();
	  return json;
	};

	VisualSerializer.prototype.fromJSON = function (json) {
	  return json.data ? json.data : null;
	};

	/**
	 * 场景序列化/反序列化类
	 * @author tengge / https://github.com/tengge1
	 */

	function Converter() {
	  BaseSerializer.call(this);
	}

	Converter.prototype = Object.create(BaseSerializer.prototype);
	Converter.prototype.constructor = Converter;
	/**
	 * 将应用转为json
	 * @param {Object} obj 需要序列化的对象
	 * @param {Object} obj.options 配置信息
	 * @param {THREE.Camera} obj.camera 相机
	 * @param {THREE.WebGLRenderer} obj.renderer 渲染器 
	 * @param {Array} obj.scripts 脚本列表
	 * @param {Array} obj.animations 动画列表
	 * @param {Object} obj.visual 可视化数据
	 * @param {THREE.Scene} obj.scene 场景
	 * @param {String} obj.server 服务端地址
	 */

	Converter.prototype.toJSON = function (obj) {
	  let options = obj.options;
	  let camera = obj.camera;
	  let renderer = obj.renderer;
	  let scripts = obj.scripts;
	  let animations = obj.animations;
	  let visual = obj.visual;
	  let scene = obj.scene;
	  let list = []; // 选项

	  let configJson = new OptionsSerializer().toJSON(options);
	  list.push(configJson); // 相机

	  let cameraJson = new CamerasSerializer().toJSON(camera);
	  list.push(cameraJson); // 渲染器

	  let rendererJson = new WebGLRendererSerializer().toJSON(renderer);
	  list.push(rendererJson); // 脚本

	  let scriptsJson = new ScriptSerializer().toJSON(scripts);
	  scriptsJson.forEach(n => {
	    list.push(n);
	  }); // 动画

	  let animationsJson = new AnimationSerializer().toJSON(animations);
	  animationsJson.forEach(n => {
	    list.push(n);
	  }); // 音频监听器

	  let audioListener = camera.children.filter(n => n instanceof THREE.AudioListener)[0];

	  if (audioListener) {
	    let audioListenerJson = new AudioListenerSerializer().toJSON(audioListener);
	    list.push(audioListenerJson);
	  } // 可视化


	  if (visual) {
	    let visualJson = new VisualSerializer().toJSON(visual);
	    list.push(visualJson);
	  } // 将场景转为json


	  let children = []; // 将层级结构保存在场景中，以供场景加载时还原。

	  this.traverse(scene, children, list);
	  let sceneJson = list.filter(n => n.uuid === scene.uuid)[0];

	  if (sceneJson) {
	    sceneJson.userData.children = children;
	  } else {
	    console.warn(`Converter: no scene json with id ${scene.uuid}`);
	  }

	  return list;
	};
	/**
	 * 场景转json
	 * @param {THREE.Object3D} obj 三维物体
	 * @param {Object} children 子级结构
	 * @param {Array} list json列表
	 */


	Converter.prototype.traverse = function (obj, children, list) {
	  let json = null;

	  if (obj.userData.Server === true) {
	    // 服务器对象
	    json = new ServerObject().toJSON(obj);
	  } else if (obj.userData.type === 'Sky') {
	    json = new SkySerializer().toJSON(obj);
	  } else if (obj.userData.type === 'Fire') {
	    // 火焰
	    json = new FireSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'Smoke') {
	    // 烟
	    json = new SmokeSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'ParticleEmitter') {
	    // 粒子发射器
	    json = new ParticleEmitterSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'PerlinTerrain') {
	    // 柏林地形
	    json = new PerlinTerrainSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'Water') {
	    json = new WaterSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'Cloth') {
	    json = new ClothSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'LineCurve') {
	    json = new LineCurveSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'CatmullRomCurve') {
	    json = new CatmullRomCurveSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'QuadraticBezierCurve') {
	    json = new QuadraticBezierCurveSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'CubicBezierCurve') {
	    json = new CubicBezierCurveSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'EllipseCurve') {
	    json = new EllipseCurveSerializer().toJSON(obj);
	  } else if (obj.userData.type === 'Globe') {
	    json = new GlobeSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.Scene) {
	    json = new SceneSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.Group) {
	    json = new GroupSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.Reflector) {
	    json = new ReflectorSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.Mesh) {
	    json = new MeshSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.Sprite) {
	    json = new SpriteSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.AmbientLight) {
	    json = new AmbientLightSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.DirectionalLight) {
	    json = new DirectionalLightSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.HemisphereLight) {
	    json = new HemisphereLightSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.PointLight) {
	    json = new PointLightSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.RectAreaLight) {
	    json = new RectAreaLightSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.SpotLight) {
	    json = new SpotLightSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.Audio) {
	    json = new AudioSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.Bone) {
	    json = new BoneSerializer().toJSON(obj);
	  } else if (obj instanceof THREE.Object3D) {
	    json = new Object3DSerializer().toJSON(obj);
	  }

	  if (json) {
	    list.push(json);
	  } else {
	    console.warn(`Converter: No ${obj.constructor.name} Serializer.`);
	  } // 1、如果obj.userData.type不为空，则为内置类型，其子项不应该序列化。
	  // 2、服务器(模型)对象需要记录用户对模型的修改，需要序列化。


	  if (obj.children && obj.userData.type === undefined) {
	    obj.children.forEach(n => {
	      let children1 = [];
	      children.push({
	        uuid: n.uuid,
	        children: children1
	      });
	      this.traverse(n, children1, list);
	    });
	  }
	};
	/**
	 * 场景反序列化
	 * @param {*} jsons json对象（列表）
	 * @param {*} options 配置选项 格式：{ server: serverUrl } 其中，serverUrl为服务端地址，用于下载模型、纹理等资源
	 * @param {*} options.server 服务端地址
	 */


	Converter.prototype.fromJson = function (jsons, options) {
	  let obj = {
	    options: null,
	    camera: null,
	    renderer: null,
	    scripts: null,
	    animations: [],
	    svg: {
	      html: ''
	    },
	    scene: null
	  }; // 选项

	  let optionsJson = jsons.filter(n => n.metadata && n.metadata.generator === 'OptionsSerializer')[0];

	  if (optionsJson) {
	    obj.options = new OptionsSerializer().fromJSON(optionsJson);
	  } else {
	    console.warn(`Converter: No config info in the scene.`);
	  } // 相机


	  let cameraJson = jsons.filter(n => n.metadata && n.metadata.generator.indexOf('CameraSerializer') > -1)[0];

	  if (cameraJson) {
	    obj.camera = new CamerasSerializer().fromJSON(cameraJson);
	  } else {
	    console.warn(`Converter: No camera info in the scene.`);
	  }

	  if (options.camera === undefined) {
	    options.camera = obj.camera;
	  } // 渲染器


	  let rendererJson = jsons.filter(n => n.metadata && n.metadata.generator.indexOf('WebGLRendererSerializer') > -1)[0];

	  if (rendererJson) {
	    obj.renderer = new WebGLRendererSerializer().fromJSON(rendererJson);
	  } else {
	    console.warn(`Converter: No renderer info in the scene.`);
	  }

	  if (options.renderer === undefined) {
	    options.renderer = obj.renderer;
	  } // 脚本


	  let scriptJsons = jsons.filter(n => n.metadata && n.metadata.generator === 'ScriptSerializer');

	  if (scriptJsons) {
	    obj.scripts = new ScriptSerializer().fromJSON(scriptJsons);
	  } // 动画


	  let animationJsons = jsons.filter(n => n.metadata && n.metadata.generator === 'AnimationSerializer');

	  if (animationJsons) {
	    obj.animations = new AnimationSerializer().fromJSON(animationJsons);
	  } // Visual


	  let visualJson = jsons.filter(n => n.metadata && n.metadata.generator === 'VisualSerializer')[0];

	  if (visualJson) {
	    obj.visual = new VisualSerializer().fromJSON(visualJson);
	  } // 音频监听器


	  let audioListenerJson = jsons.filter(n => n.metadata && n.metadata.generator === 'AudioListenerSerializer')[0];
	  let audioListener;

	  if (audioListenerJson) {
	    audioListener = new AudioListenerSerializer().fromJSON(audioListenerJson);
	  } else {
	    console.warn(`Converter: No AudioListener in the scene.`);
	    audioListener = new THREE.AudioListener();
	  }

	  obj.audioListener = audioListener;
	  options.audioListener = audioListener;
	  obj.camera.add(audioListener); // 场景

	  return new Promise(resolve => {
	    this.parse(jsons, options).then(scene => {
	      obj.scene = scene;
	      resolve(obj);
	    });
	  });
	};

	const NoDeserializeSerializers = ['OptionsSerializer', 'CamerasSerializer', 'PerspectiveCameraSerializer', 'OrthographicCameraSerializer', 'WebGLRendererSerializer', 'ScriptSerializer', 'AnimationSerializer', 'VisualSerializer', 'AudioListenerSerializer', 'SceneSerializer', 'GlobeSerializer'];
	/**
	 * json转场景
	 * @param {*} jsons 反序列化对象列表
	 * @param {*} options 配置信息
	 */

	Converter.prototype.parse = function (jsons, options) {
	  // TODO: 由于有的模型上带Scene，这样判断得到的Scene可能不太准确。
	  let sceneJson = jsons.filter(n => n.metadata && n.metadata.generator === 'SceneSerializer')[0];

	  if (sceneJson === undefined) {
	    console.warn(`Converter: No scene info in the scene.`);
	    return new Promise(resolve => {
	      resolve(new THREE.Scene());
	    });
	  }

	  let scene = new SceneSerializer().fromJSON(sceneJson, undefined, options.server);
	  let children = sceneJson.userData.children;

	  if (!children) {
	    console.warn(`Converter: scene has no children. Save your scene to update the date structure.`);
	    return this.parseOld(sceneJson, scene, jsons, options);
	  } // 将每个组件反序列化


	  let parts = [scene];
	  let serverParts = [];
	  let promises = jsons.map(n => {
	    const generator = n.metadata.generator;

	    if (generator === 'ServerObject') {
	      parts.push(new Object3DSerializer().fromJSON(n));
	      return new Promise(resolve => {
	        new ServerObject().fromJSON(n, options, options).then(obj => {
	          this.traverseServerObject(obj, serverParts);
	          resolve();
	        });
	      });
	    } else if (NoDeserializeSerializers.indexOf(generator) > -1) ; else if (generator === 'GroupSerializer') {
	      parts.push(new GroupSerializer().fromJSON(n));
	    } else if (generator === 'ReflectorSerializer') {
	      parts.push(new ReflectorSerializer().fromJSON(n));
	    } else if (generator === 'MeshSerializer') {
	      parts.push(new MeshSerializer().fromJSON(n, undefined, options.server));
	    } else if (generator === 'SpriteSerializer') {
	      parts.push(new SpriteSerializer().fromJSON(n, undefined, options.server));
	    } else if (generator === 'AmbientLightSerializer') {
	      parts.push(new AmbientLightSerializer().fromJSON(n));
	    } else if (generator === 'DirectionalLightSerializer') {
	      parts.push(new DirectionalLightSerializer().fromJSON(n));
	    } else if (generator === 'HemisphereLightSerializer') {
	      parts.push(new HemisphereLightSerializer().fromJSON(n));
	    } else if (generator === 'PointLightSerializer') {
	      parts.push(new PointLightSerializer().fromJSON(n));
	    } else if (generator === 'RectAreaLightSerializer') {
	      parts.push(new RectAreaLightSerializer().fromJSON(n));
	    } else if (generator === 'SpotLightSerializer') {
	      parts.push(new SpotLightSerializer().fromJSON(n));
	    } else if (generator === 'AudioSerializer') {
	      parts.push(new AudioSerializer().fromJSON(n, undefined, options.audioListener));
	    } else if (generator === 'FireSerializer') {
	      parts.push(new FireSerializer().fromJSON(n, undefined, options.camera));
	    } else if (generator === 'SmokeSerializer') {
	      parts.push(new SmokeSerializer().fromJSON(n, undefined, options.camera, options.renderer));
	    } else if (generator === 'BoneSerializer') {
	      parts.push(new BoneSerializer().fromJSON(n));
	    } else if (generator === 'SkySerializer') {
	      parts.push(new SkySerializer().fromJSON(n));
	    } else if (generator === 'ParticleEmitterSerializer') {
	      parts.push(new ParticleEmitterSerializer().fromJSON(n, undefined, options.server));
	    } else if (generator === 'PerlinTerrainSerializer') {
	      parts.push(new PerlinTerrainSerializer().fromJSON(n));
	    } else if (generator === 'WaterSerializer') {
	      parts.push(new WaterSerializer().fromJSON(n, undefined, options.renderer));
	    } else if (generator === 'ClothSerializer') {
	      parts.push(new ClothSerializer().fromJSON(n));
	    } else if (generator === 'LineCurveSerializer') {
	      parts.push(new LineCurveSerializer().fromJSON(n));
	    } else if (generator === 'CatmullRomCurveSerializer') {
	      parts.push(new CatmullRomCurveSerializer().fromJSON(n));
	    } else if (generator === 'QuadraticBezierCurveSerializer') {
	      parts.push(new QuadraticBezierCurveSerializer().fromJSON(n));
	    } else if (generator === 'CubicBezierCurveSerializer') {
	      parts.push(new CubicBezierCurveSerializer().fromJSON(n));
	    } else if (generator === 'EllipseCurveSerializer') {
	      parts.push(new EllipseCurveSerializer().fromJSON(n));
	    } else if (generator === 'Object3DSerializer') {
	      parts.push(new Object3DSerializer().fromJSON(n));
	    } else {
	      console.warn(`Converter: No Deserializer with ${generator}.`);
	    }

	    return new Promise(resolve => {
	      resolve();
	    });
	  }); // 根据children重新还原场景结构

	  return new Promise(resolve => {
	    Promise.all(promises).then(() => {
	      this.parseScene(scene, children, parts, serverParts);
	      resolve(scene);
	    });
	  });
	};
	/**
	 * 新的组装场景方法
	 * @description 由于只序列化了服务端模型的材质，所以优先采用服务端模型组件搭建场景，并用序列化的材质代替服务端材质。
	 */


	Converter.prototype.parseScene = function (parent, children, parts, serverParts) {
	  children.forEach(child => {
	    let obj = serverParts.filter(n => n.uuid === child.uuid)[0];

	    if (obj) {
	      // 服务端组件
	      let obj1 = parts.filter(n => n.uuid === child.uuid)[0];

	      if (obj1) {
	        // 还原修改过的名称、位置、旋转、缩放等信息。
	        obj.name = obj1.name;
	        obj.position.copy(obj1.position);
	        obj.rotation.copy(obj1.rotation);
	        obj.scale.copy(obj1.scale);

	        if (obj.material && obj1.material) {
	          // blob:http://
	          if (obj.material.map && obj.material.map.image && obj.material.map.image.src && obj.material.map.image.src.toString().startsWith('blob:http://')) ; else {
	            obj.material = obj1.material;
	          }
	        }
	      } else {
	        console.warn(`Converter: The components of ServerObject ${child.uuid} is not serialized.`);
	      }
	    } else {
	      obj = parts.filter(n => n.uuid === child.uuid)[0];
	    }

	    if (!obj) {
	      console.warn(`Converter: no element with uuid ${child.uuid}.`);
	      return;
	    }

	    parent.add(obj);

	    if (child.children.length > 0) {
	      this.parseScene(obj, child.children, parts, serverParts);
	    }
	  });
	};
	/**
	 * 将服务端模型分解为组件，并移除子组件
	 */


	Converter.prototype.traverseServerObject = function (obj, list) {
	  list.push(obj);

	  while (obj.children && obj.children.length) {
	    let child = obj.children[0];
	    obj.remove(child);
	    this.traverseServerObject(child, list);
	  }
	};
	/**
	 * 旧的保存格式还原场景，即将删除
	 */


	Converter.prototype.parseOld = function (sceneJson, scene, jsons, options) {
	  let serverObjects = [];
	  let serverParts = []; // 保存服务器模型内部组件，以便还原内部结构。

	  (function parseJson(json, parent, list) {
	    json.children.forEach(n => {
	      const objJson = list.filter(o => o.uuid === n)[0];

	      if (objJson == null) {
	        console.warn(`Converter: no object that uuid equals to ${n}.`);
	        return;
	      }

	      if (objJson.userData && objJson.userData.Server === true) {
	        // 服务器模型
	        serverObjects.push({
	          parent: parent,
	          json: objJson
	        });
	      }

	      let obj = null;

	      switch (objJson.metadata.generator) {
	        case 'SceneSerializer':
	          obj = new SceneSerializer().fromJSON(objJson, undefined, options.server);
	          break;

	        case 'GroupSerializer':
	          obj = new GroupSerializer().fromJSON(objJson);
	          break;

	        case 'ReflectorSerializer':
	          obj = new ReflectorSerializer().fromJSON(objJson);
	          break;

	        case 'MeshSerializer':
	          obj = new MeshSerializer().fromJSON(objJson, undefined, options.server);
	          break;

	        case 'SpriteSerializer':
	          obj = new SpriteSerializer().fromJSON(objJson, undefined, options.server);
	          break;

	        case 'AmbientLightSerializer':
	          obj = new AmbientLightSerializer().fromJSON(objJson);
	          break;

	        case 'DirectionalLightSerializer':
	          obj = new DirectionalLightSerializer().fromJSON(objJson);
	          break;

	        case 'HemisphereLightSerializer':
	          obj = new HemisphereLightSerializer().fromJSON(objJson);
	          break;

	        case 'PointLightSerializer':
	          obj = new PointLightSerializer().fromJSON(objJson);
	          break;

	        case 'RectAreaLightSerializer':
	          obj = new RectAreaLightSerializer().fromJSON(objJson);
	          break;

	        case 'SpotLightSerializer':
	          obj = new SpotLightSerializer().fromJSON(objJson);
	          break;

	        case 'AudioSerializer':
	          obj = new AudioSerializer().fromJSON(objJson, undefined, options.audioListener);
	          break;

	        case 'FireSerializer':
	          obj = new FireSerializer().fromJSON(objJson, undefined, options.camera);
	          break;

	        case 'SmokeSerializer':
	          obj = new SmokeSerializer().fromJSON(objJson, undefined, options.camera, options.renderer);
	          break;

	        case 'BoneSerializer':
	          obj = new BoneSerializer().fromJSON(objJson);
	          break;

	        case 'SkySerializer':
	          obj = new SkySerializer().fromJSON(objJson);
	          break;

	        case 'ParticleEmitterSerializer':
	          obj = new ParticleEmitterSerializer().fromJSON(objJson, undefined, options.server);
	          break;

	        case 'PerlinTerrainSerializer':
	          obj = new PerlinTerrainSerializer().fromJSON(objJson);
	          break;

	        case 'WaterSerializer':
	          obj = new WaterSerializer().fromJSON(objJson, undefined, options.renderer);
	          break;

	        case 'ClothSerializer':
	          obj = new ClothSerializer().fromJSON(objJson);
	          break;

	        case 'LineCurveSerializer':
	          obj = new LineCurveSerializer().fromJSON(objJson);
	          break;

	        case 'CatmullRomCurveSerializer':
	          obj = new CatmullRomCurveSerializer().fromJSON(objJson);
	          break;

	        case 'QuadraticBezierCurveSerializer':
	          obj = new QuadraticBezierCurveSerializer().fromJSON(objJson);
	          break;

	        case 'CubicBezierCurveSerializer':
	          obj = new CubicBezierCurveSerializer().fromJSON(objJson);
	          break;

	        case 'EllipseCurveSerializer':
	          obj = new EllipseCurveSerializer().fromJSON(objJson);
	          break;

	        case 'ServerObject':
	          obj = new Object3DSerializer().fromJSON(objJson, undefined);
	          break;

	        case 'Object3DSerializer':
	          obj = new Object3DSerializer().fromJSON(objJson, undefined);
	          break;

	        case 'GlobeSerializer':
	          return;
	      }

	      if (!obj) {
	        console.warn(`Converter: No Deserializer with ${objJson.metadata.generator}.`);
	        return;
	      }

	      if (objJson.userData && objJson.userData.Server === true || parent === null) {
	        // 服务端模型子组件
	        serverParts.push(obj);
	      } else {
	        // 其他要素
	        parent.add(obj);
	      } // 说明：
	      // 1、objJson.userData.type不为空，说明它是内置类型，其子项不应该被反序列化
	      // 2、objJson.userData.Server为true是模型，子项会被反序列化，但是不会添加到父模型中。


	      if (objJson.userData.type === undefined && Array.isArray(objJson.children) && objJson.children.length > 0) {
	        if (objJson.userData && objJson.userData.Server === true || parent === null) {
	          // 服务器模型或部件
	          parseJson(objJson, null, list);
	        } else {
	          parseJson(objJson, obj, list);
	        }
	      }
	    });
	  })(sceneJson, scene, jsons);

	  if (serverObjects.length === 0) {
	    return new Promise(resolve => {
	      resolve(scene);
	    });
	  }

	  let promises = serverObjects.map(serverObj => {
	    return new Promise(resolve => {
	      new ServerObject().fromJSON(serverObj.json, options, {
	        camera: options.camera,
	        renderer: options.renderer,
	        audioListener: options.audioListener,
	        parts: serverParts
	      }).then(obj => {
	        if (obj) {
	          if (serverObj.parent) {
	            serverObj.parent.add(obj);
	          } else {
	            console.warn(`Converter: the parent of serverObj with uuid ${serverObj.uuid} is null.`);
	          }
	        } else {
	          console.warn(`Converter: Server assets ${serverObj.json.uuid} loaded failed.`);
	        }

	        resolve();
	      });
	    });
	  });
	  return new Promise(resolve => {
	    Promise.all(promises).then(() => {
	      resolve(scene);
	    });
	  });
	};

	var ID$2 = -1;
	/**
	 * 播放器组件
	 * @param {*} app 播放器
	 */

	function PlayerComponent(app) {
	  this.id = `${this.constructor.name}${ID$2--}`;
	  this.app = app;
	}
	/**
	 * 创建
	 * @param {*} scene 
	 * @param {*} camera 
	 * @param {*} renderer 
	 * @param {*} others 
	 */


	PlayerComponent.prototype.create = function (scene, camera, renderer, others) {
	  return new Promise(resolve => {
	    resolve();
	  });
	};
	/**
	 * 更新
	 * @param {*} clock 
	 * @param {*} deltaTime 
	 */


	PlayerComponent.prototype.update = function (clock, deltaTime) {};
	/**
	 * 析构
	 * @param {*} scene 
	 * @param {*} camera 
	 * @param {*} renderer 
	 * @param {*} others 
	 */


	PlayerComponent.prototype.dispose = function (scene, camera, renderer, others) {};

	/**
	 * 播放器下载事件
	 * @param {*} app 播放器
	 */

	function PlayerLoader(app) {
	  PlayerComponent.call(this, app);
	}

	PlayerLoader.prototype = Object.create(PlayerComponent.prototype);
	PlayerLoader.prototype.constructor = PlayerLoader;

	PlayerLoader.prototype.create = function (jsons) {
	  return new Converter().fromJson(jsons, {
	    server: app.options.server
	  }).then(obj => {
	    this.scene = obj.scene;
	    return new Promise(resolve => {
	      resolve(obj);
	    });
	  });
	};

	PlayerLoader.prototype.dispose = function () {
	  // TODO: 彻底清空下载的模型资源
	  this.scene = null;
	};

	/**
	 * 播放器事件
	 * @param {*} app 播放器
	 */

	function PlayerEvent(app) {
	  PlayerComponent.call(this, app);
	}

	PlayerEvent.prototype = Object.create(PlayerComponent.prototype);
	PlayerEvent.prototype.constructor = PlayerEvent;

	PlayerEvent.prototype.create = function (scene, camera, renderer, scripts) {
	  this.scene = scene;
	  this.camera = camera;
	  this.renderer = renderer;
	  this.scripts = scripts;
	  var dom = renderer.domElement;
	  this.events = Object.keys(scripts).map(uuid => {
	    var script = scripts[uuid];
	    return new Function('app', 'scene', 'camera', 'renderer', script.source + `
            var init = init || null;
            var start = start || null;
            var update = update || null;
            var stop = stop || null;
            var onClick = onClick || null;
            var onDblClick = onDblClick || null;
            var onKeyDown = onKeyDown || null;
            var onKeyUp = onKeyUp || null;
            var onMouseDown = onMouseDown || null;
            var onMouseMove = onMouseMove || null;
            var onMouseUp = onMouseUp || null;
            var onMouseWheel = onMouseWheel || null;
            var onResize = onResize || null;
            return { init, start, update, stop, onClick, onDblClick, onKeyDown, onKeyUp, onMouseDown, onMouseMove, onMouseUp, onMouseWheel, onResize };
            `).call(scene, this.app, scene, camera, renderer);
	  });
	  this.events.forEach(n => {
	    if (typeof n.onClick === 'function') {
	      dom.addEventListener('click', n.onClick.bind(this.scene));
	    }

	    if (typeof n.onDblClick === 'function') {
	      dom.addEventListener('dblclick', n.onDblClick.bind(this.scene));
	    }

	    if (typeof n.onKeyDown === 'function') {
	      dom.addEventListener('keydown', n.onKeyDown.bind(this.scene));
	    }

	    if (typeof n.onKeyUp === 'function') {
	      dom.addEventListener('keyup', n.onKeyUp.bind(this.scene));
	    }

	    if (typeof n.onMouseDown === 'function') {
	      dom.addEventListener('mousedown', n.onMouseDown.bind(this.scene));
	    }

	    if (typeof n.onMouseMove === 'function') {
	      dom.addEventListener('mousemove', n.onMouseMove.bind(this.scene));
	    }

	    if (typeof n.onMouseUp === 'function') {
	      dom.addEventListener('mouseup', n.onMouseUp.bind(this.scene));
	    }

	    if (typeof n.onMouseWheel === 'function') {
	      dom.addEventListener('mousewheel', n.onMouseWheel.bind(this.scene));
	    }

	    if (typeof n.onResize === 'function') {
	      window.addEventListener('resize', n.onResize.bind(this.scene));
	    }
	  });
	  return new Promise(resolve => {
	    resolve();
	  });
	};
	/**
	 * 场景载入前执行一次
	 */


	PlayerEvent.prototype.init = function () {
	  this.events.forEach(n => {
	    if (typeof n.init === 'function') {
	      n.init();
	    }
	  });
	};
	/**
	 * 场景载入后执行一次
	 */


	PlayerEvent.prototype.start = function () {
	  this.events.forEach(n => {
	    if (typeof n.start === 'function') {
	      n.start();
	    }
	  });
	};
	/**
	 * 运行期间每帧都要执行
	 * @param {*} clock 
	 * @param {*} deltaTime 
	 */


	PlayerEvent.prototype.update = function (clock, deltaTime) {
	  this.events.forEach(n => {
	    if (typeof n.update === 'function') {
	      n.update(clock, deltaTime);
	    }
	  });
	};
	/**
	 * 程序结束运行后执行一次
	 */


	PlayerEvent.prototype.stop = function () {
	  this.events.forEach(n => {
	    if (typeof n.stop === 'function') {
	      n.stop();
	    }
	  });
	};
	/**
	 * 析构PlayerEvent
	 */


	PlayerEvent.prototype.dispose = function () {
	  var dom = this.renderer.domElement;
	  this.events.forEach(n => {
	    if (typeof n.onClick === 'function') {
	      dom.removeEventListener('click', n.onClick.bind(this.scene));
	    }

	    if (typeof n.onDblClick === 'function') {
	      dom.removeEventListener('dblclick', n.onDblClick.bind(this.scene));
	    }

	    if (typeof n.onKeyDown === 'function') {
	      dom.removeEventListener('keydown', n.onKeyDown.bind(this.scene));
	    }

	    if (typeof n.onKeyUp === 'function') {
	      dom.removeEventListener('keyup', n.onKeyUp.bind(this.scene));
	    }

	    if (typeof n.onMouseDown === 'function') {
	      dom.removeEventListener('mousedown', n.onMouseDown.bind(this.scene));
	    }

	    if (typeof n.onMouseMove === 'function') {
	      dom.removeEventListener('mousemove', n.onMouseMove.bind(this.scene));
	    }

	    if (typeof n.onMouseUp === 'function') {
	      dom.removeEventListener('mouseup', n.onMouseUp.bind(this.scene));
	    }

	    if (typeof n.onMouseWheel === 'function') {
	      dom.removeEventListener('mousewheel', n.onMouseWheel.bind(this.scene));
	    }

	    if (typeof n.onResize === 'function') {
	      window.removeEventListener('resize', n.onResize.bind(this.scene));
	    }
	  });
	  this.scene = null;
	  this.camera = null;
	  this.renderer = null;
	  this.scripts = null;
	  this.events.length = 0;
	};

	/**
	 * 播放器场景控制
	 * @param {*} app 播放器
	 */

	function PlayerControl(app) {
	  PlayerComponent.call(this, app);
	  this.packageManager = new PackageManager();
	  this.require = this.packageManager.require.bind(this.packageManager);
	  this.control = null;
	}

	PlayerControl.prototype = Object.create(PlayerComponent.prototype);
	PlayerControl.prototype.constructor = PlayerControl;

	PlayerControl.prototype.create = function (scene, camera, renderer) {
	  var type = camera.userData.control;
	  var promise = new Promise(resolve => {
	    resolve();
	  });

	  if (type === 'FirstPersonControls') {
	    // 第一视角控制器
	    promise = this.require('FirstPersonControls');
	  } else if (type === 'FlyControls') {
	    // 飞行控制器
	    promise = this.require('FlyControls');
	  } else if (type === 'OrbitControls') {
	    // 轨道控制器
	    promise = this.require('OrbitControls');
	  } else if (type === 'PointerLockControls') {
	    // 指针锁定控制器
	    promise = this.require('PointerLockControls');
	  } else if (type === 'TrackballControls') {
	    // 轨迹球控制器
	    promise = this.require('TrackballControls');
	  }

	  return promise.then(() => {
	    this._createControl(scene, camera, renderer);

	    return new Promise(resolve => {
	      resolve();
	    });
	  });
	};

	PlayerControl.prototype._createControl = function (scene, camera, renderer) {
	  var type = camera.userData.control;

	  if (type === 'FirstPersonControls') {
	    // 第一视角控制器
	    this.control = new THREE.FirstPersonControls(camera, renderer.domElement);

	    if (camera.userData.firstPersonOptions) {
	      Object.assign(this.control, camera.userData.firstPersonOptions);
	    }
	  } else if (type === 'FlyControls') {
	    // 飞行控制器
	    this.control = new THREE.FlyControls(camera, renderer.domElement);

	    if (camera.userData.flyOptions) {
	      Object.assign(this.control, camera.userData.flyOptions);
	    }
	  } else if (type === 'OrbitControls') {
	    // 轨道控制器
	    this.control = new THREE.OrbitControls(camera, renderer.domElement);

	    if (camera.userData.orbitOptions) {
	      Object.assign(this.control, camera.userData.orbitOptions);
	    }
	  } else if (type === 'PointerLockControls') {
	    // 指针锁定控制器
	    this.control = new THREE.PointerLockControls(camera, renderer.domElement);

	    if (camera.userData.pointerLockOptions) {
	      Object.assign(this.control, camera.userData.pointerLockOptions);

	      if (this.control.isLocked) {
	        this.control.lock();
	      } else {
	        this.control.unlock();
	      }
	    }
	  } else if (type === 'TrackballControls') {
	    // 轨迹球控制器
	    this.control = new THREE.TrackballControls(camera, renderer.domElement);

	    if (camera.userData.trackballOptions) {
	      Object.assign(this.control, camera.userData.trackballOptions);
	    }
	  }
	};

	PlayerControl.prototype.update = function (clock, deltaTime) {
	  if (this.control && this.control.update) {
	    this.control.update(deltaTime);
	  }
	};

	PlayerControl.prototype.dispose = function () {
	  if (this.control) {
	    this.control.dispose();
	    this.control = null;
	  }
	};

	/**
	 * 播放器音频
	 * @param {*} app 播放器
	 */

	function PlayerAudio(app) {
	  PlayerComponent.call(this, app);
	  this.audios = [];
	}

	PlayerAudio.prototype = Object.create(PlayerComponent.prototype);
	PlayerAudio.prototype.constructor = PlayerAudio;

	PlayerAudio.prototype.create = function (scene, camera, renderer) {
	  this.audios.length = 0;
	  scene.traverse(n => {
	    if (n instanceof THREE.Audio) {
	      this.audios.push(n);
	    }
	  });
	  var loader = new THREE.AudioLoader();
	  var promises = this.audios.map(n => {
	    return new Promise(resolve => {
	      loader.load(app.options.server + n.userData.Url, buffer => {
	        n.setBuffer(buffer);

	        if (n.userData.autoplay) {
	          n.autoplay = n.userData.autoplay;
	          n.play();
	        }

	        resolve();
	      }, undefined, () => {
	        console.warn(`PlayerLoader: ${n.userData.Url} loaded failed.`);
	        resolve();
	      });
	    });
	  });
	  return Promise.all(promises);
	};

	PlayerAudio.prototype.dispose = function () {
	  this.audios.forEach(n => {
	    if (n.isPlaying) {
	      n.stop();
	    }
	  });
	  this.audios.length = 0;
	};

	var ID$3 = -1;
	/**
	 * 基本渲染器
	 * @author tengge / https://github.com/tengge1
	 */

	function BaseRenderer() {
	  this.id = `${this.constructor.name}${ID$3--}`;
	}

	BaseRenderer.prototype.create = function (scenes, camera, renderer, selected) {
	  return new Promise(resolve => {
	    resolve();
	  });
	};

	BaseRenderer.prototype.render = function () {};

	BaseRenderer.prototype.dispose = function () {};

	/**
	 * 特效渲染器
	 */

	function EffectRenderer() {
	  BaseRenderer.call(this);
	  this.packageManager = new PackageManager();
	  this.require = this.packageManager.require.bind(this.packageManager);
	  this.ready = false;
	  this.effectNames = ['fxaa', 'smaa', 'ssaa', 'taa', 'sao', 'ssao', 'pixel', 'dotScreen', 'rgbShift', 'afterimage', 'halftone', 'bokeh', 'glitch'];
	}
	EffectRenderer.prototype = Object.create(BaseRenderer.prototype);
	EffectRenderer.prototype.constructor = EffectRenderer;
	/**
	 * 特效渲染器初始化，特效配置修改后需要重新调用该函数
	 * @param {*} scenes 场景数组，使用第一个场景的特效配置
	 * @param {*} camera 相机
	 * @param {*} renderer 渲染器
	 */

	EffectRenderer.prototype.create = async function (scenes, camera, renderer) {
	  if (!Array.isArray(scenes)) {
	    scenes = [scenes];
	  }

	  this.scenes = scenes;
	  this.camera = camera;
	  this.renderer = renderer;
	  var postProcessing = scenes[0].userData.postProcessing || {};
	  this.ready = false; // 快速近似抗锯齿

	  if (postProcessing.fxaa && postProcessing.fxaa.enabled) {
	    await this.require(['CopyShader', 'FXAAShader', 'EffectComposer', 'RenderPass', 'ShaderPass']);
	  } // 多重采样抗锯齿


	  if (postProcessing.smaa && postProcessing.smaa.enabled) {
	    await this.require(['CopyShader', 'SMAAShader', 'EffectComposer', 'RenderPass', 'ShaderPass', 'SMAAPass']);
	  } // 全屏抗锯齿


	  if (postProcessing.ssaa && postProcessing.ssaa.enabled) {
	    await this.require(['CopyShader', 'EffectComposer', 'RenderPass', 'ShaderPass', 'SSAARenderPass']);
	  } // 时间抗锯齿


	  if (postProcessing.taa && postProcessing.taa.enabled) {
	    await this.require(['CopyShader', 'EffectComposer', 'RenderPass', 'ShaderPass', 'SSAARenderPass', 'TAARenderPass']);
	  } // 可扩展环境光遮挡


	  if (postProcessing.sao && postProcessing.sao.enabled) {
	    await this.require(['CopyShader', 'SAOShader', 'DepthLimitedBlurShader', 'UnpackDepthRGBAShader', 'EffectComposer', 'RenderPass', 'ShaderPass', 'SAOPass']);
	  } // 屏幕空间环境光遮蔽


	  if (postProcessing.ssao && postProcessing.ssao.enabled) {
	    await this.require(['CopyShader', 'SSAOShader', 'EffectComposer', 'RenderPass', 'ShaderPass', 'SSAOPass']);
	  } // 像素特效


	  if (postProcessing.pixel && postProcessing.pixel.enabled) {
	    await this.require(['CopyShader', 'PixelShader', 'EffectComposer', 'RenderPass', 'ShaderPass']);
	  } // 点阵化


	  if (postProcessing.dotScreen && postProcessing.dotScreen.enabled) {
	    await this.require(['CopyShader', 'DotScreenShader', 'EffectComposer', 'RenderPass', 'ShaderPass']);
	  } // 颜色偏移


	  if (postProcessing.rgbShift && postProcessing.rgbShift.enabled) {
	    await this.require(['CopyShader', 'RGBShiftShader', 'EffectComposer', 'RenderPass', 'ShaderPass']);
	  } // 残影特效


	  if (postProcessing.afterimage && postProcessing.afterimage.enabled) {
	    await this.require(['CopyShader', 'AfterimageShader', 'EffectComposer', 'RenderPass', 'ShaderPass', 'AfterimagePass']);
	  } // 半色调特效


	  if (postProcessing.halftone && postProcessing.halftone.enabled) {
	    await this.require(['HalftoneShader', 'HalftonePass']);
	  } // 背景虚化特效


	  if (postProcessing.bokeh && postProcessing.bokeh.enabled) {
	    await this.require(['CopyShader', 'BokehShader', 'EffectComposer', 'RenderPass', 'ShaderPass', 'BokehPass']);
	  } // 毛刺特效


	  if (postProcessing.glitch && postProcessing.glitch.enabled) {
	    await this.require(['CopyShader', 'DigitalGlitch', 'EffectComposer', 'RenderPass', 'ShaderPass', 'GlitchPass']);
	  }

	  this._createPostProcessing(scenes, camera, renderer);

	  this.ready = true;
	};

	EffectRenderer.prototype._createPostProcessing = function (scenes, camera, renderer) {
	  let scene = scenes[0];
	  let postProcessing = scene.userData.postProcessing || {};

	  if (this.composer) {
	    this.dispose();
	  } // 判断是否需要启用特效渲染器


	  var keys = Object.keys(postProcessing);
	  var useEffect = false;

	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];

	    if (this.effectNames.indexOf(key) > -1 && postProcessing[key].enabled) {
	      // 需要特效
	      useEffect = true;
	      break;
	    }
	  }

	  if (!useEffect) {
	    return;
	  }

	  var effects = [],
	      effect;
	  var composer = new THREE.EffectComposer(renderer);
	  scenes.forEach((n, i) => {
	    effect = new THREE.RenderPass(n, camera);
	    effect.clear = i === 0;
	    composer.addPass(effect);
	    effects.push(effect);
	  }); // 快速近似抗锯齿

	  if (postProcessing.fxaa && postProcessing.fxaa.enabled) {
	    effect = new THREE.ShaderPass(THREE.FXAAShader);
	    effect.uniforms['resolution'].value.set(1 / renderer.domElement.width, 1 / renderer.domElement.height);
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 多重采样抗锯齿


	  if (postProcessing.smaa && postProcessing.smaa.enabled) {
	    effect = new THREE.SMAAPass(renderer.domElement.width * renderer.getPixelRatio(), renderer.domElement.height * renderer.getPixelRatio());
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 全屏抗锯齿


	  if (postProcessing.ssaa && postProcessing.ssaa.enabled) {
	    effect = new THREE.SSAARenderPass(scene, camera);
	    effect.unbiased = postProcessing.ssaa.unbiased;
	    effect.sampleLevel = postProcessing.ssaa.sampleLevel;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 时间抗锯齿


	  if (postProcessing.taa && postProcessing.taa.enabled) {
	    effect = new THREE.TAARenderPass(scene, camera);
	    effect.unbiased = postProcessing.taa.unbiased;
	    effect.sampleLevel = postProcessing.taa.sampleLevel;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 可扩展环境光遮挡


	  if (postProcessing.sao && postProcessing.sao.enabled) {
	    effect = new THREE.SAOPass(scene, camera, false, true);
	    effect.params.output = postProcessing.sao.output;
	    effect.params.saoBias = postProcessing.sao.saoBias;
	    effect.params.saoIntensity = postProcessing.sao.saoIntensity;
	    effect.params.saoScale = postProcessing.sao.saoScale;
	    effect.params.saoKernelRadius = postProcessing.sao.saoKernelRadius;
	    effect.params.saoMinResolution = postProcessing.sao.saoMinResolution;
	    effect.params.saoBlur = postProcessing.sao.saoBlur;
	    effect.params.saoBlurRadius = postProcessing.sao.saoBlurRadius;
	    effect.params.saoBlurStdDev = postProcessing.sao.saoBlurStdDev;
	    effect.params.saoBlurDepthCutoff = postProcessing.sao.saoBlurDepthCutoff;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 屏幕空间环境光遮蔽


	  if (postProcessing.ssao && postProcessing.ssao.enabled) {
	    effect = new THREE.SSAOPass(scene, camera, renderer.domElement.width, renderer.domElement.height);
	    effect.output = postProcessing.ssao.output;
	    effect.kernelRadius = postProcessing.ssao.kernelRadius;
	    effect.minDistance = postProcessing.ssao.minDistance;
	    effect.maxDistance = postProcessing.ssao.maxDistance;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 像素特效


	  if (postProcessing.pixel && postProcessing.pixel.enabled) {
	    effect = new THREE.ShaderPass(THREE.PixelShader);
	    effect.uniforms.resolution.value = new THREE.Vector2(renderer.domElement.width, renderer.domElement.height);
	    effect.uniforms.resolution.value.multiplyScalar(window.devicePixelRatio);
	    effect.uniforms.pixelSize.value = postProcessing.pixel.pixelSize;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 点阵化


	  if (postProcessing.dotScreen && postProcessing.dotScreen.enabled) {
	    effect = new THREE.ShaderPass(THREE.DotScreenShader);
	    effect.uniforms['scale'].value = postProcessing.dotScreen.scale;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 颜色偏移


	  if (postProcessing.rgbShift && postProcessing.rgbShift.enabled) {
	    effect = new THREE.ShaderPass(THREE.RGBShiftShader);
	    effect.uniforms['amount'].value = postProcessing.rgbShift.amount;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 残影特效


	  if (postProcessing.afterimage && postProcessing.afterimage.enabled) {
	    effect = new THREE.AfterimagePass();
	    effect.uniforms['damp'].value = postProcessing.afterimage.damp;
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 半色调特效


	  if (postProcessing.halftone && postProcessing.halftone.enabled) {
	    effect = new THREE.HalftonePass(renderer.domElement.width, renderer.domElement.height, {
	      shape: postProcessing.halftone.shape,
	      radius: postProcessing.halftone.radius,
	      rotateR: postProcessing.halftone.rotateR * (Math.PI / 180),
	      rotateB: postProcessing.halftone.rotateB * (Math.PI / 180),
	      rotateG: postProcessing.halftone.rotateG * (Math.PI / 180),
	      scatter: postProcessing.halftone.scatter,
	      blending: postProcessing.halftone.blending,
	      blendingMode: postProcessing.halftone.blendingMode,
	      greyscale: postProcessing.halftone.greyscale
	    });
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 背景虚化特效


	  if (postProcessing.bokeh && postProcessing.bokeh.enabled) {
	    effect = new THREE.BokehPass(scene, camera, {
	      focus: postProcessing.bokeh.focus,
	      aperture: postProcessing.bokeh.aperture / 100000,
	      maxblur: postProcessing.bokeh.maxBlur,
	      width: renderer.domElement.width,
	      height: renderer.domElement.height
	    });
	    composer.addPass(effect);
	    effects.push(effect);
	  } // 毛刺特效


	  if (postProcessing.glitch && postProcessing.glitch.enabled) {
	    effect = new THREE.GlitchPass();
	    effect.goWild = postProcessing.glitch.wild;
	    composer.addPass(effect);
	    effects.push(effect);
	  }

	  for (var i = 0; i < effects.length; i++) {
	    if (i === effects.length - 1) {
	      effects[i].renderToScreen = true;
	    } else {
	      effects[i].renderToScreen = false;
	    }
	  }

	  this.composer = composer;
	};
	/**
	 * 渲染特效
	 */


	EffectRenderer.prototype.render = function () {
	  if (this.composer && this.ready) {
	    // 使用特效渲染器
	    this.composer.render();
	  } else {
	    // 未设置特效
	    this.scenes.forEach(n => {
	      this.renderer.render(n, this.camera);
	    });
	  }
	};

	EffectRenderer.prototype.dispose = function () {
	  if (this.composer) {
	    this.composer.reset();
	    this.composer.passes.length = 0;
	    this.composer = null;
	  }
	};

	/**
	 * 播放器渲染器
	 * @param {*} app 播放器
	 */

	function PlayerRenderer(app) {
	  PlayerComponent.call(this, app);
	}

	PlayerRenderer.prototype = Object.create(PlayerComponent.prototype);
	PlayerRenderer.prototype.constructor = PlayerRenderer;

	PlayerRenderer.prototype.create = function (scene, camera, renderer) {
	  this.renderer = new EffectRenderer();
	  return this.renderer.create(scene, camera, renderer);
	};

	PlayerRenderer.prototype.update = function (clock, deltaTime) {
	  this.renderer.render();
	};

	PlayerRenderer.prototype.dispose = function () {
	  this.renderer.dispose();
	  this.renderer = null;
	};

	/*
	* Ease
	* Visit http://createjs.com/ for documentation, updates and examples.
	*
	* Copyright (c) 2010 gskinner.com, inc.
	*
	* Permission is hereby granted, free of charge, to any person
	* obtaining a copy of this software and associated documentation
	* files (the "Software"), to deal in the Software without
	* restriction, including without limitation the rights to use,
	* copy, modify, merge, publish, distribute, sublicense, and/or sell
	* copies of the Software, and to permit persons to whom the
	* Software is furnished to do so, subject to the following
	* conditions:
	*
	* The above copyright notice and this permission notice shall be
	* included in all copies or substantial portions of the Software.
	*
	* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	* OTHER DEALINGS IN THE SOFTWARE.
	*/

	/**
	 * @module TweenJS
	 * @author tweenjs / https://www.createjs.com/tweenjs
	 * @link https://github.com/CreateJS/TweenJS/blob/master/src/tweenjs/Ease.js
	 */

	/**
	 * The Ease class provides a collection of easing functions for use with TweenJS. It does not use the standard 4 param
	 * easing signature. Instead it uses a single param which indicates the current linear ratio (0 to 1) of the tween.
	 *
	 * Most methods on Ease can be passed directly as easing functions:
	 *
	 *      createjs.Tween.get(target).to({x:100}, 500, createjs.Ease.linear);
	 *
	 * However, methods beginning with "get" will return an easing function based on parameter values:
	 *
	 *      createjs.Tween.get(target).to({y:200}, 500, createjs.Ease.getPowIn(2.2));
	 *
	 * Please see the <a href="http://www.createjs.com/Demos/TweenJS/Tween_SparkTable">spark table demo</a> for an
	 * overview of the different ease types on <a href="http://tweenjs.com">TweenJS.com</a>.
	 *
	 * <em>Equations derived from work by Robert Penner.</em>
	 * @class Ease
	 * @static
	 **/
	function Ease() {
	  throw "Ease cannot be instantiated.";
	} // static methods and properties

	/**
	 * @method linear
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.linear = function (t) {
	  return t;
	};
	/**
	 * Identical to linear.
	 * @method none
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.none = Ease.linear;
	/**
	 * Mimics the simple -100 to 100 easing in Adobe Flash/Animate.
	 * @method get
	 * @param {Number} amount A value from -1 (ease in) to 1 (ease out) indicating the strength and direction of the ease.
	 * @static
	 * @return {Function}
	 **/

	Ease.get = function (amount) {
	  if (amount < -1) {
	    amount = -1;
	  } else if (amount > 1) {
	    amount = 1;
	  }

	  return function (t) {
	    if (amount == 0) {
	      return t;
	    }

	    if (amount < 0) {
	      return t * (t * -amount + 1 + amount);
	    }

	    return t * ((2 - t) * amount + (1 - amount));
	  };
	};
	/**
	 * Configurable exponential ease.
	 * @method getPowIn
	 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
	 * @static
	 * @return {Function}
	 **/


	Ease.getPowIn = function (pow) {
	  return function (t) {
	    return Math.pow(t, pow);
	  };
	};
	/**
	 * Configurable exponential ease.
	 * @method getPowOut
	 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
	 * @static
	 * @return {Function}
	 **/


	Ease.getPowOut = function (pow) {
	  return function (t) {
	    return 1 - Math.pow(1 - t, pow);
	  };
	};
	/**
	 * Configurable exponential ease.
	 * @method getPowInOut
	 * @param {Number} pow The exponent to use (ex. 3 would return a cubic ease).
	 * @static
	 * @return {Function}
	 **/


	Ease.getPowInOut = function (pow) {
	  return function (t) {
	    if ((t *= 2) < 1) return 0.5 * Math.pow(t, pow);
	    return 1 - 0.5 * Math.abs(Math.pow(2 - t, pow));
	  };
	};
	/**
	 * @method quadIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.quadIn = Ease.getPowIn(2);
	/**
	 * @method quadOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quadOut = Ease.getPowOut(2);
	/**
	 * @method quadInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quadInOut = Ease.getPowInOut(2);
	/**
	 * @method cubicIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.cubicIn = Ease.getPowIn(3);
	/**
	 * @method cubicOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.cubicOut = Ease.getPowOut(3);
	/**
	 * @method cubicInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.cubicInOut = Ease.getPowInOut(3);
	/**
	 * @method quartIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quartIn = Ease.getPowIn(4);
	/**
	 * @method quartOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quartOut = Ease.getPowOut(4);
	/**
	 * @method quartInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quartInOut = Ease.getPowInOut(4);
	/**
	 * @method quintIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quintIn = Ease.getPowIn(5);
	/**
	 * @method quintOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quintOut = Ease.getPowOut(5);
	/**
	 * @method quintInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.quintInOut = Ease.getPowInOut(5);
	/**
	 * @method sineIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.sineIn = function (t) {
	  return 1 - Math.cos(t * Math.PI / 2);
	};
	/**
	 * @method sineOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.sineOut = function (t) {
	  return Math.sin(t * Math.PI / 2);
	};
	/**
	 * @method sineInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.sineInOut = function (t) {
	  return -0.5 * (Math.cos(Math.PI * t) - 1);
	};
	/**
	 * Configurable "back in" ease.
	 * @method getBackIn
	 * @param {Number} amount The strength of the ease.
	 * @static
	 * @return {Function}
	 **/


	Ease.getBackIn = function (amount) {
	  return function (t) {
	    return t * t * ((amount + 1) * t - amount);
	  };
	};
	/**
	 * @method backIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.backIn = Ease.getBackIn(1.7);
	/**
	 * Configurable "back out" ease.
	 * @method getBackOut
	 * @param {Number} amount The strength of the ease.
	 * @static
	 * @return {Function}
	 **/

	Ease.getBackOut = function (amount) {
	  return function (t) {
	    return --t * t * ((amount + 1) * t + amount) + 1;
	  };
	};
	/**
	 * @method backOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.backOut = Ease.getBackOut(1.7);
	/**
	 * Configurable "back in out" ease.
	 * @method getBackInOut
	 * @param {Number} amount The strength of the ease.
	 * @static
	 * @return {Function}
	 **/

	Ease.getBackInOut = function (amount) {
	  amount *= 1.525;
	  return function (t) {
	    if ((t *= 2) < 1) return 0.5 * (t * t * ((amount + 1) * t - amount));
	    return 0.5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
	  };
	};
	/**
	 * @method backInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.backInOut = Ease.getBackInOut(1.7);
	/**
	 * @method circIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/

	Ease.circIn = function (t) {
	  return -(Math.sqrt(1 - t * t) - 1);
	};
	/**
	 * @method circOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.circOut = function (t) {
	  return Math.sqrt(1 - --t * t);
	};
	/**
	 * @method circInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.circInOut = function (t) {
	  if ((t *= 2) < 1) return -0.5 * (Math.sqrt(1 - t * t) - 1);
	  return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
	};
	/**
	 * @method bounceIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.bounceIn = function (t) {
	  return 1 - Ease.bounceOut(1 - t);
	};
	/**
	 * @method bounceOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.bounceOut = function (t) {
	  if (t < 1 / 2.75) {
	    return 7.5625 * t * t;
	  } else if (t < 2 / 2.75) {
	    return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
	  } else if (t < 2.5 / 2.75) {
	    return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
	  } else {
	    return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
	  }
	};
	/**
	 * @method bounceInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.bounceInOut = function (t) {
	  if (t < 0.5) return Ease.bounceIn(t * 2) * .5;
	  return Ease.bounceOut(t * 2 - 1) * 0.5 + 0.5;
	};
	/**
	 * Configurable elastic ease.
	 * @method getElasticIn
	 * @param {Number} amplitude
	 * @param {Number} period
	 * @static
	 * @return {Function}
	 **/


	Ease.getElasticIn = function (amplitude, period) {
	  var pi2 = Math.PI * 2;
	  return function (t) {
	    if (t == 0 || t == 1) return t;
	    var s = period / pi2 * Math.asin(1 / amplitude);
	    return -(amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period));
	  };
	};
	/**
	 * @method elasticIn
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.elasticIn = Ease.getElasticIn(1, 0.3);
	/**
	 * Configurable elastic ease.
	 * @method getElasticOut
	 * @param {Number} amplitude
	 * @param {Number} period
	 * @static
	 * @return {Function}
	 **/

	Ease.getElasticOut = function (amplitude, period) {
	  var pi2 = Math.PI * 2;
	  return function (t) {
	    if (t == 0 || t == 1) return t;
	    var s = period / pi2 * Math.asin(1 / amplitude);
	    return amplitude * Math.pow(2, -10 * t) * Math.sin((t - s) * pi2 / period) + 1;
	  };
	};
	/**
	 * @method elasticOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.elasticOut = Ease.getElasticOut(1, 0.3);
	/**
	 * Configurable elastic ease.
	 * @method getElasticInOut
	 * @param {Number} amplitude
	 * @param {Number} period
	 * @static
	 * @return {Function}
	 **/

	Ease.getElasticInOut = function (amplitude, period) {
	  var pi2 = Math.PI * 2;
	  return function (t) {
	    var s = period / pi2 * Math.asin(1 / amplitude);
	    if ((t *= 2) < 1) return -0.5 * (amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period));
	    return amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * 0.5 + 1;
	  };
	};
	/**
	 * @method elasticInOut
	 * @param {Number} t
	 * @static
	 * @return {Number}
	 **/


	Ease.elasticInOut = Ease.getElasticInOut(1, 0.3 * 1.5);

	/**
	 * 补间动画控制器
	 * @param {*} app 播放器
	 */

	function TweenAnimator(app) {
	  PlayerComponent.call(this, app);
	}

	TweenAnimator.prototype = Object.create(PlayerComponent.prototype);
	TweenAnimator.prototype.constructor = TweenAnimator;

	TweenAnimator.prototype.create = function (scene, camera, renderer, animations) {
	  this.scene = scene;
	  this.animations = animations;
	  return new Promise(resolve => {
	    resolve();
	  });
	};

	TweenAnimator.prototype.update = function (clock, deltaTime, time) {
	  this.animations.forEach(n => {
	    n.animations.forEach(m => {
	      this.tweenObject(m, time);
	    });
	  });
	};

	TweenAnimator.prototype.tweenObject = function (animation, time) {
	  // 条件判断
	  if (animation.type !== 'Tween' || time < animation.beginTime || time > animation.endTime || animation.target == null) {
	    return;
	  } // 获取对象


	  var target = this.scene.getObjectByProperty('uuid', animation.target);

	  if (target == null) {
	    console.warn(`Player: There is no object that uuid equals to ${animation.target}.`);
	    return;
	  } // 获取插值函数


	  var data = animation.data;
	  var ease = Ease[data.ease];

	  if (ease == null) {
	    console.warn(`Player: There is no ease function named ${data.ease}.`);
	    return;
	  }

	  var result = ease((time - animation.beginTime) / (animation.endTime - animation.beginTime));
	  var positionX = data.beginPositionX + (data.endPositionX - data.beginPositionX) * result;
	  var positionY = data.beginPositionY + (data.endPositionY - data.beginPositionY) * result;
	  var positionZ = data.beginPositionZ + (data.endPositionZ - data.beginPositionZ) * result;
	  var rotationX = data.beginRotationX + (data.endRotationX - data.beginRotationX) * result;
	  var rotationY = data.beginRotationY + (data.endRotationY - data.beginRotationY) * result;
	  var rotationZ = data.beginRotationZ + (data.endRotationZ - data.beginRotationZ) * result;
	  var scaleX = data.beginScaleX + (data.endScaleX - data.beginScaleX) * result;
	  var scaleY = data.beginScaleY + (data.endScaleY - data.beginScaleY) * result;
	  var scaleZ = data.beginScaleZ + (data.endScaleZ - data.beginScaleZ) * result;
	  target.position.x = positionX;
	  target.position.y = positionY;
	  target.position.z = positionZ;
	  target.rotation.x = rotationX;
	  target.rotation.y = rotationY;
	  target.rotation.z = rotationZ;
	  target.scale.x = scaleX;
	  target.scale.y = scaleY;
	  target.scale.z = scaleZ;
	};

	TweenAnimator.prototype.dispose = function () {
	  this.scene = null;
	  this.animations = null;
	};

	/**
	 * MMD动画控制器
	 * @param {*} app 播放器
	 */

	function MMDAnimator(app) {
	  PlayerComponent.call(this, app);
	  this.time = 0.0; // 当前动画播放时间

	  this.delayTime = 160 * 1 / 30; // 动画比音频提前执行时间
	}

	MMDAnimator.prototype = Object.create(PlayerComponent.prototype);
	MMDAnimator.prototype.constructor = MMDAnimator;

	MMDAnimator.prototype.create = function (scene, camera, renderer, animations) {
	  var mmds = [];
	  scene.traverse(mesh => {
	    if (mesh.userData.Type === 'pmd' || mesh.userData.Type === 'pmx') {
	      mmds.push(mesh);
	    }
	  });

	  if (mmds.length === 0) {
	    return;
	  }

	  if (this.helper === undefined) {
	    this.helper = new THREE.MMDAnimationHelper();
	  }

	  var helper = this.helper;
	  mmds.forEach(mesh => {
	    let {
	      animation,
	      cameraAnimation,
	      audio
	    } = mesh.userData.obj;

	    if (animation) {
	      helper.add(mesh, {
	        animation: animation,
	        physics: true
	      });
	    } else {
	      helper.add(mesh, {
	        physics: true
	      });
	    }

	    if (cameraAnimation) {
	      helper.add(camera, {
	        animation: cameraAnimation
	      });
	    }

	    if (audio) {
	      var audioParams = {
	        delayTime: this.delayTime
	      };
	      helper.add(audio, audioParams);
	    }
	  });
	  this.time = 0.0;
	  return new Promise(resolve => {
	    resolve();
	  });
	};

	MMDAnimator.prototype.update = function (clock, deltaTime) {
	  if (!this.helper) {
	    return;
	  }

	  if (this.helper.audio) {
	    // 如果有音频，使用音频时间比较准确
	    var currentTime = this.helper.audio.context.currentTime - this.helper.audio.startTime;

	    if (currentTime < this.delayTime) {
	      this.time += deltaTime;
	    } else {
	      var time = this.delayTime + currentTime;
	      deltaTime = time - this.time;
	      this.time = time;
	    }
	  }

	  this.helper.update(deltaTime);
	};

	MMDAnimator.prototype.dispose = function () {
	  if (!this.helper) {
	    return;
	  }

	  var helper = this.helper;
	  helper.meshes.forEach(n => {
	    helper.remove(n);
	  });

	  if (helper.camera) {
	    helper.remove(helper.camera);
	  }

	  if (helper.audio) {
	    if (helper.audio.isPlaying) {
	      helper.audio.stop();
	    }

	    helper.remove(helper.audio);
	  }

	  delete this.helper;
	};

	/**
	 * 粒子动画控制器
	 * @param {*} app 播放器
	 */

	function ParticleAnimator(app) {
	  PlayerComponent.call(this, app);
	}

	ParticleAnimator.prototype = Object.create(PlayerComponent.prototype);
	ParticleAnimator.prototype.constructor = ParticleAnimator;

	ParticleAnimator.prototype.create = function (scene, camera, renderer) {
	  this.scene = scene;
	  return new Promise(resolve => {
	    resolve();
	  });
	};

	ParticleAnimator.prototype.update = function (clock, deltaTime, time) {
	  var elapsed = clock.getElapsedTime();
	  this.scene.children.forEach(n => {
	    if (n.userData.type === 'Fire') {
	      n.userData.fire.update(elapsed);
	    } else if (n.userData.type === 'Smoke') {
	      n.update(elapsed);
	    } else if (n.userData.type === 'Water') {
	      n.update();
	    } else if (n.userData.type === 'ParticleEmitter') {
	      n.userData.group.tick(deltaTime);
	    } else if (n.userData.type === 'Cloth') {
	      n.update();
	    }
	  });
	};

	ParticleAnimator.prototype.dispose = function () {
	  this.scene = null;
	};

	/**
	 * 播放器动画
	 * @param {*} app 播放器
	 */

	function PlayerAnimation(app) {
	  PlayerComponent.call(this, app);
	  this.maxTime = 0; // 最大动画时间（单位：秒）

	  this.currentTime = 0; // 当前动画时间（单位：秒）

	  this.animations = null;
	  this.animators = [new TweenAnimator(app), new MMDAnimator(app), new ParticleAnimator(app)];
	}

	PlayerAnimation.prototype = Object.create(PlayerComponent.prototype);
	PlayerAnimation.prototype.constructor = PlayerAnimation;

	PlayerAnimation.prototype.create = function (scene, camera, renderer, animations) {
	  this.maxTime = 0;
	  this.currentTime = 0;
	  this.scene = scene;
	  this.camera = camera;
	  this.renderer = renderer;
	  this.animations = animations;
	  this.maxTime = this.calculateMaxTime();
	  var promises = this.animators.map(n => {
	    return n.create(scene, camera, renderer, animations);
	  });
	  return Promise.all(promises);
	};

	PlayerAnimation.prototype.calculateMaxTime = function () {
	  var maxTime = 0;
	  this.animations.forEach(n => {
	    n.animations.forEach(m => {
	      if (m.endTime > maxTime) {
	        maxTime = m.endTime;
	      }
	    });
	  });
	  return maxTime;
	};

	PlayerAnimation.prototype.update = function (clock, deltaTime) {
	  if (this.maxTime > 0) {
	    this.currentTime = clock.getElapsedTime() % this.maxTime;
	  }

	  this.animators.forEach(n => {
	    n.update(clock, deltaTime, this.currentTime);
	  });
	};

	PlayerAnimation.prototype.dispose = function () {
	  this.maxTime = 0;
	  this.currentTime = 0;
	  this.scene = null;
	  this.camera = null;
	  this.renderer = null;
	  this.animations = null;
	  this.animators.forEach(n => {
	    n.dispose();
	  });
	};

	/**
	 * 按z键扔球事件
	 * @param {*} app 播放器
	 * @param {*} world 
	 * @param {*} rigidBodies 
	 */

	function ThrowBallEvent(app, world, rigidBodies) {
	  PlayerComponent.call(this, app);
	  this.world = world;
	  this.rigidBodies = rigidBodies;
	}

	ThrowBallEvent.prototype = Object.create(PlayerComponent.prototype);
	ThrowBallEvent.prototype.constructor = ThrowBallEvent;

	ThrowBallEvent.prototype.create = function (scene, camera, renderer) {
	  this.scene = scene;
	  this.camera = camera;
	  this.renderer = renderer;
	  this.renderer.domElement.addEventListener('click', this.throwBall.bind(this));
	};

	ThrowBallEvent.prototype.dispose = function () {
	  // TODO: 不判断有时报错，不知道为什么。
	  if (this.renderer) {
	    this.renderer.domElement.removeEventListener('click', this.throwBall);
	  }

	  this.scene = null;
	  this.camera = null;
	  this.renderer = null;
	};

	ThrowBallEvent.prototype.throwBall = function (event) {
	  if (!app.options.enableThrowBall) {
	    return;
	  }

	  var mouse = new THREE.Vector2();
	  var raycaster = new THREE.Raycaster();
	  var camera = this.camera;
	  var width = this.renderer.domElement.width;
	  var height = this.renderer.domElement.height;
	  mouse.set(event.offsetX / width * 2 - 1, -(event.offsetY / height) * 2 + 1);
	  raycaster.setFromCamera(mouse, camera); // Creates a ball and throws it

	  var ballMass = 3;
	  var ballRadius = 0.4;
	  var ballMaterial = new THREE.MeshPhongMaterial({
	    color: 0x202020
	  });
	  var ball = new THREE.Mesh(new THREE.SphereBufferGeometry(ballRadius, 14, 10), ballMaterial);
	  ball.castShadow = true;
	  ball.receiveShadow = true;
	  this.scene.add(ball);
	  var ballShape = new Ammo.btSphereShape(ballRadius);
	  var pos = new THREE.Vector3();
	  pos.copy(raycaster.ray.direction);
	  pos.add(raycaster.ray.origin);
	  var quat = new THREE.Quaternion();
	  quat.set(0, 0, 0, 1);
	  var body = this.createRigidBody(ball, ballShape, ballMass, pos, quat);
	  pos.copy(raycaster.ray.direction);
	  pos.multiplyScalar(20);
	  body.setLinearVelocity(new Ammo.btVector3(pos.x, pos.y, pos.z));
	  body.setFriction(0.5);
	  ball.userData.physics = {
	    body: body
	  };
	  this.world.addRigidBody(body);
	  this.rigidBodies.push(ball);
	};

	ThrowBallEvent.prototype.createRigidBody = function (threeObject, physicsShape, mass, pos, quat) {
	  threeObject.position.copy(pos);
	  threeObject.quaternion.copy(quat);
	  var transform = new Ammo.btTransform();
	  transform.setIdentity();
	  transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
	  transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
	  var motionState = new Ammo.btDefaultMotionState(transform);
	  var localInertia = new Ammo.btVector3(0, 0, 0);
	  physicsShape.calculateLocalInertia(mass, localInertia);
	  var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, physicsShape, localInertia);
	  var body = new Ammo.btRigidBody(rbInfo);

	  if (mass > 0) {
	    body.setActivationState(4);
	  }

	  return body;
	};

	//     btBoxShape: Ammo.btBoxShape, // 正方体
	//     btBvhTriangleMeshShape: Ammo.btBvhTriangleMeshShape, // 三角形
	//     btCapsuleShape: Ammo.btCapsuleShape, // 胶囊
	//     btCapsuleShapeX: Ammo.btCapsuleShapeX, // x轴胶囊
	//     btCapsuleShapeZ: Ammo.btCapsuleShapeZ, // z轴胶囊
	//     btCollisionShape: Ammo.btCollisionShape, // 碰撞体
	//     btCompoundShape: Ammo.btCompoundShape, // 复合形状
	//     btConcaveShape: Ammo.btConcaveShape, // 
	//     btConeShape: Ammo.btConeShape, // 圆锥体
	//     btConeShapeX: Ammo.btConeShapeX, // x轴圆椎体
	//     btConeShapeZ: Ammo.btConeShapeZ, // z轴圆椎体
	//     btConvexHullShape: Ammo.btConvexHullShape, // 凸包
	//     btConvexShape: Ammo.btConvexShape, // 
	//     btConvexTriangleMeshShape: Ammo.btConvexTriangleMeshShape, // 凸三角形
	//     btCylinderShape: Ammo.btCylinderShape, // 圆柱体
	//     btCylinderShapeX: Ammo.btCylinderShapeX, // x轴圆柱体
	//     btCylinderShapeZ: Ammo.btCylinderShapeZ, // z轴圆柱体
	//     btHeightfieldTerrainShape: Ammo.btHeightfieldTerrainShape, // 灰阶高程地形
	//     btSphereShape: Ammo.btSphereShape, // 球体
	//     btStaticPlaneShape: Ammo.btStaticPlaneShape, // 静态平板
	//     btTriangleMeshShape: Ammo.btTriangleMeshShape, // 三角网格
	// };

	/**
	 * 播放器物理
	 * @param {*} app 播放器
	 */

	function PlayerPhysics(app) {
	  PlayerComponent.call(this, app);
	}

	PlayerPhysics.prototype = Object.create(PlayerComponent.prototype);
	PlayerPhysics.prototype.constructor = PlayerPhysics;

	PlayerPhysics.prototype.create = function (scene, camera, renderer) {
	  var usePhysics = false;
	  this.scene = scene;
	  this.scene.traverse(n => {
	    if (n.userData && n.userData.physics && n.userData.physics.enabled) {
	      usePhysics = true;
	    }
	  }); // 未使用物理

	  if (!usePhysics) {
	    return new Promise(resolve => {
	      resolve();
	    });
	  }

	  this.initPhysicsWorld();
	  this.initScene(scene, camera, renderer);
	};

	PlayerPhysics.prototype.initPhysicsWorld = function () {
	  // 各种参数
	  var gravityConstant = -9.8; // 重力常数

	  this.margin = 0.05; // 两个物体之间最小间距
	  // 物理环境配置

	  var collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration(); // 软体刚体碰撞配置

	  var dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration); // 碰撞调度器

	  var broadphase = new Ammo.btDbvtBroadphase(); // dbvt粗测

	  var solver = new Ammo.btSequentialImpulseConstraintSolver(); // 顺序脉冲约束求解器

	  var softBodySolver = new Ammo.btDefaultSoftBodySolver(); // 默认软体求解器

	  this.world = new Ammo.btSoftRigidDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
	  var gravity = new Ammo.btVector3(0, gravityConstant, 0);
	  this.world.setGravity(gravity);
	  this.world.getWorldInfo().set_m_gravity(gravity);
	  this.transformAux1 = new Ammo.btTransform();
	  this.rigidBodies = [];
	  this.softBodies = [];
	  this.softBodyHelpers = new Ammo.btSoftBodyHelpers();
	  this.events = [new ThrowBallEvent(app, this.world, this.rigidBodies)]; // api函数
	  // TODO: 很难受的实现

	  Object.assign(this.app, {
	    addPhysicsObject: this.addPhysicsObject.bind(this)
	  });
	};

	PlayerPhysics.prototype.initScene = function (scene, camera, renderer) {
	  this.scene.traverse(n => {
	    if (n.userData && n.userData.physics && n.userData.physics.enabled) {
	      if (n.userData.physics.type === 'rigidBody') {
	        var body = this.createRigidBody(n);

	        if (body) {
	          n.userData.physics.body = body;
	          this.world.addRigidBody(body);

	          if (n.userData.physics.mass > 0) {
	            this.rigidBodies.push(n);
	            body.setActivationState(4);
	          }
	        }
	      } else if (n.userData.physics.type === 'softVolume') {
	        var body = this.createSoftVolume(n);

	        if (body) {
	          n.userData.physics.body = body;
	          this.world.addSoftBody(body, 1, -1);
	          this.softBodies.push(n);

	          if (n.userData.physics.mass > 0) {
	            body.setActivationState(4);
	          }
	        }
	      } else {
	        console.warn(`PlayerPhysics: unknown physics type ${n.userData.physics.type}.`);
	      }
	    }
	  });
	  this.events.forEach(n => {
	    n.create(scene, camera, renderer);
	  });
	};

	PlayerPhysics.prototype.update = function (clock, deltaTime) {
	  if (!this.world) {
	    return;
	  }

	  this.world.stepSimulation(deltaTime, 10); // 更新柔软体

	  var softBodies = this.softBodies;

	  for (var i = 0, il = softBodies.length; i < il; i++) {
	    var volume = softBodies[i];
	    var geometry = volume.geometry;
	    var body = volume.userData.physics.body;
	    var volumePositions = geometry.attributes.position.array;
	    var volumeNormals = geometry.attributes.normal.array;
	    var association = geometry.ammoIndexAssociation;
	    var numVerts = association.length;
	    var nodes = body.get_m_nodes();

	    for (var j = 0; j < numVerts; j++) {
	      var node = nodes.at(j);
	      var nodePos = node.get_m_x();
	      var x = nodePos.x();
	      var y = nodePos.y();
	      var z = nodePos.z();
	      var nodeNormal = node.get_m_n();
	      var nx = nodeNormal.x();
	      var ny = nodeNormal.y();
	      var nz = nodeNormal.z();
	      var assocVertex = association[j];

	      for (var k = 0, kl = assocVertex.length; k < kl; k++) {
	        var indexVertex = assocVertex[k];
	        volumePositions[indexVertex] = x;
	        volumeNormals[indexVertex] = nx;
	        indexVertex++;
	        volumePositions[indexVertex] = y;
	        volumeNormals[indexVertex] = ny;
	        indexVertex++;
	        volumePositions[indexVertex] = z;
	        volumeNormals[indexVertex] = nz;
	      }
	    }

	    geometry.attributes.position.needsUpdate = true;
	    geometry.attributes.normal.needsUpdate = true;
	  }

	  var rigidBodies = this.rigidBodies;

	  for (var i = 0, l = rigidBodies.length; i < l; i++) {
	    var objThree = rigidBodies[i];
	    var objPhys = objThree.userData.physics.body;

	    if (!objPhys) {
	      continue;
	    }

	    var ms = objPhys.getMotionState();

	    if (ms) {
	      ms.getWorldTransform(this.transformAux1);
	      var p = this.transformAux1.getOrigin();
	      var q = this.transformAux1.getRotation();
	      objThree.position.set(p.x(), p.y(), p.z());
	      objThree.quaternion.set(q.x(), q.y(), q.z(), q.w());
	    }
	  }

	  this.events.forEach(n => {
	    n.update(clock, deltaTime);
	  });
	};

	PlayerPhysics.prototype.dispose = function () {
	  this.events && this.events.forEach(n => {
	    n.dispose();
	  });

	  if (this.rigidBodies) {
	    this.rigidBodies.forEach(n => {
	      var body = n.userData.physics.body;
	      this.world.removeRigidBody(body);
	    });
	    this.rigidBodies.length = 0;
	  }

	  if (this.softBodies) {
	    this.softBodies.forEach(n => {
	      var body = n.userData.physics.body;
	      this.world.removeRigidBody(body);
	    });
	    this.softBodies.length = 0;
	  }

	  this.scene.traverse(n => {
	    if (n.userData && n.userData.physics) {
	      n.userData.physics.body = null;
	    }
	  });
	  this.scene = null;
	}; // ------------------------------------ 创建刚体 ------------------------------------


	PlayerPhysics.prototype.createRigidBody = function (obj) {
	  var position = obj.position;
	  var quaternion = obj.quaternion;
	  var scale = obj.scale;
	  var physics = obj.userData.physics;
	  var shape = physics.shape;
	  var mass = physics.mass;
	  var inertia = physics.inertia; // 形状

	  var physicsShape = null;

	  if (shape === 'btBoxShape') {
	    var geometry = obj.geometry;
	    geometry.computeBoundingBox();
	    var box = geometry.boundingBox;
	    var x = box.max.x - box.min.x;
	    var y = box.max.y - box.min.y;
	    var z = box.max.z - box.min.z;
	    var center = new THREE.Vector3();
	    box.getCenter(center);
	    position = position.clone();
	    position.add(center);
	    physicsShape = new Ammo.btBoxShape(new Ammo.btVector3(x * 0.5, y * 0.5, z * 0.5));
	  } else if (shape === 'btSphereShape') {
	    var geometry = obj.geometry;
	    geometry.computeBoundingSphere();
	    var sphere = geometry.boundingSphere;
	    physicsShape = new Ammo.btSphereShape(sphere.radius);
	  } else {
	    console.warn(`PlayerPhysics: cannot create shape ${shape}.`);
	    return null;
	  }

	  physicsShape.setMargin(0.05); // 位移

	  var transform = new Ammo.btTransform();
	  transform.setIdentity();
	  transform.setOrigin(new Ammo.btVector3(position.x, position.y, position.z));
	  transform.setRotation(new Ammo.btQuaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w));
	  var defaultState = new Ammo.btDefaultMotionState(transform);
	  var localInertia = new Ammo.btVector3(inertia.x, inertia.y, inertia.z);
	  physicsShape.calculateLocalInertia(mass, localInertia);
	  var info = new Ammo.btRigidBodyConstructionInfo(mass, defaultState, physicsShape, localInertia);
	  return new Ammo.btRigidBody(info);
	}; // --------------------------------- 创建柔软体 ---------------------------------------------


	PlayerPhysics.prototype.createSoftVolume = function (obj) {
	  var geometry = obj.geometry;
	  var mass = obj.userData.physics.mass;
	  var pressure = obj.userData.physics.pressure;
	  this.processGeometry(geometry);
	  var volume = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
	    color: 0xFFFFFF
	  }));
	  volume.castShadow = true;
	  volume.receiveShadow = true;
	  volume.frustumCulled = false; // Volume physic object

	  var body = this.softBodyHelpers.CreateFromTriMesh(this.world.getWorldInfo(), geometry.ammoVertices, geometry.ammoIndices, geometry.ammoIndices.length / 3, true);
	  var sbConfig = body.get_m_cfg();
	  sbConfig.set_viterations(40); // 设置迭代次数

	  sbConfig.set_piterations(40); // Soft-soft and soft-rigid碰撞

	  sbConfig.set_collisions(0x11); // 摩擦力(Friction)

	  sbConfig.set_kDF(0.1); // 减震(Damping)

	  sbConfig.set_kDP(0.01); // 压力(Pressure)

	  sbConfig.set_kPR(pressure); // 刚性(Stiffness)

	  body.get_m_materials().at(0).set_m_kLST(0.9);
	  body.get_m_materials().at(0).set_m_kAST(0.9);
	  body.setTotalMass(mass, false);
	  Ammo.castObject(body, Ammo.btCollisionObject).getCollisionShape().setMargin(0.05);
	  return body;
	};

	PlayerPhysics.prototype.processGeometry = function (bufGeometry) {
	  // Obtain a Geometry
	  var geometry = new THREE.Geometry().fromBufferGeometry(bufGeometry); // Merge the vertices so the triangle soup is converted to indexed triangles

	  geometry.mergeVertices(); // Convert again to BufferGeometry, indexed

	  var indexedBufferGeom = this.createIndexedBufferGeometryFromGeometry(geometry); // Create index arrays mapping the indexed vertices to bufGeometry vertices

	  this.mapIndices(bufGeometry, indexedBufferGeom);
	};

	PlayerPhysics.prototype.createIndexedBufferGeometryFromGeometry = function (geometry) {
	  var numVertices = geometry.vertices.length;
	  var numFaces = geometry.faces.length;
	  var bufferGeom = new THREE.BufferGeometry();
	  var vertices = new Float32Array(numVertices * 3);
	  var indices = new (numFaces * 3 > 65535 ? Uint32Array : Uint16Array)(numFaces * 3);

	  for (var i = 0; i < numVertices; i++) {
	    var p = geometry.vertices[i];
	    var i3 = i * 3;
	    vertices[i3] = p.x;
	    vertices[i3 + 1] = p.y;
	    vertices[i3 + 2] = p.z;
	  }

	  for (var i = 0; i < numFaces; i++) {
	    var f = geometry.faces[i];
	    var i3 = i * 3;
	    indices[i3] = f.a;
	    indices[i3 + 1] = f.b;
	    indices[i3 + 2] = f.c;
	  }

	  bufferGeom.setIndex(new THREE.BufferAttribute(indices, 1));
	  bufferGeom.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
	  return bufferGeom;
	};

	PlayerPhysics.prototype.mapIndices = function (bufGeometry, indexedBufferGeom) {
	  // Creates ammoVertices, ammoIndices and ammoIndexAssociation in bufGeometry
	  var vertices = bufGeometry.attributes.position.array;
	  var idxVertices = indexedBufferGeom.attributes.position.array;
	  var indices = indexedBufferGeom.index.array;
	  var numIdxVertices = idxVertices.length / 3;
	  var numVertices = vertices.length / 3;
	  bufGeometry.ammoVertices = idxVertices;
	  bufGeometry.ammoIndices = indices;
	  bufGeometry.ammoIndexAssociation = [];

	  for (var i = 0; i < numIdxVertices; i++) {
	    var association = [];
	    bufGeometry.ammoIndexAssociation.push(association);
	    var i3 = i * 3;

	    for (var j = 0; j < numVertices; j++) {
	      var j3 = j * 3;

	      if (this.isEqual(idxVertices[i3], idxVertices[i3 + 1], idxVertices[i3 + 2], vertices[j3], vertices[j3 + 1], vertices[j3 + 2])) {
	        association.push(j3);
	      }
	    }
	  }
	};

	PlayerPhysics.prototype.isEqual = function (x1, y1, z1, x2, y2, z2) {
	  var delta = 0.000001;
	  return Math.abs(x2 - x1) < delta && Math.abs(y2 - y1) < delta && Math.abs(z2 - z1) < delta;
	}; // --------------------------------- API函数 ------------------------------------------------

	/**
	 * 添加一个物理物体
	 * @param {*} obj 
	 */


	PlayerPhysics.prototype.addPhysicsObject = function (obj) {
	  this.scene.add(obj);

	  if (obj.userData && obj.userData.physics && obj.userData.physics.enabled) {
	    if (obj.userData.physics.type === 'rigidBody') {
	      var body = this.createRigidBody(obj);

	      if (body) {
	        obj.userData.physics.body = body;
	        this.world.addRigidBody(body);

	        if (obj.userData.physics.mass > 0) {
	          this.rigidBodies.push(obj);
	          body.setActivationState(4);
	        }
	      }
	    } else if (obj.userData.physics.type === 'softVolume') {
	      var body = this.createSoftVolume(obj);

	      if (body) {
	        obj.userData.physics.body = body;
	        this.world.addSoftBody(body);
	        this.softBodies.push(obj);
	      }
	    }
	  }
	};

	/**
	 * CSS工具类
	 */
	var CssUtils = {
	  /**
	   * 序列化滤镜
	   * @param {*} filters 滤镜对象
	   */
	  serializeFilter: function (filters) {
	    var _filters = Object.assign({}, {
	      hueRotate: filters.hueRotate || 0,
	      saturate: filters.saturate === undefined ? 1 : filters.saturate,
	      brightness: filters.brightness === undefined ? 1 : filters.brightness,
	      blur: filters.blur || 0,
	      contrast: filters.contrast === undefined ? 1 : filters.contrast,
	      grayscale: filters.grayscale || 0,
	      invert: filters.invert || 0,
	      sepia: filters.sepia || 0
	    });

	    return `hue-rotate(${_filters.hueRotate}deg) saturate(${_filters.saturate}) brightness(${_filters.brightness}) ` + `blur(${_filters.blur}px) contrast(${_filters.contrast}) grayscale(${_filters.grayscale}) invert(${_filters.invert}) sepia(${_filters.sepia})`;
	  },

	  /**
	   * 反序列化滤镜
	   * @param {*} str css滤镜字符串
	   */
	  parseFilter: function (str) {
	    var list = str.split(' ');
	    var filters = {
	      hueRotate: 0,
	      saturate: 1,
	      brightness: 1,
	      blur: 0,
	      contrast: 1,
	      grayscale: 0,
	      invert: 0,
	      sepia: 0
	    };
	    list.forEach(n => {
	      if (n.startsWith('hue-rotate')) {
	        // 色调
	        filters.hueRotate = parseFloat(n.substring(11, n.length - 4));
	      } else if (n.startsWith('saturate')) {
	        // 饱和度
	        filters.saturate = parseFloat(n.substring(9, n.length - 1));
	      } else if (n.startsWith('brightness')) {
	        // 亮度
	        filters.brightness = parseFloat(n.substring(11, n.length - 1));
	      } else if (n.startsWith('blur')) {
	        // 模糊
	        filters.blur = parseFloat(n.substring(5, n.length - 3));
	      } else if (n.startsWith('contrast')) {
	        // 对比度
	        filters.contrast = parseFloat(n.substring(9, n.length - 1));
	      } else if (n.startsWith('grayscale')) {
	        filters.grayscale = parseFloat(n.substring(10, n.length - 1));
	      } else if (n.startsWith('invert')) {
	        // 颜色反转
	        filters.invert = parseFloat(n.substring(7, n.length - 1));
	      } else if (n.startsWith('sepia')) {
	        // 复古
	        filters.sepia = parseFloat(n.substring(6, n.length - 1));
	      }
	    });
	    return filters;
	  }
	};

	var ID$4 = -1;
	/**
	 * 渲染器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} globe 
	 */

	function Renderer(globe) {
	  this.globe = globe;
	  this.id = `${this.constructor.name}${ID$4--}`;
	  this.camera = this.globe.camera;
	  this.renderer = this.globe.renderer;
	  this.gl = this.renderer.getContext();
	}

	Renderer.prototype.render = function (layer) {};

	Renderer.prototype.dispose = function () {
	  delete this.camera;
	  delete this.render;
	  delete this.gl;
	  delete this.globe;
	};

	var BackgroundVertex = "precision highp float;\r\nprecision highp int;\r\n\r\nuniform mat4 modelMatrix;\r\nuniform mat4 modelViewMatrix;\r\nuniform mat4 projectionMatrix;\r\n\r\nattribute vec3 position;\r\n\r\nvarying vec3 vWorldDirection;\r\n\r\nvec3 transformDirection(in vec3 dir, in mat4 matrix) {\r\n    return normalize((matrix * vec4(dir, 0.0)).xyz);\r\n}\r\n\r\nvoid main() {\r\n    vWorldDirection = transformDirection(position, modelMatrix);\r\n    \r\n    vec3 transformed = vec3(position);\r\n    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);\r\n    gl_Position = projectionMatrix * mvPosition;\r\n\tgl_Position.z = gl_Position.w;\r\n}";

	var BackgroundFragment = "precision highp float;\r\nprecision highp int;\r\n\r\nuniform samplerCube tCube;\r\nuniform float tFlip;\r\n\r\nvarying vec3 vWorldDirection;\r\n\r\nvoid main() {\r\n\tgl_FragColor = textureCube(tCube, vec3(tFlip * vWorldDirection.x, vWorldDirection.yz));\r\n}";

	/**
	 * 背景渲染器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} globe 
	 */

	function BackgroundRenderer(globe) {
	  Renderer.call(this, globe);
	  this.program = null;
	  this.attributes = {};
	  this.uniforms = {};
	  this.buffers = {};
	  this.texture = null;
	  this.indexCount = 0;
	  this.modelMatrix = new THREE.Matrix4();
	  this.initProgram();
	  this.initBuffers();
	  this.initTextures();
	}

	BackgroundRenderer.prototype = Object.create(Renderer.prototype);
	BackgroundRenderer.prototype.constructor = BackgroundRenderer;

	BackgroundRenderer.prototype.initProgram = function () {
	  var gl = this.gl; // 顶点着色器

	  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	  gl.shaderSource(vertexShader, BackgroundVertex);
	  gl.compileShader(vertexShader);

	  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
	    console.warn(gl.getShaderInfoLog(vertexShader));
	    gl.deleteShader(vertexShader);
	    return;
	  } // 片源着色器


	  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	  gl.shaderSource(fragmentShader, BackgroundFragment);
	  gl.compileShader(fragmentShader);

	  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
	    console.warn(gl.getShaderInfoLog(fragmentShader));
	    gl.deleteShader(fragmentShader);
	    return;
	  } // 着色器程序


	  var program = gl.createProgram();
	  gl.attachShader(program, vertexShader);
	  gl.attachShader(program, fragmentShader);
	  gl.linkProgram(program);

	  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
	    console.warn("Could not initialise shaders");
	    gl.deleteProgram(program);
	    return;
	  } // 使用着色器程序


	  gl.useProgram(program);
	  this.program = program; // 获取attributes和uniform信息

	  Object.assign(this.attributes, {
	    position: gl.getAttribLocation(program, 'position')
	  });
	  Object.assign(this.uniforms, {
	    modelMatrix: gl.getUniformLocation(program, 'modelMatrix'),
	    modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
	    projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
	    tCube: gl.getUniformLocation(program, 'tCube'),
	    tFlip: gl.getUniformLocation(program, 'tFlip')
	  });
	};

	BackgroundRenderer.prototype.initBuffers = function () {
	  var gl = this.gl;
	  var geometry = new THREE.BoxBufferGeometry(1, 1, 1);
	  var attributes = geometry.attributes;
	  this.indexCount = geometry.index.count;
	  var positionBuffer = gl.createBuffer();
	  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
	  gl.bufferData(gl.ARRAY_BUFFER, attributes.position.array, gl.STATIC_DRAW);
	  var indexBuffer = gl.createBuffer();
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
	  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geometry.index.array, gl.STATIC_DRAW);
	  Object.assign(this.buffers, {
	    position: positionBuffer,
	    index: indexBuffer
	  });
	};

	BackgroundRenderer.prototype.initTextures = function () {
	  var gl = this.gl;
	  var urls = ['assets/textures/MilkyWay/dark-s_px.jpg', 'assets/textures/MilkyWay/dark-s_nx.jpg', 'assets/textures/MilkyWay/dark-s_py.jpg', 'assets/textures/MilkyWay/dark-s_ny.jpg', 'assets/textures/MilkyWay/dark-s_pz.jpg', 'assets/textures/MilkyWay/dark-s_nz.jpg']; // 创建立方体纹理

	  var texture = gl.createTexture();
	  gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
	  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
	  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	  gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	  var promises = urls.map(n => {
	    return this.createImage(n);
	  });
	  Promise.all(promises).then(imgs => {
	    gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
	    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, imgs[0]);
	    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, imgs[1]);
	    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, imgs[2]);
	    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, imgs[3]);
	    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, imgs[4]);
	    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, imgs[5]);
	    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	    this.texture = texture;
	  });
	};

	BackgroundRenderer.prototype.createImage = function (url) {
	  var img = document.createElement('img');
	  img.src = url;
	  return new Promise(resolve => {
	    img.onload = () => {
	      img.onload = null;
	      resolve(img);
	    };
	  });
	};

	BackgroundRenderer.prototype.render = function () {
	  var modelViewMatrix = new THREE.Matrix4();
	  return function () {
	    if (!this.texture) {
	      return;
	    }

	    var gl = this.gl;
	    var camera = this.camera;
	    this.modelMatrix.copyPosition(this.camera.matrixWorld);
	    gl.useProgram(this.program);
	    gl.enable(gl.CULL_FACE);
	    gl.cullFace(gl.FRONT);
	    gl.frontFace(gl.CCW);
	    gl.disable(gl.DEPTH_TEST);
	    modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.modelMatrix);
	    gl.uniformMatrix4fv(this.uniforms.modelMatrix, false, this.modelMatrix.elements);
	    gl.uniformMatrix4fv(this.uniforms.modelViewMatrix, false, modelViewMatrix.elements);
	    gl.uniformMatrix4fv(this.uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
	    gl.uniform1f(this.uniforms.tFlip, -1);
	    gl.activeTexture(gl.TEXTURE0);
	    gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
	    gl.uniform1i(this.uniforms.tCube, 0);
	    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.position);
	    gl.enableVertexAttribArray(this.attributes.position);
	    gl.vertexAttribPointer(this.attributes.position, 3, gl.FLOAT, false, 0, 0);
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffers.index);
	    gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
	    gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
	    gl.bindBuffer(gl.ARRAY_BUFFER, null);
	    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	  };
	}();

	BackgroundRenderer.prototype.dispose = function () {
	  this.gl.deleteProgram(this.program);
	  this.program = null;
	  this.attributes = {};
	  this.uniforms = {};
	  Object.values(this.buffers).forEach(n => {
	    this.gl.deleteBuffer(n);
	  });
	  this.buffers = {};
	  Renderer.prototype.dispose.call(this);
	};

	var SunVertex = "precision highp float;\r\nprecision highp int;\r\n\r\nuniform mat4 modelViewMatrix;\r\nuniform mat4 projectionMatrix;\r\n\r\nuniform vec3 sunPosition;\r\n\r\nattribute vec3 position;\r\nattribute vec2 uv;\r\n\r\nvarying vec2 vUV;\r\n\r\nvec3 applyMatrix4(vec3 v, mat4 m) {\r\n    float x = v.x;\r\n    float y = v.y;\r\n    float z = v.z;\r\n    \r\n    float w = 1.0 / ( m[0][3] * x + m[1][3] * y + m[2][3] * z + m[3][3] );\r\n\r\n    return vec3(\r\n        (m[0][0] * x + m[1][0] * y + m[2][0] * z + m[3][0]) * w,\r\n        (m[0][1] * x + m[1][1] * y + m[2][1] * z + m[3][1]) * w,\r\n        (m[0][2] * x + m[1][2] * y + m[2][2] * z + m[3][2] ) * w\r\n    );\r\n}\r\n\r\nvoid main() {\r\n    vec3 screenPos = applyMatrix4(applyMatrix4(sunPosition, modelViewMatrix), projectionMatrix);\r\n\r\n    gl_Position = vec4(\r\n        screenPos.x + position.x,\r\n        screenPos.y + position.y,\r\n        screenPos.z + position.z,\r\n        1.0\r\n    );\r\n\r\n    vUV = uv;\r\n}";

	var SunFragment = "precision highp float;\r\nprecision highp int;\r\n\r\nuniform sampler2D map;\r\n\r\nvarying vec2 vUV;\r\n\r\nvoid main() {\r\n    gl_FragColor = texture2D(map, vUV);\r\n}";

	/**
	 * WGS84
	 * @author tengge / https://github.com/tengge1
	 * @see https://zhidao.baidu.com/question/535863620.html
	 */
	var WGS84 = {
	  // 长半轴
	  a: 6378137,
	  // 短半轴
	  b: 6356752.3142,
	  // 扁率
	  alpha: 1 / 298.2572236,
	  // 第一偏心率平方 = (a**2 - b**2) / a**2
	  e2_1: 0.00669437999013,
	  // 第二偏心率平方 = (a**2 - b**2) / b**2
	  e2_2: 0.006739496742227
	};

	/**
	 * 太阳渲染器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} globe 
	 */

	function SunRenderer(globe) {
	  Renderer.call(this, globe);
	  this.program = null;
	  this.attributes = {};
	  this.uniforms = {};
	  this.buffers = {};
	  this.texture = null;
	  this.indexCount = 0;
	  this.initProgram();
	  this.initBuffers();
	  this.initTextures();
	}

	SunRenderer.prototype = Object.create(Renderer.prototype);
	SunRenderer.prototype.constructor = SunRenderer;

	SunRenderer.prototype.initProgram = function () {
	  var gl = this.gl; // 顶点着色器

	  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	  gl.shaderSource(vertexShader, SunVertex);
	  gl.compileShader(vertexShader);

	  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
	    console.warn(gl.getShaderInfoLog(vertexShader));
	    gl.deleteShader(vertexShader);
	    return;
	  } // 片源着色器


	  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	  gl.shaderSource(fragmentShader, SunFragment);
	  gl.compileShader(fragmentShader);

	  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
	    console.warn(gl.getShaderInfoLog(fragmentShader));
	    gl.deleteShader(fragmentShader);
	    return;
	  } // 着色器程序


	  var program = gl.createProgram();
	  gl.attachShader(program, vertexShader);
	  gl.attachShader(program, fragmentShader);
	  gl.linkProgram(program);

	  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
	    console.warn("Could not initialise shaders");
	    gl.deleteProgram(program);
	    return;
	  } // 使用着色器程序


	  gl.useProgram(program);
	  this.program = program; // 获取attributes和uniform信息

	  Object.assign(this.attributes, {
	    position: gl.getAttribLocation(program, 'position'),
	    uv: gl.getAttribLocation(program, 'uv')
	  });
	  Object.assign(this.uniforms, {
	    modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
	    projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
	    sunPosition: gl.getUniformLocation(program, 'sunPosition'),
	    map: gl.getUniformLocation(program, 'map')
	  });
	};

	SunRenderer.prototype.initBuffers = function () {
	  var gl = this.gl;
	  var geometry = new THREE.PlaneBufferGeometry(0.4, 0.4);
	  var attributes = geometry.attributes;
	  this.indexCount = geometry.index.count;
	  var positionBuffer = gl.createBuffer();
	  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
	  gl.bufferData(gl.ARRAY_BUFFER, attributes.position.array, gl.STATIC_DRAW);
	  var uvBuffer = gl.createBuffer();
	  gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
	  gl.bufferData(gl.ARRAY_BUFFER, attributes.uv.array, gl.STATIC_DRAW);
	  var indexBuffer = gl.createBuffer();
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
	  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geometry.index.array, gl.STATIC_DRAW);
	  Object.assign(this.buffers, {
	    position: positionBuffer,
	    uv: uvBuffer,
	    index: indexBuffer
	  });
	};

	SunRenderer.prototype.initTextures = function () {
	  var gl = this.gl;
	  var texture = gl.createTexture();
	  gl.bindTexture(gl.TEXTURE_2D, texture);
	  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	  var img = document.createElement('img');

	  img.onload = () => {
	    img.onload = null;
	    gl.bindTexture(gl.TEXTURE_2D, texture);
	    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
	    this.texture = texture;
	  };

	  img.src = 'assets/textures/lensflare/lensflare0_alpha.png';
	};

	SunRenderer.prototype.render = function () {
	  if (!this.texture) {
	    return;
	  }

	  var gl = this.gl;
	  var camera = this.camera;
	  gl.useProgram(this.program);
	  gl.disable(gl.CULL_FACE);
	  gl.cullFace(gl.FRONT);
	  gl.frontFace(gl.CCW);
	  gl.enable(gl.DEPTH_TEST);
	  gl.enable(gl.BLEND);
	  gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
	  gl.uniformMatrix4fv(this.uniforms.modelViewMatrix, false, camera.matrixWorldInverse.elements);
	  gl.uniformMatrix4fv(this.uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
	  gl.uniform3f(this.uniforms.sunPosition, this.globe.sunPosition.x, this.globe.sunPosition.y, this.globe.sunPosition.z);
	  gl.activeTexture(gl.TEXTURE0);
	  gl.bindTexture(gl.TEXTURE_2D, this.texture);
	  gl.uniform1i(this.uniforms.map, 0);
	  gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.position);
	  gl.enableVertexAttribArray(this.attributes.position);
	  gl.vertexAttribPointer(this.attributes.position, 3, gl.FLOAT, false, 0, 0);
	  gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.uv);
	  gl.enableVertexAttribArray(this.attributes.uv);
	  gl.vertexAttribPointer(this.attributes.uv, 2, gl.FLOAT, false, 0, 0);
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffers.index);
	  gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
	  gl.bindTexture(gl.TEXTURE_2D, null);
	  gl.bindBuffer(gl.ARRAY_BUFFER, null);
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	};

	SunRenderer.prototype.dispose = function () {
	  this.gl.deleteProgram(this.program);
	  this.program = null;
	  this.attributes = {};
	  this.uniforms = {};
	  Object.values(this.buffers).forEach(n => {
	    this.gl.deleteBuffer(n);
	  });
	  this.buffers = {};
	  Renderer.prototype.dispose.call(this);
	};

	/**
	 * 瓦片创建者
	 * @author tengge / https://github.com/tengge1
	 * @param {*} globe 
	 */
	function TileCreator(globe) {
	  this.globe = globe;
	  this.options = this.globe.options;
	  this.camera = this.globe.camera;
	  this.renderer = this.globe.renderer;
	}

	TileCreator.prototype.get = function (lon, lat, alt) {
	  return [];
	};

	TileCreator.prototype.dispose = function () {
	  delete this.globe;
	  delete this.options;
	  delete this.camera;
	  delete this.renderer;
	};

	const RADIAN_PER_DEGREE = Math.PI / 180;
	const DEGREE_PER_RADIAN = 180 / Math.PI;

	/**
	 * 经纬度、海拔转笛卡尔坐标
	 * 坐标系：
	 * 原点：地心
	 * x轴：经度0，纬度0
	 * y轴：指向北极
	 * z轴：西经90，纬度0
	 * @param {THREE.Vector3} lonlat 经纬度（弧度）、海拔
	 * @param {THREE.Vector3} xyz 笛卡尔坐标
	 */

	function _lonlatToXYZ(lonlat, xyz) {
	  var lon = lonlat.x;
	  var lat = lonlat.y;
	  var r = WGS84.a + (lonlat.z || 0);

	  if (xyz === undefined) {
	    xyz = new THREE.Vector3();
	  } // 可用THREE.Vector3.prototype.setFromSphericalCoords实现？


	  return xyz.set(r * Math.cos(lat) * Math.cos(lon), r * Math.sin(lat), -r * Math.cos(lat) * Math.sin(lon));
	}
	/**
	 * 经纬度、海拔转笛卡尔坐标
	 * @param {THREE.Vector3} lonlat 经纬度（角度）、海拔
	 * @param {THREE.Vector3} xyz 笛卡尔坐标
	 */


	function lonlatToXYZ(lonlat, xyz) {
	  if (xyz === undefined) {
	    xyz = new THREE.Vector3();
	  }

	  xyz.set(lonlat.x * RADIAN_PER_DEGREE, lonlat.y * RADIAN_PER_DEGREE, lonlat.z);
	  return _lonlatToXYZ(xyz, xyz);
	}
	/**
	 * 笛卡尔坐标转经纬度（弧度）、海拔
	 * @param {THREE.Vector3} xyz 笛卡尔坐标
	 * @param {THREE.Vector3} lonlat 经纬度（弧度）、海拔
	 */


	function _xyzToLonlat(xyz, lonlat) {
	  var lon = -Math.sign(xyz.z) * Math.acos(xyz.x / Math.sqrt(xyz.x ** 2 + xyz.z ** 2));
	  var lat = Math.atan(xyz.y / Math.sqrt(xyz.x ** 2 + xyz.z ** 2));
	  var alt = Math.sqrt(xyz.x ** 2 + xyz.y ** 2 + xyz.z ** 2) - WGS84.a;

	  if (lonlat === undefined) {
	    lonlat = new THREE.Vector3();
	  }

	  return lonlat.set(lon, lat, alt);
	}
	/**
	 * 笛卡尔坐标转经纬度（角度）、海拔
	 * @param {THREE.Vector3} xyz 笛卡尔坐标
	 * @param {THREE.Vector3} lonlat 经纬度（角度）、海拔
	 */


	function xyzToLonlat(xyz, lonlat) {
	  if (lonlat === undefined) {
	    lonlat = new THREE.Vector3();
	  }

	  _xyzToLonlat(xyz, lonlat);

	  lonlat.x *= DEGREE_PER_RADIAN;
	  lonlat.y *= DEGREE_PER_RADIAN;
	  return lonlat;
	}
	/**
	 * 层级转海拔
	 * @param {Number} zoom 层级
	 */


	function zoomToAlt(zoom) {
	  return 7820683 / 2 ** (zoom - 3);
	}
	/**
	 * 海拔转层级
	 * @param {Number} alt 海拔
	 */


	function altToZoom(alt) {
	  return Math.log2(7820683 / alt) + 3;
	}
	/**
	 * 墨卡托投影（弧度）
	 * @param {Number} lat 纬度（弧度）
	 * @see https://github.com/d3/d3-geo/blob/master/src/projection/mercator.js
	 */


	function _mercatorLat(lat) {
	  return Math.log(Math.tan((Math.PI / 2 + lat) / 2));
	}
	/**
	 * 墨卡托投影（角度）
	 * @param {Number} lat 纬度（角度）
	 * @see https://github.com/d3/d3-geo/blob/master/src/projection/mercator.js
	 */


	function mercatorLat(lat) {
	  return _mercatorLat(lat * RADIAN_PER_DEGREE) * DEGREE_PER_RADIAN;
	}
	/**
	 * 墨卡托投影反算（弧度）
	 * @param {Number} y 墨卡托投影Y坐标
	 * @see https://github.com/d3/d3-geo/blob/master/src/projection/mercator.js
	 */


	function _mercatorLatInvert(y) {
	  return 2 * Math.atan(Math.exp(y)) - Math.PI / 2;
	}
	/**
	 * 墨卡托投影反算（角度）
	 * @param {Number} y 墨卡托投影Y坐标
	 * @see https://github.com/d3/d3-geo/blob/master/src/projection/mercator.js
	 */


	function mercatorLatInvert(y) {
	  return _mercatorLatInvert(y) * DEGREE_PER_RADIAN;
	}
	/**
	 * 计算两个经纬度之间距离(弧度)
	 * @param {*} lon1 经度1(弧度)
	 * @param {*} lat1 纬度1(弧度)
	 * @param {*} lon2 经度2(弧度)
	 * @param {*} lat2 纬度2(弧度)
	 * @see https://www.xuebuyuan.com/2173606.html
	 */


	function _getDistance(lon1, lat1, lon2, lat2) {
	  return 2 * 6378137 * Math.asin(Math.sqrt(Math.pow(Math.sin((lat1 - lat2) / 2), 2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin((lon1 - lon2) / 2), 2)));
	}
	/**
	 * 计算两个经纬度之间距离(角度)
	 * @param {*} lon1 经度1(角度)
	 * @param {*} lat1 纬度1(角度)
	 * @param {*} lon2 经度2(角度)
	 * @param {*} lat2 纬度2(角度)
	 * @see https://www.xuebuyuan.com/2173606.html
	 */


	function getDistance(lon1, lat1, lon2, lat2) {
	  lon1 *= RADIAN_PER_DEGREE;
	  lat1 *= RADIAN_PER_DEGREE;
	  lon2 *= RADIAN_PER_DEGREE;
	  lat2 *= RADIAN_PER_DEGREE;
	  return _getDistance(lon1, lat1, lon2, lat2);
	}
	/**
	 * 数学工具
	 * @author tengge / https://github.com/tengge1
	 */


	var GeoUtils = {
	  // 经纬度海拔转笛卡尔坐标
	  _lonlatToXYZ,
	  lonlatToXYZ,
	  // 笛卡尔坐标转经纬度海拔
	  _xyzToLonlat,
	  xyzToLonlat,
	  // 层级转海拔
	  zoomToAlt,
	  // 海拔转层级
	  altToZoom,
	  // 墨卡托投影
	  _mercatorLat,
	  mercatorLat,
	  // 墨卡托投影反算
	  _mercatorLatInvert,
	  mercatorLatInvert,
	  // 计算两个经纬度之间距离
	  _getDistance,
	  getDistance
	};

	/**
	 * 瓦片
	 * @author tengge / https://github.com/tengge1
	 * @param {*} x 
	 * @param {*} y 
	 * @param {*} z 
	 */

	function Tile(x = 0, y = 0, z = 0) {
	  this.x = x;
	  this.y = y;
	  this.z = z;
	  this.images = [];
	  this._aabb = this._getBox(x, y, z);
	  this._center = this._getCenter(this._aabb);
	}
	/**
	 * 获取包围盒
	 * @param {*} x 
	 * @param {*} y 
	 * @param {*} z 
	 */


	Tile.prototype._getBox = function (x, y, z) {
	  var size = Math.PI * 2 / 2 ** z;
	  var minX = -Math.PI + size * x;
	  var maxX = minX + size;
	  var maxY = Math.PI - size * y;
	  var minY = maxY - size;
	  minY = GeoUtils._mercatorLatInvert(minY);
	  maxY = GeoUtils._mercatorLatInvert(maxY);
	  return new THREE.Box2(new THREE.Vector2(minX, minY), new THREE.Vector2(maxX, maxY));
	};
	/**
	 * 获取中心点
	 * @param {*} aabb 
	 */


	Tile.prototype._getCenter = function (aabb) {
	  var center = new THREE.Vector2();
	  return aabb.getCenter(center);
	};

	/**
	 * 球形瓦片创建者
	 * @author tengge / https://github.com/tengge1
	 * @param {*} globe 
	 */

	function SphereTileCreator(globe) {
	  TileCreator.call(this, globe);
	  this.cache = new Map();
	  this._centerZoom = 0;
	}

	SphereTileCreator.prototype = Object.create(TileCreator.prototype);
	SphereTileCreator.prototype.constructor = SphereTileCreator;

	SphereTileCreator.prototype.get = function (tiles) {
	  tiles.length = 0;
	  this._centerZoom = ~~GeoUtils.altToZoom(this.camera.position.length() - WGS84.a);
	  this.fork(0, 0, 1, tiles);
	  this.fork(1, 0, 1, tiles);
	  this.fork(0, 1, 1, tiles);
	  this.fork(1, 1, 1, tiles); // 排序

	  tiles = tiles.sort((a, b) => {
	    if (a.z > b.z) {
	      return 1;
	    } else if (a.z < b.z) {
	      return -1;
	    } else {
	      return 0;
	    }
	  }); // 获取图层数据

	  tiles.forEach(tile => {
	    tile.images.length = 0;

	    this.globe._layers.forEach(n => {
	      var image = n.get(tile.x, tile.y, tile.z);

	      if (image) {
	        tile.images.push(image);
	      }
	    });
	  });
	  return tiles;
	};
	/**
	 * 从1层级进行四分，返回满足要求的瓦片
	 * @param {*} x 
	 * @param {*} y 
	 * @param {*} z 
	 * @param {*} tiles 
	 */


	SphereTileCreator.prototype.fork = function (x, y, z, tiles) {
	  var tile = this.getTile(x, y, z); // if (z > 20) { // 最大20层级
	  //     return;
	  // }

	  if (!this.isVisible(tile)) {
	    return;
	  }

	  tiles.push(tile);

	  if (tile.z > this._centerZoom) {
	    return;
	  }

	  this.fork(x * 2, y * 2, z + 1, tiles);
	  this.fork(x * 2 + 1, y * 2, z + 1, tiles);
	  this.fork(x * 2, y * 2 + 1, z + 1, tiles);
	  this.fork(x * 2 + 1, y * 2 + 1, z + 1, tiles);
	};
	/**
	 * 获取一个瓦片
	 * @param {*} x 
	 * @param {*} y 
	 * @param {*} z 
	 */


	SphereTileCreator.prototype.getTile = function (x, y, z) {
	  var id = `${x}_${y}_${z}`;
	  var tile = this.cache.get(id);

	  if (!tile) {
	    tile = new Tile(x, y, z);
	    this.cache.set(id, tile);
	  }

	  return tile;
	};
	/**
	 * 判断瓦片是否可见：
	 * 1、材质上的底图已经下载完；
	 * 2、当前视锥与该瓦片的包围盒相交。
	 * @param {*} tile 
	 */


	SphereTileCreator.prototype.isVisible = function (tile) {
	  return this.globe.viewer.aabb.intersectsBox(tile._aabb);
	};

	SphereTileCreator.prototype.dispose = function () {
	  this.cache.clear();
	  TileCreator.prototype.dispose.call(this);
	};

	var TiledVertex = "precision highp float;\r\n\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec2 uv;\r\n\r\nuniform mat4 modelMatrix;\r\nuniform mat4 viewMatrix;\r\nuniform mat4 projectionMatrix;\r\n\r\nuniform int x;\r\nuniform int y;\r\nuniform int z;\r\n\r\nvarying vec3 vNormal;\r\nvarying vec2 vUV;\r\n\r\n// 必应地图参数，纬度180是85.05112878的墨卡托投影\r\n#define EARTH_RADIUS 6378137.0\r\n#define MIN_LATITUDE -180.0\r\n#define MAX_LATITUDE 180.0\r\n#define MIN_LONGITUDE -180.0\r\n#define MAX_LONGITUDE 180.0\r\n#define PI 3.141592653589793\r\n\r\nvoid main() {\r\n    // 每个瓦片位置\r\n    float size = pow(2.0, float(z));\r\n    float dlon = (MAX_LONGITUDE - MIN_LONGITUDE) / size;\r\n    float dlat = (MAX_LATITUDE - MIN_LATITUDE) / size;\r\n\r\n    float left = MIN_LONGITUDE + dlon * float(x);\r\n    float top = MAX_LATITUDE - dlat * float(y);\r\n    float right = left + dlon;\r\n    float bottom = top - dlat;\r\n\r\n    // 瓦片上每个小格位置\r\n    // +0.5的原因是：position范围是-0.5到0.5\r\n    float lon = left + (right - left) * (0.5 + position.x);\r\n    float lat = top - (top - bottom) * (0.5 + position.y);\r\n\r\n    lon = lon * PI / 180.0;\r\n    lat = lat * PI / 180.0;\r\n\r\n    // 墨卡托投影反算\r\n    lat = 2.0 * atan(exp(lat)) - PI / 2.0;\r\n\r\n    vec3 transformed = vec3(\r\n        EARTH_RADIUS * cos(lat) * cos(lon),\r\n        EARTH_RADIUS * sin(lat),\r\n        -EARTH_RADIUS * cos(lat) * sin(lon)\r\n    );\r\n\r\n    gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(transformed, 1.0);\r\n\r\n    vNormal = normal;\r\n    vUV = uv;\r\n}";

	var TiledFragment = "precision highp float;\r\n\r\nuniform sampler2D map;\r\n\r\nvarying vec2 vUV;\r\n\r\nvoid main() {\r\n    gl_FragColor = texture2D(map, vUV);\r\n}";

	/**
	 * 瓦片图层渲染器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} globe 
	 */

	function TiledLayerRenderer(globe) {
	  Renderer.call(this, globe);
	  this.creator = new SphereTileCreator(this.globe);
	  this.geometry = new THREE.PlaneBufferGeometry(1, 1, 16, 16);
	  this.modelMatrix = new THREE.Matrix4();
	  this.program = null;
	  this.attributes = {};
	  this.uniforms = {};
	  this.buffers = {};
	  this.tiles = [];
	  this.initProgram();
	  this.initBuffers();
	}

	TiledLayerRenderer.prototype = Object.create(Renderer.prototype);
	TiledLayerRenderer.prototype.constructor = TiledLayerRenderer;

	TiledLayerRenderer.prototype.initProgram = function () {
	  var gl = this.gl; // 顶点着色器

	  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	  gl.shaderSource(vertexShader, TiledVertex);
	  gl.compileShader(vertexShader);

	  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
	    console.warn(gl.getShaderInfoLog(vertexShader));
	    gl.deleteShader(vertexShader);
	    return;
	  } // 片源着色器


	  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	  gl.shaderSource(fragmentShader, TiledFragment);
	  gl.compileShader(fragmentShader);

	  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
	    console.warn(gl.getShaderInfoLog(fragmentShader));
	    gl.deleteShader(fragmentShader);
	    return;
	  } // 着色器程序


	  var program = gl.createProgram();
	  gl.attachShader(program, vertexShader);
	  gl.attachShader(program, fragmentShader);
	  gl.linkProgram(program);

	  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
	    console.warn("Could not initialise shaders");
	    gl.deleteProgram(program);
	    return;
	  } // 使用着色器程序


	  gl.useProgram(program);
	  this.program = program; // 获取attributes和uniform信息

	  Object.assign(this.attributes, {
	    position: gl.getAttribLocation(program, 'position'),
	    normal: gl.getAttribLocation(program, 'normal'),
	    uv: gl.getAttribLocation(program, 'uv')
	  });
	  Object.assign(this.uniforms, {
	    modelMatrix: gl.getUniformLocation(program, 'modelMatrix'),
	    viewMatrix: gl.getUniformLocation(program, 'viewMatrix'),
	    projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix'),
	    x: gl.getUniformLocation(program, 'x'),
	    y: gl.getUniformLocation(program, 'y'),
	    z: gl.getUniformLocation(program, 'z'),
	    map: gl.getUniformLocation(program, 'map')
	  });
	};

	TiledLayerRenderer.prototype.initBuffers = function () {
	  var gl = this.gl;
	  var geometry = this.geometry;
	  var attributes = geometry.attributes;
	  var positionBuffer = gl.createBuffer();
	  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
	  gl.bufferData(gl.ARRAY_BUFFER, attributes.position.array, gl.STATIC_DRAW);
	  var normalBuffer = gl.createBuffer();
	  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
	  gl.bufferData(gl.ARRAY_BUFFER, attributes.normal.array, gl.STATIC_DRAW);
	  var uvBuffer = gl.createBuffer();
	  gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
	  gl.bufferData(gl.ARRAY_BUFFER, attributes.uv.array, gl.STATIC_DRAW);
	  var indexBuffer = gl.createBuffer();
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
	  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geometry.index.array, gl.STATIC_DRAW);
	  Object.assign(this.buffers, {
	    position: positionBuffer,
	    normal: normalBuffer,
	    uv: uvBuffer,
	    index: indexBuffer
	  });
	};

	TiledLayerRenderer.prototype.render = function () {
	  this.creator.get(this.tiles);
	  this.renderMesh();
	  this.renderer.state.reset();
	};

	TiledLayerRenderer.prototype.renderMesh = function () {
	  var gl = this.gl;
	  var camera = this.camera;
	  gl.useProgram(this.program);
	  gl.enable(gl.CULL_FACE);
	  gl.cullFace(gl.BACK);
	  gl.frontFace(gl.CW);
	  gl.enable(gl.DEPTH_TEST); // gl.depthFunc(gl.LEQUAL);
	  // gl.depthMask(true);

	  gl.disable(gl.BLEND);
	  gl.uniformMatrix4fv(this.uniforms.modelMatrix, false, this.modelMatrix.elements);
	  gl.uniformMatrix4fv(this.uniforms.viewMatrix, false, camera.matrixWorldInverse.elements);
	  gl.uniformMatrix4fv(this.uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
	  gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.position);
	  gl.enableVertexAttribArray(this.attributes.position);
	  gl.vertexAttribPointer(this.attributes.position, 3, gl.FLOAT, false, 0, 0);
	  gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.normal);
	  gl.enableVertexAttribArray(this.attributes.normal);
	  gl.vertexAttribPointer(this.attributes.normal, 3, gl.FLOAT, false, 0, 0);
	  gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.uv);
	  gl.enableVertexAttribArray(this.attributes.uv);
	  gl.vertexAttribPointer(this.attributes.uv, 2, gl.FLOAT, false, 0, 0);
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffers.index); // x, y, z

	  this.tiles.forEach(tile => {
	    tile.images.forEach(n => {
	      gl.uniform1i(this.uniforms.x, n._x);
	      gl.uniform1i(this.uniforms.y, n._y);
	      gl.uniform1i(this.uniforms.z, n._z);

	      if (!n.texture) {
	        var texture = gl.createTexture();
	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, texture);
	        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, n);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	        n.texture = texture;
	      }

	      gl.activeTexture(gl.TEXTURE0);
	      gl.bindTexture(gl.TEXTURE_2D, n.texture);
	      gl.uniform1i(this.uniforms.map, 0);
	      gl.drawElements(gl.TRIANGLES, this.geometry.index.count, gl.UNSIGNED_SHORT, 0);
	    });
	  });
	  gl.bindBuffer(gl.ARRAY_BUFFER, null);
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	  gl.bindTexture(gl.TEXTURE_2D, null);
	};

	TiledLayerRenderer.prototype.dispose = function () {
	  this.gl.deleteProgram(this.program);
	  this.program = null;
	  this.attributes = {};
	  this.uniforms = {};
	  Object.values(this.buffers).forEach(n => {
	    this.gl.deleteBuffer(n);
	  });
	  this.buffers = {};
	  this.creator.dispose();
	  Renderer.prototype.dispose.call(this);
	};

	var AtmosphereVertex = "attribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec3 uv;\r\n\r\nuniform mat4 modelViewMatrix;\r\nuniform mat4 projectionMatrix;\r\n\r\nvarying vec4 vTransformed;\r\nvarying vec3 vNormal;\r\nvarying vec3 vUV; \r\n\r\nvoid main()\r\n{\r\n    vec4 transformed =  modelViewMatrix * vec4(position, 1.0);\r\n\r\n    gl_Position = projectionMatrix * transformed;\r\n\r\n    vTransformed = transformed;\r\n    vNormal = normal;\r\n    vUV = uv;\r\n}";

	var AtmosphereFragment = "precision highp float;\r\n\r\nvarying vec4 vTransformed;\r\n\r\n// three.js生成的球体半径是0.5，所以要除以2\r\n#define HALF_EARTH_RADIUS 3189068.5\r\n\r\nvoid main() \r\n{\r\n    float r = sqrt(vTransformed.x * vTransformed.x + vTransformed.y * vTransformed.y);\r\n\r\n    if(r < HALF_EARTH_RADIUS) {\r\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n    } else {\r\n        float rate = (r - HALF_EARTH_RADIUS) / (HALF_EARTH_RADIUS * 1.02);\r\n        //float red = smoothstep(0.0, 1.0, rate);\r\n        //float opacity = smoothstep(1.0, 0.0, rate);\r\n        gl_FragColor = vec4(1.0, 1.0, 1.0, 0.4);\r\n    }\r\n}";

	/**
	 * 大气层渲染器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} globe 
	 */

	function AtmosphereRenderer(globe) {
	  Renderer.call(this, globe);
	  this.program = null;
	  this.attributes = {};
	  this.uniforms = {};
	  this.buffers = {};
	  this.indexCount = 0;
	  this.initProgram();
	  this.initBuffers();
	}

	AtmosphereRenderer.prototype = Object.create(Renderer.prototype);
	AtmosphereRenderer.prototype.constructor = AtmosphereRenderer;

	AtmosphereRenderer.prototype.initProgram = function () {
	  var gl = this.gl; // 顶点着色器

	  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	  gl.shaderSource(vertexShader, AtmosphereVertex);
	  gl.compileShader(vertexShader);

	  if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
	    console.warn(gl.getShaderInfoLog(vertexShader));
	    gl.deleteShader(vertexShader);
	    return;
	  } // 片源着色器


	  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	  gl.shaderSource(fragmentShader, AtmosphereFragment);
	  gl.compileShader(fragmentShader);

	  if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
	    console.warn(gl.getShaderInfoLog(fragmentShader));
	    gl.deleteShader(fragmentShader);
	    return;
	  } // 着色器程序


	  var program = gl.createProgram();
	  gl.attachShader(program, vertexShader);
	  gl.attachShader(program, fragmentShader);
	  gl.linkProgram(program);

	  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
	    console.warn("Could not initialise shaders");
	    gl.deleteProgram(program);
	    return;
	  } // 使用着色器程序


	  gl.useProgram(program);
	  this.program = program; // 获取attributes和uniform信息

	  Object.assign(this.attributes, {
	    position: gl.getAttribLocation(program, 'position'),
	    normal: gl.getAttribLocation(program, 'normal'),
	    uv: gl.getAttribLocation(program, 'uv')
	  });
	  Object.assign(this.uniforms, {
	    modelViewMatrix: gl.getUniformLocation(program, 'modelViewMatrix'),
	    projectionMatrix: gl.getUniformLocation(program, 'projectionMatrix')
	  });
	};

	AtmosphereRenderer.prototype.initBuffers = function () {
	  var gl = this.gl;
	  var geometry = new THREE.SphereBufferGeometry(WGS84.a * 1.02, 32, 32);
	  var attributes = geometry.attributes;
	  this.indexCount = geometry.index.count;
	  var positionBuffer = gl.createBuffer();
	  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
	  gl.bufferData(gl.ARRAY_BUFFER, attributes.position.array, gl.STATIC_DRAW);
	  var normalBuffer = gl.createBuffer();
	  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
	  gl.bufferData(gl.ARRAY_BUFFER, attributes.normal.array, gl.STATIC_DRAW);
	  var uvBuffer = gl.createBuffer();
	  gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
	  gl.bufferData(gl.ARRAY_BUFFER, attributes.uv.array, gl.STATIC_DRAW);
	  var indexBuffer = gl.createBuffer();
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
	  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geometry.index.array, gl.STATIC_DRAW);
	  Object.assign(this.buffers, {
	    position: positionBuffer,
	    normal: normalBuffer,
	    uv: uvBuffer,
	    index: indexBuffer
	  });
	};

	AtmosphereRenderer.prototype.render = function () {
	  var gl = this.gl;
	  var camera = this.camera;
	  gl.useProgram(this.program);
	  gl.enable(gl.CULL_FACE);
	  gl.cullFace(gl.BACK);
	  gl.frontFace(gl.CCW);
	  gl.enable(gl.DEPTH_TEST);
	  gl.enable(gl.BLEND);
	  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	  gl.uniformMatrix4fv(this.uniforms.modelViewMatrix, false, camera.matrixWorldInverse.elements);
	  gl.uniformMatrix4fv(this.uniforms.projectionMatrix, false, camera.projectionMatrix.elements);
	  gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.position);
	  gl.enableVertexAttribArray(this.attributes.position);
	  gl.vertexAttribPointer(this.attributes.position, 3, gl.FLOAT, false, 0, 0);
	  gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.normal);
	  gl.enableVertexAttribArray(this.attributes.normal);
	  gl.vertexAttribPointer(this.attributes.normal, 3, gl.FLOAT, false, 0, 0);
	  gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.uv);
	  gl.enableVertexAttribArray(this.attributes.uv);
	  gl.vertexAttribPointer(this.attributes.uv, 2, gl.FLOAT, false, 0, 0);
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffers.index);
	  gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
	  gl.bindBuffer(gl.ARRAY_BUFFER, null);
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	};

	AtmosphereRenderer.prototype.dispose = function () {
	  this.gl.deleteProgram(this.program);
	  this.program = null;
	  this.attributes = {};
	  this.uniforms = {};
	  Object.values(this.buffers).forEach(n => {
	    this.gl.deleteBuffer(n);
	  });
	  this.buffers = {};
	  Renderer.prototype.dispose.call(this);
	};

	/**
	 * 所有渲染器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} globe 
	 */

	function Renderers(globe) {
	  Renderer.call(this, globe);
	  this.renderers = [new BackgroundRenderer(this.globe), new SunRenderer(this.globe), new TiledLayerRenderer(this.globe)];
	}

	Renderers.prototype = Object.create(Renderer.prototype);
	Renderers.prototype.constructor = Renderers;

	Renderers.prototype.render = function () {
	  this.renderers.forEach(n => {
	    n.render();
	  });
	};

	Renderers.prototype.dispose = function () {
	  this.renderers.forEach(n => {
	    n.dispose();
	  });
	  this.renderers.length = 0;
	  Renderer.prototype.dispose.call(this);
	};

	var ID$5 = -1;
	/**
	 * 查看器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} camera 相机
	 * @param {*} domElement 文档
	 */

	function Viewer(camera, domElement) {
	  this.camera = camera;
	  this.domElement = domElement;
	  this.id = `${this.constructor.name}${ID$5--}`;
	  this.oldFar = this.camera.far;
	  this.camera.far = 20576957;
	  this.camera.updateProjectionMatrix();
	}

	Viewer.prototype.update = function () {};

	Viewer.prototype.dispose = function () {
	  this.camera.far = this.oldFar;
	  this.camera.updateProjectionMatrix();
	  delete this.oldFar;
	  delete this.camera;
	  delete this.domElement;
	};

	/**
	 * 轨道查看器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} camera 相机
	 * @param {*} domElement 文档
	 * @description 鼠标的旋转和缩放操作，都应该转换为对相机的操作
	 */

	function OrbitViewer(camera, domElement) {
	  Viewer.call(this, camera, domElement); // 碰撞判断

	  this.isDown = false;
	  this.isPan = false;
	  this.sphere = new THREE.Sphere(undefined, WGS84.a);
	  this.intersectPoint = new THREE.Vector3(); // 碰撞点
	  // 视场

	  this.aabb = new THREE.Box2(new THREE.Vector2(-Math.PI, -Math.PI / 2), new THREE.Vector2(Math.PI, Math.PI / 2)); // 动画参数

	  this.rotationSpeed = new THREE.Vector3(); // 事件绑定

	  this.onMouseDown = this.onMouseDown.bind(this);
	  this.onMouseMove = this.onMouseMove.bind(this);
	  this.onMouseUp = this.onMouseUp.bind(this);
	  this.onMouseWheel = this.onMouseWheel.bind(this);
	  this.domElement.addEventListener('mousedown', this.onMouseDown);
	  this.domElement.addEventListener('mousemove', this.onMouseMove);
	  document.body.addEventListener('mouseup', this.onMouseUp);
	  this.domElement.addEventListener('mousewheel', this.onMouseWheel); // 初始化

	  this._updateAABB();
	}
	OrbitViewer.prototype = Object.create(Viewer.prototype);
	OrbitViewer.prototype.constructor = OrbitViewer;

	OrbitViewer.prototype.onMouseDown = function (event) {
	  this.isDown = true;
	  this.isPan = false;
	};

	OrbitViewer.prototype.onMouseMove = function () {
	  // 计算碰撞
	  var lastIntersectPoint = new THREE.Vector3(); // 计算旋转

	  var unit1 = new THREE.Vector3();
	  var unit2 = new THREE.Vector3(); // 旋转校正

	  var yAxis = new THREE.Vector3(0, 1, 0);
	  var minAngle = 30 * Math.PI / 180;
	  var maxAngle = 150 * Math.PI / 180;
	  var axis = new THREE.Vector3();
	  var startTime = 0;
	  var endTime = 0;
	  var quat = new THREE.Quaternion();
	  var dir1 = new THREE.Vector3();
	  var dir2 = new THREE.Vector3();
	  return function (event) {
	    if (!this.isDown) {
	      return;
	    } // 1. 按下鼠标，第一次拖动


	    if (!this.isPan) {
	      if (!this.intersectSphere(event.offsetX, event.offsetY, this.intersectPoint)) {
	        // 鼠标在地球外
	        return;
	      }

	      this.isPan = true;
	      lastIntersectPoint.copy(this.intersectPoint);
	      startTime = new Date().getTime();
	      return;
	    } // 2. 后续的拖动


	    if (!this.intersectSphere(event.offsetX, event.offsetY, this.intersectPoint)) {
	      // 鼠标在地球外
	      return;
	    } // 3. 计算碰撞点相对于地心旋转


	    unit1.copy(lastIntersectPoint).normalize();
	    unit2.copy(this.intersectPoint).normalize();
	    quat.setFromUnitVectors(unit2, unit1); // 4. 计算相机相对于地心旋转

	    var distance = this.camera.position.length();
	    dir1.copy(this.camera.position).normalize();
	    dir2.copy(dir1);
	    dir2.applyQuaternion(quat).normalize(); // 5. 限制dir与y轴的夹角

	    var angle = dir2.angleTo(yAxis);

	    if (angle && Math.abs(angle) < minAngle) {
	      axis.crossVectors(dir2, yAxis);
	      axis.normalize();
	      dir2.copy(yAxis);
	      dir2.applyAxisAngle(axis, -minAngle);
	    }

	    if (angle && Math.abs(angle) > maxAngle) {
	      axis.crossVectors(dir2, yAxis);
	      axis.normalize();
	      dir2.copy(yAxis);
	      dir2.applyAxisAngle(axis, -maxAngle);
	    } // 6. 校正碰撞点


	    quat.setFromUnitVectors(dir2, dir1);
	    unit2.copy(unit1);
	    unit2.applyQuaternion(quat);
	    this.intersectPoint.copy(unit2).multiplyScalar(WGS84.a); // 7. 计算相机位置和旋转

	    this.camera.position.copy(dir2).multiplyScalar(distance);
	    this.camera.lookAt(this.sphere.center); // 8. 计算旋转速度

	    endTime = new Date().getTime(); // if (endTime > startTime) {
	    //     this.rotationSpeed.subVectors(endLonLat, startLonLat)
	    //         .multiplyScalar(endTime - startTime);
	    // }
	    // 9. 更新旧碰撞点

	    lastIntersectPoint.copy(this.intersectPoint);
	  };
	}();

	OrbitViewer.prototype.onMouseUp = function (event) {
	  this.isDown = false;
	  this.isPan = false;

	  this._updateAABB();
	};

	OrbitViewer.prototype.onMouseWheel = function () {
	  var dir = new THREE.Vector3();
	  return function (event) {
	    var delta = -event.wheelDelta;
	    var distance = dir.copy(this.camera.position).length();
	    dir.copy(this.camera.position).normalize();

	    if (distance < WGS84.a) {
	      distance = WGS84.a;
	    }

	    var d = delta * (distance - WGS84.a) / 1000;
	    var d_1 = GeoUtils.zoomToAlt(2) + WGS84.a;

	    if (distance + d >= d_1) {
	      // 最远2层级距离
	      d = 0;
	    }

	    var d_2 = GeoUtils.zoomToAlt(18) + WGS84.a;

	    if (distance + d <= d_2) {
	      // 最近18层级
	      d = 0;
	    }

	    this.camera.position.set(this.camera.position.x + d * dir.x, this.camera.position.y + d * dir.y, this.camera.position.z + d * dir.z);

	    this._updateAABB();
	  };
	}();
	/**
	 * 计算屏幕坐标与地球表面交点
	 * @param {float} x 屏幕坐标X
	 * @param {float} y 屏幕坐标Y
	 * @param {THREE.Vector3} intersectPoint 计算出的碰撞点
	 */


	OrbitViewer.prototype.intersectSphere = function () {
	  var projectionMatrixInverse = new THREE.Matrix4();
	  var matrixWorld = new THREE.Matrix4();
	  var ray = new THREE.Ray();
	  return function (x, y, intersectPoint) {
	    if (!this.isPan) {
	      // 只在鼠标按下时，计算一次矩阵的原因是：1、提高性能 2、避免由于浮点数问题抖动。
	      projectionMatrixInverse.getInverse(this.camera.projectionMatrix);
	      matrixWorld.copy(this.camera.matrixWorld);
	    }

	    ray.origin.set(x / this.domElement.clientWidth * 2 - 1, -y / this.domElement.clientHeight * 2 + 1, 0.1);
	    ray.direction.copy(ray.origin);
	    ray.direction.z = 1;
	    ray.origin.applyMatrix4(projectionMatrixInverse).applyMatrix4(matrixWorld);
	    ray.direction.applyMatrix4(projectionMatrixInverse).applyMatrix4(matrixWorld).sub(ray.origin).normalize();
	    return ray.intersectSphere(this.sphere, intersectPoint);
	  };
	}();
	/**
	 * 计算当前视锥内的经纬度范围
	 */


	OrbitViewer.prototype._updateAABB = function () {
	  var min = new THREE.Vector3();
	  var max = new THREE.Vector3();
	  return function () {
	    if (!this.intersectSphere(0, this.domElement.clientHeight, min)) {
	      // 未发生碰撞
	      this.aabb.min.set(-Math.PI, -Math.PI / 2);
	      this.aabb.max.set(Math.PI, Math.PI / 2);
	      return;
	    }

	    this.intersectSphere(this.domElement.clientWidth, 0, max);

	    GeoUtils._xyzToLonlat(min, min);

	    GeoUtils._xyzToLonlat(max, max);

	    this.aabb.min.copy(min);
	    this.aabb.max.copy(max);
	  };
	}();

	OrbitViewer.prototype.setPosition = function (lon, lat, alt) {
	  var xyz = GeoUtils.lonlatToXYZ(new THREE.Vector3(lon, lat, alt));
	  this.camera.position.copy(xyz);
	  this.camera.lookAt(new THREE.Vector3());
	};

	OrbitViewer.prototype.getPosition = function () {};

	OrbitViewer.prototype.update = function () {
	  var lonlat = new THREE.Vector3();
	  return function () {// if (this.isPan) {
	    //     return;
	    // }
	    // if (this.rotationSpeed.x === 0 && this.rotationSpeed.y === 0) {
	    //     return;
	    // }
	    // GeoUtils.xyzToLonlat(this.camera.position, lonlat);
	    // lonlat.add(this.rotationSpeed);
	    // if (this.rotationSpeed.x > 0) {
	    //     this.rotationSpeed.x -= 1;
	    //     if (this.rotationSpeed.x < 1) {
	    //         this.rotationSpeed.x = 0;
	    //     }
	    // } else if (this.rotationSpeed.x < 0) {
	    //     this.rotationSpeed.x += 0.01;
	    //     if (this.rotationSpeed.x > -0.01) {
	    //         this.rotationSpeed.x = 0;
	    //     }
	    // }
	    // if (this.rotationSpeed.y > 0) {
	    //     this.rotationSpeed.y -= 0.01;
	    //     if (this.rotationSpeed.y < 0.01) {
	    //         this.rotationSpeed.y = 0;
	    //     }
	    // } else if (this.rotationSpeed.y < 0) {
	    //     this.rotationSpeed.y += 0.01;
	    //     if (this.rotationSpeed.y > -0.01) {
	    //         this.rotationSpeed.y = 0;
	    //     }
	    // }
	    // GeoUtils.lonlatToXYZ(lonlat, this.camera.position);
	    // this.camera.lookAt(this.sphere.center);
	  };
	}();

	OrbitViewer.prototype.dispose = function () {
	  this.domElement.removeEventListener('mousedown', this.onMouseDown);
	  this.domElement.removeEventListener('mousemove', this.onMouseMove);
	  document.body.removeEventListener('mouseup', this.onMouseUp);
	  this.domElement.removeEventListener('mousewheel', this.onMouseWheel);
	  Viewer.prototype.dispose.call(this);
	};

	var ID$6 = -1;
	/**
	 * 图层
	 * @author tengge / https://github.com/tengge1
	 * @param {*} globe 
	 */

	function Layer(globe) {
	  this.globe = globe;
	  this.id = `${this.constructor.name}${ID$6--}`;
	  this.name = this.constructor.name;
	}
	/**
	 * 获取某个经纬度范围内的资源
	 * @param {THREE.Box2} aabb 
	 */


	Layer.prototype.get = function (aabb) {};
	/**
	 * 释放该图层所有资源
	 */


	Layer.prototype.dispose = function () {
	  delete this.globe;
	};

	/**
	 * 图片图层
	 * @author tengge / https://github.com/tengge1
	 * @param {*} globe 
	 */

	function ImageLayer(globe) {
	  Layer.call(this, globe);
	}

	ImageLayer.prototype = Object.create(Layer.prototype);
	ImageLayer.prototype.constructor = ImageLayer;

	/**
	 * 瓦片缓存
	 */
	function TileCache() {
	  this.cache = new Map();
	}

	TileCache.prototype.get = function (x, y, z) {
	  var cache = this.cache.get(z);

	  if (!cache) {
	    return cache;
	  }

	  cache = cache.get(y);

	  if (!cache) {
	    return cache;
	  }

	  return cache.get(x);
	};

	TileCache.prototype.set = function (x, y, z, data) {
	  var zcache = this.cache.get(z);

	  if (!zcache) {
	    zcache = new Map();
	    this.cache.set(z, zcache);
	  }

	  var ycache = zcache.get(y);

	  if (!ycache) {
	    ycache = new Map();
	    zcache.set(y, ycache);
	  }

	  ycache.set(x, data);
	};

	TileCache.prototype.clear = function () {
	  this.cache.clear();
	};

	/**
	 * 图片瓦片图层
	 * @author tengge / https://github.com/tengge1
	 * @param {*} globe 
	 */

	function TiledImageLayer(globe) {
	  ImageLayer.call(this, globe);
	  this.cache = new TileCache();
	}

	TiledImageLayer.prototype = Object.create(ImageLayer.prototype);
	TiledImageLayer.prototype.constructor = TiledImageLayer;
	/**
	 * 由子类实现，返回下载图片的url
	 * @param {*} x 
	 * @param {*} y 
	 * @param {*} z 
	 */

	TiledImageLayer.prototype.getUrl = function (x, y, z) {
	  return null;
	};
	/**
	 * 获取图片数据
	 * @param {*} x 
	 * @param {*} y 
	 * @param {*} z 
	 */


	TiledImageLayer.prototype.get = function (x, y, z) {
	  var img = this.cache.get(x, y, z);

	  if (img && img.loaded) {
	    return img;
	  }

	  if (img && (img.loading || img.error)) {
	    return null;
	  }

	  if (this.globe.thread < this.globe.options.maxThread) {
	    this._createImage(x, y, z);
	  }

	  return null;
	};

	TiledImageLayer.prototype._createImage = function (x, y, z) {
	  var url = this.getUrl(x, y, z);

	  if (!url) {
	    console.warn(`TiledImageLayer: url is not defined.`);
	    return null;
	  }

	  var img = document.createElement('img');
	  img._x = x;
	  img._y = y;
	  img._z = z;
	  img.crossOrigin = 'anonymous';
	  img.loading = true;
	  this.cache.set(x, y, z, img);

	  img.onload = () => {
	    img.onload = null;
	    img.onerror = null;
	    img.loaded = true;
	    delete img.loading; // 避免下载过程中，切换地图，导致报错。

	    if (this.globe) {
	      this.globe.thread--;
	    }
	  };

	  img.onerror = () => {
	    img.onload = null;
	    img.onerror = null;
	    img.error = true;
	    delete img.loading;

	    if (this.globe) {
	      this.globe.thread--;
	    }
	  };

	  img.src = url;
	  this.globe.thread++;
	};

	/**
	 * 谷歌瓦片图层
	 * @author tengge / https://github.com/tengge1
	 * @param {*} globe 
	 */

	function GoogleTiledLayer(globe) {
	  TiledImageLayer.call(this, globe);
	  this.name = 'google';
	}

	GoogleTiledLayer.prototype = Object.create(TiledImageLayer.prototype);
	GoogleTiledLayer.prototype.constructor = GoogleTiledLayer;

	GoogleTiledLayer.prototype.getUrl = function (x, y, z) {
	  return `http://www.google.cn/maps/vt?lyrs=s@821&gl=cn&x=${x}&y=${y}&z=${z}`;
	};

	/**
	 * 天地图瓦片图层
	 * @author tengge / https://github.com/tengge1
	 * @param {*} globe 
	 */

	function TiandituTiledLayer(globe) {
	  TiledImageLayer.call(this, globe);
	  this.name = 'tianditu';
	}

	TiandituTiledLayer.prototype = Object.create(TiledImageLayer.prototype);
	TiandituTiledLayer.prototype.constructor = TiandituTiledLayer;

	TiandituTiledLayer.prototype.getUrl = function (x, y, z) {
	  return `http://t6.tianditu.gov.cn/DataServer?T=img_w&x=${x}&y=${y}&l=${z}&tk=85a57b38db5ed01efb7e999f6b097746`;
	};

	/**
	 * 必应瓦片图层
	 * @author tengge / https://github.com/tengge1
	 * @param {*} globe 
	 */

	function BingTiledLayer(globe) {
	  TiledImageLayer.call(this, globe);
	  this.name = 'bing';
	}

	BingTiledLayer.prototype = Object.create(TiledImageLayer.prototype);
	BingTiledLayer.prototype.constructor = BingTiledLayer;

	BingTiledLayer.prototype.getUrl = function (x, y, z) {
	  return `http://t0.ssl.ak.tiles.virtualearth.net/tiles/a${this.tileXYToQuadKey(x, y, z)}.jpeg?g=5793`;
	};
	/**
	 * Converts tile XY coordinates into a QuadKey at a specified level of detail.
	 * @param {*} tileX Tile X coordinate.
	 * @param {*} tileY Tile Y coordinate.
	 * @param {*} levelOfDetail evel of detail, from 1 (lowest detail) to 23 (highest detail).
	 * @see https://docs.microsoft.com/en-us/bingmaps/articles/bing-maps-tile-system
	 */


	BingTiledLayer.prototype.tileXYToQuadKey = function (tileX, tileY, levelOfDetail) {
	  let quadKey = '';
	  let digit;
	  let mask;

	  for (let i = levelOfDetail; i > 0; i--) {
	    digit = '0';
	    mask = 1 << i - 1;

	    if ((tileX & mask) != 0) {
	      digit++;
	    }

	    if ((tileY & mask) != 0) {
	      digit++;
	      digit++;
	    }

	    quadKey += digit;
	  }

	  return quadKey;
	};

	/**
	 * 地球
	 * @author tengge / https://github.com/tengge1
	 * @param {THREE.PerspectiveCamera} camera 相机
	 * @param {THREE.WebGLRenderer} renderer 渲染器
	 * @param {Object} options 配置
	 * @param {String} options.server 服务端配置
	 * @param {Boolean} options.useCameraPosition 是否使用相机位置
	 * @param {Number} options.maxThread 最大工作线程数，避免任务创建过多，导致地图卡顿
	 */

	function Globe(camera, renderer, options = {}) {
	  THREE.Object3D.call(this);
	  options.server = options.server || location.origin;
	  options.useCameraPosition = options.useCameraPosition || false;
	  options.maxThread = options.maxThread || 10;
	  this.name = _t('Globe');
	  Object.assign(this.userData, {
	    type: 'Globe',
	    background: 'google'
	  });
	  this.camera = camera;
	  this.renderer = renderer;
	  this.options = options;
	  this.thread = 0; // 当前线程总数

	  this.matrixAutoUpdate = false;
	  this.time = new Date();
	  this.timeZone = this.time.getTimezoneOffset() / 60; // minutes

	  this.sunPosition = new THREE.Vector3(); // 不能命名为layers，否则跟three.js的layers冲突

	  this._layers = [new GoogleTiledLayer(this)];
	  this.renderers = new Renderers(this);
	  this.viewer = new OrbitViewer(this.camera, this.renderer.domElement); // 如果不使用相机位置，则设置默认中心点

	  if (!this.options.useCameraPosition) {
	    this.viewer.setPosition(0, 0, GeoUtils.zoomToAlt(2));
	  }
	}

	Globe.prototype = Object.create(THREE.Object3D.prototype);
	Globe.prototype.constructor = Globe;
	/**
	 * 设置背景
	 * @param {*} type 背景类型，支持google、tianditu、bing
	 */

	Globe.prototype.setBackground = function (type) {
	  var newLayerName = 'google';

	  switch (type) {
	    case 'bing':
	      newLayerName = 'bing';
	      break;

	    case 'tianditu':
	      newLayerName = 'tianditu';
	      break;

	    default:
	      newLayerName = 'google';
	      break;
	  }

	  var layer = this._layers[0];

	  if (newLayerName === layer.name) {
	    return;
	  }

	  this.userData.background = newLayerName;
	  var newLayer = null;

	  switch (newLayerName) {
	    case 'google':
	      newLayer = new GoogleTiledLayer(this);
	      break;

	    case 'tianditu':
	      newLayer = new TiandituTiledLayer(this);
	      break;

	    case 'bing':
	      newLayer = new BingTiledLayer(this);
	      break;
	  }

	  this._layers[0] = newLayer;
	  layer.dispose();
	};

	Globe.prototype.getBackground = function () {
	  var layer = this._layers[0];
	  return layer.name;
	};
	/**
	 * 需要由应用程序连续调用
	 */


	Globe.prototype.update = function () {
	  this.time = new Date();
	  var hour = this.time.getHours() + this.timeZone;
	  var angle = Math.PI * 2 / 24 * hour;
	  var x = -WGS84.a * 10 * Math.cos(angle);
	  var z = WGS84.a * 10 * Math.sin(angle);
	  this.sunPosition.set(x, 0, z);
	  this.renderers.render();
	  this.viewer.update();
	};
	/**
	 * 光线投射
	 * @param {*} raycaster 
	 * @param {*} intersects 
	 */


	Globe.prototype.raycast = function () {
	  var geometry = new THREE.SphereBufferGeometry(WGS84.a, 32, 32);
	  var material = new THREE.MeshBasicMaterial();
	  var mesh = new THREE.Mesh(geometry, material);
	  return function (raycaster, intersects) {
	    return mesh.raycast(raycaster, intersects);
	  };
	}();
	/**
	 * 释放占用的所有资源
	 */


	Globe.prototype.dispose = function () {
	  this.renderers.dispose();
	  this.viewer.dispose();

	  this._layers.forEach(n => {
	    n.dispose();
	  });

	  delete this._layers;
	  delete this.renderers;
	  delete this.viewer;
	  delete this.camera;
	  delete this.renderer;
	};

	/**
	 * 播放器
	 * @author mrdoob / http://mrdoob.com/
	 * @author tengge / https://github.com/tengge1
	 * @param {HTMLElement} 容器
	 * @param {Object} options 配置信息
	 * @param {String} options.server 服务器信息，例如：http://localhost:2000
	 * @param {Boolean} options.enableThrowBall 是否允许扔小球进行物理测试
	 * @param {Boolean} options.showStats 是否显示性能控件
	 */

	function Player(container = document.body, options = {}) {
	  this.container = container;
	  this.options = options;
	  this.options.server = this.options.server || window.origin;
	  this.options.enableThrowBall = this.options.enableThrowBall || false;
	  this.options.showStats = this.options.showStats || false;
	  this.dispatch = new d3.dispatch(['init']);
	  this.call = this.dispatch.call.bind(this.dispatch);
	  this.on = this.dispatch.on.bind(this.dispatch); // 性能控件

	  if (this.options.showStats) {
	    this.stats = new Stats();
	    Object.assign(this.stats.dom.style, {
	      position: 'absolute',
	      left: '8px',
	      top: '8px',
	      zIndex: 'initial'
	    });
	    container.appendChild(this.stats.dom);
	  }

	  window.addEventListener('resize', this.onResize.bind(this));
	  var observer = new MutationObserver(this.onResize.bind(this));
	  observer.observe(this.container, {
	    attributes: true,
	    characterData: false,
	    childList: false
	  });
	  this.scene = null;
	  this.camera = null;
	  this.renderer = null;
	  this.gis = null;
	  this.package = new PackageManager();
	  this.require = this.package.require.bind(this.package);
	  this.loader = new PlayerLoader(this);
	  this.event = new PlayerEvent(this);
	  this.control = new PlayerControl(this);
	  this.audio = new PlayerAudio(this);
	  this.playerRenderer = new PlayerRenderer(this);
	  this.animation = new PlayerAnimation(this);
	  this.physics = new PlayerPhysics(this);
	  this.isPlaying = false;
	  this.clock = new THREE.Clock(false); // 保证播放器在不加载语言包的情况下正常运行

	  if (!window._t) {
	    window._t = function (data) {
	      return data;
	    };
	  }
	}
	/**
	 * 启动播放器
	 * @param {String} sceneData 场景数据
	 */

	Player.prototype.start = function (sceneData) {
	  if (typeof sceneData !== 'string') {
	    app.toast(_t('Scene data of string type is needed.'));
	    return;
	  }

	  var jsons;

	  try {
	    jsons = JSON.parse(sceneData);
	  } catch (e) {
	    app.toast(_t('Cannot deserialize scene data.'));
	    return;
	  }

	  if (this.isPlaying) {
	    return;
	  }

	  this.isPlaying = true;
	  this.container.style.display = 'block';
	  this.loader.create(jsons).then(obj => {
	    this.initPlayer(obj);
	    this.dispatch.call('init', this);
	    var promise1 = this.event.create(this.scene, this.camera, this.renderer, obj.scripts);
	    var promise2 = this.control.create(this.scene, this.camera, this.renderer);
	    var promise3 = this.audio.create(this.scene, this.camera, this.renderer);
	    var promise4 = this.playerRenderer.create(this.scene, this.camera, this.renderer);
	    var promise5 = this.animation.create(this.scene, this.camera, this.renderer, obj.animations);
	    var promise6 = this.physics.create(this.scene, this.camera, this.renderer);
	    Promise.all([promise1, promise2, promise3, promise4, promise5, promise6]).then(() => {
	      this.event.init();
	      this.clock.start();
	      this.event.start();
	    });
	    requestAnimationFrame(this.animate.bind(this));
	  });
	};
	/**
	 * 停止播放器
	 */


	Player.prototype.stop = function () {
	  if (!this.isPlaying) {
	    return;
	  }

	  this.isPlaying = false;
	  this.event.stop();
	  this.loader.dispose();
	  this.event.dispose();
	  this.control.dispose();
	  this.audio.dispose();
	  this.animation.dispose();
	  this.physics.dispose();

	  if (this.gis) {
	    this.gis.dispose();
	    this.gis = null;
	  }

	  this.playerRenderer.dispose();
	  this.container.removeChild(this.renderer.domElement);
	  this.container.style.display = 'none';
	  this.scene.children.length = 0;
	  this.scene = null;
	  this.camera = null;
	  this.renderer = null;
	  this.clock.stop();
	};
	/**
	 * 初始化播放器
	 * @param {*} obj 
	 */


	Player.prototype.initPlayer = function (obj) {
	  var container = this.container;
	  this.camera = obj.camera;

	  if (!this.camera) {
	    console.warn(`Player: Three is no camera in the scene.`);
	    this.camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
	  }

	  this.renderer = obj.renderer || new THREE.WebGLRenderer({
	    antialias: true
	  });
	  this.renderer.setSize(container.clientWidth, container.clientHeight);
	  container.appendChild(this.renderer.domElement);
	  this.camera.aspect = this.renderer.domElement.width / this.renderer.domElement.height;
	  this.camera.updateProjectionMatrix();
	  var listener = obj.audioListener || new THREE.AudioListener();
	  this.camera.add(listener);
	  this.renderer.domElement.style.filter = CssUtils.serializeFilter(obj.options);
	  this.scene = obj.scene || new THREE.Scene();

	  if (obj.options.sceneType === 'GIS') {
	    this.gis = new Globe(this.camera, this.renderer, Object.assign({}, obj.options, {
	      useCameraPosition: true
	    }));
	  } // 可视化
	  // if (obj.visual) {
	  //     this.visual.fromJSON(obj.visual);
	  // } else {
	  //     this.visual.clear();
	  // }
	  // this.visual.render(this.svg);

	};

	Player.prototype.animate = function () {
	  if (!this.isPlaying) {
	    return;
	  }

	  if (this.stats) {
	    this.stats.begin();
	  }

	  var deltaTime = this.clock.getDelta();
	  this.event.update(this.clock, deltaTime);
	  this.control.update(this.clock, deltaTime);
	  this.playerRenderer.update(this.clock, deltaTime);
	  this.animation.update(this.clock, deltaTime);
	  this.physics.update(this.clock, deltaTime);

	  if (this.gis) {
	    this.gis.update();
	  }

	  if (this.stats) {
	    this.stats.end();
	  }

	  requestAnimationFrame(this.animate.bind(this));
	};

	Player.prototype.resize = function () {
	  if (!this.camera || !this.renderer) {
	    return;
	  }

	  var width = this.container.clientWidth;
	  var height = this.container.clientHeight;
	  var camera = this.camera;
	  var renderer = this.renderer;
	  camera.aspect = width / height;
	  camera.updateProjectionMatrix();
	  renderer.domElement;
	  renderer.setSize(width, height);
	};

	Player.prototype.onResize = function (records) {
	  this.resize();
	};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var bind = createCommonjsModule(function (module) {
	/*!
	  Copyright (c) 2017 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */

	(function () {

		var hasOwn = {}.hasOwnProperty;

		function classNames () {
			var classes = [];

			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;

				var argType = typeof arg;

				if (argType === 'string' || argType === 'number') {
					classes.push(this && this[arg] || arg);
				} else if (Array.isArray(arg)) {
					classes.push(classNames.apply(this, arg));
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(this && this[key] || key);
						}
					}
				}
			}

			return classes.join(' ');
		}

		if (module.exports) {
			classNames.default = classNames;
			module.exports = classNames;
		} else {
			window.classNames = classNames;
		}
	}());
	});

	var reactIs_production_min = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports,"__esModule",{value:!0});
	var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?Symbol.for("react.memo"):
	60115,r=b?Symbol.for("react.lazy"):60116;function t(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case h:return a;default:return u}}case r:case q:case d:return u}}}function v(a){return t(a)===m}exports.typeOf=t;exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;
	exports.Fragment=e;exports.Lazy=r;exports.Memo=q;exports.Portal=d;exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||"object"===typeof a&&null!==a&&(a.$$typeof===r||a.$$typeof===q||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n)};exports.isAsyncMode=function(a){return v(a)||t(a)===l};exports.isConcurrentMode=v;exports.isContextConsumer=function(a){return t(a)===k};
	exports.isContextProvider=function(a){return t(a)===h};exports.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return t(a)===n};exports.isFragment=function(a){return t(a)===e};exports.isLazy=function(a){return t(a)===r};exports.isMemo=function(a){return t(a)===q};exports.isPortal=function(a){return t(a)===d};exports.isProfiler=function(a){return t(a)===g};exports.isStrictMode=function(a){return t(a)===f};
	exports.isSuspense=function(a){return t(a)===p};
	});

	unwrapExports(reactIs_production_min);
	var reactIs_production_min_1 = reactIs_production_min.typeOf;
	var reactIs_production_min_2 = reactIs_production_min.AsyncMode;
	var reactIs_production_min_3 = reactIs_production_min.ConcurrentMode;
	var reactIs_production_min_4 = reactIs_production_min.ContextConsumer;
	var reactIs_production_min_5 = reactIs_production_min.ContextProvider;
	var reactIs_production_min_6 = reactIs_production_min.Element;
	var reactIs_production_min_7 = reactIs_production_min.ForwardRef;
	var reactIs_production_min_8 = reactIs_production_min.Fragment;
	var reactIs_production_min_9 = reactIs_production_min.Lazy;
	var reactIs_production_min_10 = reactIs_production_min.Memo;
	var reactIs_production_min_11 = reactIs_production_min.Portal;
	var reactIs_production_min_12 = reactIs_production_min.Profiler;
	var reactIs_production_min_13 = reactIs_production_min.StrictMode;
	var reactIs_production_min_14 = reactIs_production_min.Suspense;
	var reactIs_production_min_15 = reactIs_production_min.isValidElementType;
	var reactIs_production_min_16 = reactIs_production_min.isAsyncMode;
	var reactIs_production_min_17 = reactIs_production_min.isConcurrentMode;
	var reactIs_production_min_18 = reactIs_production_min.isContextConsumer;
	var reactIs_production_min_19 = reactIs_production_min.isContextProvider;
	var reactIs_production_min_20 = reactIs_production_min.isElement;
	var reactIs_production_min_21 = reactIs_production_min.isForwardRef;
	var reactIs_production_min_22 = reactIs_production_min.isFragment;
	var reactIs_production_min_23 = reactIs_production_min.isLazy;
	var reactIs_production_min_24 = reactIs_production_min.isMemo;
	var reactIs_production_min_25 = reactIs_production_min.isPortal;
	var reactIs_production_min_26 = reactIs_production_min.isProfiler;
	var reactIs_production_min_27 = reactIs_production_min.isStrictMode;
	var reactIs_production_min_28 = reactIs_production_min.isSuspense;

	var reactIs_development = createCommonjsModule(function (module, exports) {



	{
	  (function() {

	Object.defineProperty(exports, '__esModule', { value: true });

	// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var hasSymbol = typeof Symbol === 'function' && Symbol.for;

	var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
	var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
	var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
	var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
	var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
	var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
	var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
	var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
	var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
	var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
	var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
	var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
	var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;

	function isValidElementType(type) {
	  return typeof type === 'string' || typeof type === 'function' ||
	  // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
	  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
	}

	/**
	 * Forked from fbjs/warning:
	 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
	 *
	 * Only change is we use console.warn instead of console.error,
	 * and do nothing when 'console' is not supported.
	 * This really simplifies the code.
	 * ---
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var lowPriorityWarning = function () {};

	{
	  var printWarning = function (format) {
	    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      args[_key - 1] = arguments[_key];
	    }

	    var argIndex = 0;
	    var message = 'Warning: ' + format.replace(/%s/g, function () {
	      return args[argIndex++];
	    });
	    if (typeof console !== 'undefined') {
	      console.warn(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };

	  lowPriorityWarning = function (condition, format) {
	    if (format === undefined) {
	      throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	    if (!condition) {
	      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	        args[_key2 - 2] = arguments[_key2];
	      }

	      printWarning.apply(undefined, [format].concat(args));
	    }
	  };
	}

	var lowPriorityWarning$1 = lowPriorityWarning;

	function typeOf(object) {
	  if (typeof object === 'object' && object !== null) {
	    var $$typeof = object.$$typeof;
	    switch ($$typeof) {
	      case REACT_ELEMENT_TYPE:
	        var type = object.type;

	        switch (type) {
	          case REACT_ASYNC_MODE_TYPE:
	          case REACT_CONCURRENT_MODE_TYPE:
	          case REACT_FRAGMENT_TYPE:
	          case REACT_PROFILER_TYPE:
	          case REACT_STRICT_MODE_TYPE:
	          case REACT_SUSPENSE_TYPE:
	            return type;
	          default:
	            var $$typeofType = type && type.$$typeof;

	            switch ($$typeofType) {
	              case REACT_CONTEXT_TYPE:
	              case REACT_FORWARD_REF_TYPE:
	              case REACT_PROVIDER_TYPE:
	                return $$typeofType;
	              default:
	                return $$typeof;
	            }
	        }
	      case REACT_LAZY_TYPE:
	      case REACT_MEMO_TYPE:
	      case REACT_PORTAL_TYPE:
	        return $$typeof;
	    }
	  }

	  return undefined;
	}

	// AsyncMode is deprecated along with isAsyncMode
	var AsyncMode = REACT_ASYNC_MODE_TYPE;
	var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
	var ContextConsumer = REACT_CONTEXT_TYPE;
	var ContextProvider = REACT_PROVIDER_TYPE;
	var Element = REACT_ELEMENT_TYPE;
	var ForwardRef = REACT_FORWARD_REF_TYPE;
	var Fragment = REACT_FRAGMENT_TYPE;
	var Lazy = REACT_LAZY_TYPE;
	var Memo = REACT_MEMO_TYPE;
	var Portal = REACT_PORTAL_TYPE;
	var Profiler = REACT_PROFILER_TYPE;
	var StrictMode = REACT_STRICT_MODE_TYPE;
	var Suspense = REACT_SUSPENSE_TYPE;

	var hasWarnedAboutDeprecatedIsAsyncMode = false;

	// AsyncMode should be deprecated
	function isAsyncMode(object) {
	  {
	    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
	      hasWarnedAboutDeprecatedIsAsyncMode = true;
	      lowPriorityWarning$1(false, 'The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
	    }
	  }
	  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
	}
	function isConcurrentMode(object) {
	  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
	}
	function isContextConsumer(object) {
	  return typeOf(object) === REACT_CONTEXT_TYPE;
	}
	function isContextProvider(object) {
	  return typeOf(object) === REACT_PROVIDER_TYPE;
	}
	function isElement(object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	}
	function isForwardRef(object) {
	  return typeOf(object) === REACT_FORWARD_REF_TYPE;
	}
	function isFragment(object) {
	  return typeOf(object) === REACT_FRAGMENT_TYPE;
	}
	function isLazy(object) {
	  return typeOf(object) === REACT_LAZY_TYPE;
	}
	function isMemo(object) {
	  return typeOf(object) === REACT_MEMO_TYPE;
	}
	function isPortal(object) {
	  return typeOf(object) === REACT_PORTAL_TYPE;
	}
	function isProfiler(object) {
	  return typeOf(object) === REACT_PROFILER_TYPE;
	}
	function isStrictMode(object) {
	  return typeOf(object) === REACT_STRICT_MODE_TYPE;
	}
	function isSuspense(object) {
	  return typeOf(object) === REACT_SUSPENSE_TYPE;
	}

	exports.typeOf = typeOf;
	exports.AsyncMode = AsyncMode;
	exports.ConcurrentMode = ConcurrentMode;
	exports.ContextConsumer = ContextConsumer;
	exports.ContextProvider = ContextProvider;
	exports.Element = Element;
	exports.ForwardRef = ForwardRef;
	exports.Fragment = Fragment;
	exports.Lazy = Lazy;
	exports.Memo = Memo;
	exports.Portal = Portal;
	exports.Profiler = Profiler;
	exports.StrictMode = StrictMode;
	exports.Suspense = Suspense;
	exports.isValidElementType = isValidElementType;
	exports.isAsyncMode = isAsyncMode;
	exports.isConcurrentMode = isConcurrentMode;
	exports.isContextConsumer = isContextConsumer;
	exports.isContextProvider = isContextProvider;
	exports.isElement = isElement;
	exports.isForwardRef = isForwardRef;
	exports.isFragment = isFragment;
	exports.isLazy = isLazy;
	exports.isMemo = isMemo;
	exports.isPortal = isPortal;
	exports.isProfiler = isProfiler;
	exports.isStrictMode = isStrictMode;
	exports.isSuspense = isSuspense;
	  })();
	}
	});

	unwrapExports(reactIs_development);
	var reactIs_development_1 = reactIs_development.typeOf;
	var reactIs_development_2 = reactIs_development.AsyncMode;
	var reactIs_development_3 = reactIs_development.ConcurrentMode;
	var reactIs_development_4 = reactIs_development.ContextConsumer;
	var reactIs_development_5 = reactIs_development.ContextProvider;
	var reactIs_development_6 = reactIs_development.Element;
	var reactIs_development_7 = reactIs_development.ForwardRef;
	var reactIs_development_8 = reactIs_development.Fragment;
	var reactIs_development_9 = reactIs_development.Lazy;
	var reactIs_development_10 = reactIs_development.Memo;
	var reactIs_development_11 = reactIs_development.Portal;
	var reactIs_development_12 = reactIs_development.Profiler;
	var reactIs_development_13 = reactIs_development.StrictMode;
	var reactIs_development_14 = reactIs_development.Suspense;
	var reactIs_development_15 = reactIs_development.isValidElementType;
	var reactIs_development_16 = reactIs_development.isAsyncMode;
	var reactIs_development_17 = reactIs_development.isConcurrentMode;
	var reactIs_development_18 = reactIs_development.isContextConsumer;
	var reactIs_development_19 = reactIs_development.isContextProvider;
	var reactIs_development_20 = reactIs_development.isElement;
	var reactIs_development_21 = reactIs_development.isForwardRef;
	var reactIs_development_22 = reactIs_development.isFragment;
	var reactIs_development_23 = reactIs_development.isLazy;
	var reactIs_development_24 = reactIs_development.isMemo;
	var reactIs_development_25 = reactIs_development.isPortal;
	var reactIs_development_26 = reactIs_development.isProfiler;
	var reactIs_development_27 = reactIs_development.isStrictMode;
	var reactIs_development_28 = reactIs_development.isSuspense;

	var reactIs = createCommonjsModule(function (module) {

	{
	  module.exports = reactIs_development;
	}
	});

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	var ReactPropTypesSecret_1 = ReactPropTypesSecret;

	var printWarning = function() {};

	{
	  var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
	  var loggedTypeFailures = {};
	  var has = Function.call.bind(Object.prototype.hasOwnProperty);

	  printWarning = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?Function} getStack Returns the component stack.
	 * @private
	 */
	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
	  {
	    for (var typeSpecName in typeSpecs) {
	      if (has(typeSpecs, typeSpecName)) {
	        var error;
	        // Prop type validation may throw. In case they do, we don't want to
	        // fail the render phase where it didn't fail before. So we log it.
	        // After these have been cleaned up, we'll let them throw.
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          if (typeof typeSpecs[typeSpecName] !== 'function') {
	            var err = Error(
	              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
	              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
	            );
	            err.name = 'Invariant Violation';
	            throw err;
	          }
	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error && !(error instanceof Error)) {
	          printWarning(
	            (componentName || 'React class') + ': type specification of ' +
	            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
	            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
	            'You may have forgotten to pass an argument to the type checker ' +
	            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
	            'shape all require an argument).'
	          );
	        }
	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	          // Only monitor this failure once because there tends to be a lot of the
	          // same error.
	          loggedTypeFailures[error.message] = true;

	          var stack = getStack ? getStack() : '';

	          printWarning(
	            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
	          );
	        }
	      }
	    }
	  }
	}

	/**
	 * Resets warning cache when testing.
	 *
	 * @private
	 */
	checkPropTypes.resetWarningCache = function() {
	  {
	    loggedTypeFailures = {};
	  }
	};

	var checkPropTypes_1 = checkPropTypes;

	var has$1 = Function.call.bind(Object.prototype.hasOwnProperty);
	var printWarning$1 = function() {};

	{
	  printWarning$1 = function(text) {
	    var message = 'Warning: ' + text;
	    if (typeof console !== 'undefined') {
	      console.error(message);
	    }
	    try {
	      // --- Welcome to debugging React ---
	      // This error was thrown as a convenience so that you can use this stack
	      // to find the callsite that caused this warning to fire.
	      throw new Error(message);
	    } catch (x) {}
	  };
	}

	function emptyFunctionThatReturnsNull() {
	  return null;
	}

	var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
	  /* global Symbol */
	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	  /**
	   * Returns the iterator method function contained on the iterable object.
	   *
	   * Be sure to invoke the function with the iterable as context:
	   *
	   *     var iteratorFn = getIteratorFn(myIterable);
	   *     if (iteratorFn) {
	   *       var iterator = iteratorFn.call(myIterable);
	   *       ...
	   *     }
	   *
	   * @param {?object} maybeIterable
	   * @return {?function}
	   */
	  function getIteratorFn(maybeIterable) {
	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  /**
	   * Collection of methods that allow declaration and validation of props that are
	   * supplied to React components. Example usage:
	   *
	   *   var Props = require('ReactPropTypes');
	   *   var MyArticle = React.createClass({
	   *     propTypes: {
	   *       // An optional string prop named "description".
	   *       description: Props.string,
	   *
	   *       // A required enum prop named "category".
	   *       category: Props.oneOf(['News','Photos']).isRequired,
	   *
	   *       // A prop named "dialog" that requires an instance of Dialog.
	   *       dialog: Props.instanceOf(Dialog).isRequired
	   *     },
	   *     render: function() { ... }
	   *   });
	   *
	   * A more formal specification of how these methods are used:
	   *
	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	   *   decl := ReactPropTypes.{type}(.isRequired)?
	   *
	   * Each and every declaration produces a function with the same signature. This
	   * allows the creation of custom validation functions. For example:
	   *
	   *  var MyLink = React.createClass({
	   *    propTypes: {
	   *      // An optional string or URI prop named "href".
	   *      href: function(props, propName, componentName) {
	   *        var propValue = props[propName];
	   *        if (propValue != null && typeof propValue !== 'string' &&
	   *            !(propValue instanceof URI)) {
	   *          return new Error(
	   *            'Expected a string or an URI for ' + propName + ' in ' +
	   *            componentName
	   *          );
	   *        }
	   *      }
	   *    },
	   *    render: function() {...}
	   *  });
	   *
	   * @internal
	   */

	  var ANONYMOUS = '<<anonymous>>';

	  // Important!
	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
	  var ReactPropTypes = {
	    array: createPrimitiveTypeChecker('array'),
	    bool: createPrimitiveTypeChecker('boolean'),
	    func: createPrimitiveTypeChecker('function'),
	    number: createPrimitiveTypeChecker('number'),
	    object: createPrimitiveTypeChecker('object'),
	    string: createPrimitiveTypeChecker('string'),
	    symbol: createPrimitiveTypeChecker('symbol'),

	    any: createAnyTypeChecker(),
	    arrayOf: createArrayOfTypeChecker,
	    element: createElementTypeChecker(),
	    elementType: createElementTypeTypeChecker(),
	    instanceOf: createInstanceTypeChecker,
	    node: createNodeChecker(),
	    objectOf: createObjectOfTypeChecker,
	    oneOf: createEnumTypeChecker,
	    oneOfType: createUnionTypeChecker,
	    shape: createShapeTypeChecker,
	    exact: createStrictShapeTypeChecker,
	  };

	  /**
	   * inlined Object.is polyfill to avoid requiring consumers ship their own
	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	   */
	  /*eslint-disable no-self-compare*/
	  function is(x, y) {
	    // SameValue algorithm
	    if (x === y) {
	      // Steps 1-5, 7-10
	      // Steps 6.b-6.e: +0 != -0
	      return x !== 0 || 1 / x === 1 / y;
	    } else {
	      // Step 6.a: NaN == NaN
	      return x !== x && y !== y;
	    }
	  }
	  /*eslint-enable no-self-compare*/

	  /**
	   * We use an Error-like object for backward compatibility as people may call
	   * PropTypes directly and inspect their output. However, we don't use real
	   * Errors anymore. We don't inspect their stack anyway, and creating them
	   * is prohibitively expensive if they are created too often, such as what
	   * happens in oneOfType() for any type before the one that matched.
	   */
	  function PropTypeError(message) {
	    this.message = message;
	    this.stack = '';
	  }
	  // Make `instanceof Error` still work for returned errors.
	  PropTypeError.prototype = Error.prototype;

	  function createChainableTypeChecker(validate) {
	    {
	      var manualPropTypeCallCache = {};
	      var manualPropTypeWarningCount = 0;
	    }
	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	      componentName = componentName || ANONYMOUS;
	      propFullName = propFullName || propName;

	      if (secret !== ReactPropTypesSecret_1) {
	        if (throwOnDirectAccess) {
	          // New behavior only for users of `prop-types` package
	          var err = new Error(
	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	            'Use `PropTypes.checkPropTypes()` to call them. ' +
	            'Read more at http://fb.me/use-check-prop-types'
	          );
	          err.name = 'Invariant Violation';
	          throw err;
	        } else if (typeof console !== 'undefined') {
	          // Old behavior for people using React.PropTypes
	          var cacheKey = componentName + ':' + propName;
	          if (
	            !manualPropTypeCallCache[cacheKey] &&
	            // Avoid spamming the console because they are often not actionable except for lib authors
	            manualPropTypeWarningCount < 3
	          ) {
	            printWarning$1(
	              'You are manually calling a React.PropTypes validation ' +
	              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
	              'and will throw in the standalone `prop-types` package. ' +
	              'You may be seeing this warning due to a third-party PropTypes ' +
	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
	            );
	            manualPropTypeCallCache[cacheKey] = true;
	            manualPropTypeWarningCount++;
	          }
	        }
	      }
	      if (props[propName] == null) {
	        if (isRequired) {
	          if (props[propName] === null) {
	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
	          }
	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
	        }
	        return null;
	      } else {
	        return validate(props, propName, componentName, location, propFullName);
	      }
	    }

	    var chainedCheckType = checkType.bind(null, false);
	    chainedCheckType.isRequired = checkType.bind(null, true);

	    return chainedCheckType;
	  }

	  function createPrimitiveTypeChecker(expectedType) {
	    function validate(props, propName, componentName, location, propFullName, secret) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== expectedType) {
	        // `propValue` being instance of, say, date/regexp, pass the 'object'
	        // check, but we can offer a more precise error message here rather than
	        // 'of type `object`'.
	        var preciseType = getPreciseType(propValue);

	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createAnyTypeChecker() {
	    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
	  }

	  function createArrayOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	      }
	      var propValue = props[propName];
	      if (!Array.isArray(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	      }
	      for (var i = 0; i < propValue.length; i++) {
	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!isValidElement(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createElementTypeTypeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      if (!reactIs.isValidElementType(propValue)) {
	        var propType = getPropType(propValue);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createInstanceTypeChecker(expectedClass) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!(props[propName] instanceof expectedClass)) {
	        var expectedClassName = expectedClass.name || ANONYMOUS;
	        var actualClassName = getClassName(props[propName]);
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createEnumTypeChecker(expectedValues) {
	    if (!Array.isArray(expectedValues)) {
	      {
	        if (arguments.length > 1) {
	          printWarning$1(
	            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
	            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
	          );
	        } else {
	          printWarning$1('Invalid argument supplied to oneOf, expected an array.');
	        }
	      }
	      return emptyFunctionThatReturnsNull;
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      for (var i = 0; i < expectedValues.length; i++) {
	        if (is(propValue, expectedValues[i])) {
	          return null;
	        }
	      }

	      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
	        var type = getPreciseType(value);
	        if (type === 'symbol') {
	          return String(value);
	        }
	        return value;
	      });
	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createObjectOfTypeChecker(typeChecker) {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (typeof typeChecker !== 'function') {
	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	      }
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	      }
	      for (var key in propValue) {
	        if (has$1(propValue, key)) {
	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
	          if (error instanceof Error) {
	            return error;
	          }
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createUnionTypeChecker(arrayOfTypeCheckers) {
	    if (!Array.isArray(arrayOfTypeCheckers)) {
	      printWarning$1('Invalid argument supplied to oneOfType, expected an instance of array.');
	      return emptyFunctionThatReturnsNull;
	    }

	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (typeof checker !== 'function') {
	        printWarning$1(
	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
	          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
	        );
	        return emptyFunctionThatReturnsNull;
	      }
	    }

	    function validate(props, propName, componentName, location, propFullName) {
	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	        var checker = arrayOfTypeCheckers[i];
	        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
	          return null;
	        }
	      }

	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createNodeChecker() {
	    function validate(props, propName, componentName, location, propFullName) {
	      if (!isNode(props[propName])) {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      for (var key in shapeTypes) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          continue;
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }
	    return createChainableTypeChecker(validate);
	  }

	  function createStrictShapeTypeChecker(shapeTypes) {
	    function validate(props, propName, componentName, location, propFullName) {
	      var propValue = props[propName];
	      var propType = getPropType(propValue);
	      if (propType !== 'object') {
	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	      }
	      // We need to check all keys in case some are required but missing from
	      // props.
	      var allKeys = objectAssign({}, props[propName], shapeTypes);
	      for (var key in allKeys) {
	        var checker = shapeTypes[key];
	        if (!checker) {
	          return new PropTypeError(
	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
	            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
	          );
	        }
	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
	        if (error) {
	          return error;
	        }
	      }
	      return null;
	    }

	    return createChainableTypeChecker(validate);
	  }

	  function isNode(propValue) {
	    switch (typeof propValue) {
	      case 'number':
	      case 'string':
	      case 'undefined':
	        return true;
	      case 'boolean':
	        return !propValue;
	      case 'object':
	        if (Array.isArray(propValue)) {
	          return propValue.every(isNode);
	        }
	        if (propValue === null || isValidElement(propValue)) {
	          return true;
	        }

	        var iteratorFn = getIteratorFn(propValue);
	        if (iteratorFn) {
	          var iterator = iteratorFn.call(propValue);
	          var step;
	          if (iteratorFn !== propValue.entries) {
	            while (!(step = iterator.next()).done) {
	              if (!isNode(step.value)) {
	                return false;
	              }
	            }
	          } else {
	            // Iterator will provide entry [k,v] tuples rather than values.
	            while (!(step = iterator.next()).done) {
	              var entry = step.value;
	              if (entry) {
	                if (!isNode(entry[1])) {
	                  return false;
	                }
	              }
	            }
	          }
	        } else {
	          return false;
	        }

	        return true;
	      default:
	        return false;
	    }
	  }

	  function isSymbol(propType, propValue) {
	    // Native Symbol.
	    if (propType === 'symbol') {
	      return true;
	    }

	    // falsy value can't be a Symbol
	    if (!propValue) {
	      return false;
	    }

	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	    if (propValue['@@toStringTag'] === 'Symbol') {
	      return true;
	    }

	    // Fallback for non-spec compliant Symbols which are polyfilled.
	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	      return true;
	    }

	    return false;
	  }

	  // Equivalent of `typeof` but with special handling for array and regexp.
	  function getPropType(propValue) {
	    var propType = typeof propValue;
	    if (Array.isArray(propValue)) {
	      return 'array';
	    }
	    if (propValue instanceof RegExp) {
	      // Old webkits (at least until Android 4.0) return 'function' rather than
	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	      // passes PropTypes.object.
	      return 'object';
	    }
	    if (isSymbol(propType, propValue)) {
	      return 'symbol';
	    }
	    return propType;
	  }

	  // This handles more types than `getPropType`. Only used for error messages.
	  // See `createPrimitiveTypeChecker`.
	  function getPreciseType(propValue) {
	    if (typeof propValue === 'undefined' || propValue === null) {
	      return '' + propValue;
	    }
	    var propType = getPropType(propValue);
	    if (propType === 'object') {
	      if (propValue instanceof Date) {
	        return 'date';
	      } else if (propValue instanceof RegExp) {
	        return 'regexp';
	      }
	    }
	    return propType;
	  }

	  // Returns a string that is postfixed to a warning about an invalid type.
	  // For example, "undefined" or "of type array"
	  function getPostfixForTypeWarning(value) {
	    var type = getPreciseType(value);
	    switch (type) {
	      case 'array':
	      case 'object':
	        return 'an ' + type;
	      case 'boolean':
	      case 'date':
	      case 'regexp':
	        return 'a ' + type;
	      default:
	        return type;
	    }
	  }

	  // Returns class name of the object, if any.
	  function getClassName(propValue) {
	    if (!propValue.constructor || !propValue.constructor.name) {
	      return ANONYMOUS;
	    }
	    return propValue.constructor.name;
	  }

	  ReactPropTypes.checkPropTypes = checkPropTypes_1;
	  ReactPropTypes.resetWarningCache = checkPropTypes_1.resetWarningCache;
	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};

	var propTypes = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	{
	  var ReactIs = reactIs;

	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  module.exports = factoryWithTypeCheckers(ReactIs.isElement, throwOnDirectAccess);
	}
	});

	function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

	function _typeof(obj) {
	  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
	    _typeof = function _typeof(obj) {
	      return _typeof2(obj);
	    };
	  } else {
	    _typeof = function _typeof(obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
	    };
	  }

	  return _typeof(obj);
	}

	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    Object.defineProperty(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	function _objectSpread(target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i] != null ? arguments[i] : {};
	    var ownKeys = Object.keys(source);

	    if (typeof Object.getOwnPropertySymbols === 'function') {
	      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
	        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
	      }));
	    }

	    ownKeys.forEach(function (key) {
	      _defineProperty(target, key, source[key]);
	    });
	  }

	  return target;
	}

	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;
	    Object.defineProperty(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	function _possibleConstructorReturn(self, call) {
	  if (call && (_typeof(call) === "object" || typeof call === "function")) {
	    return call;
	  }

	  return _assertThisInitialized(self);
	}

	function _getPrototypeOf(o) {
	  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
	    return o.__proto__ || Object.getPrototypeOf(o);
	  };
	  return _getPrototypeOf(o);
	}

	function _setPrototypeOf(o, p) {
	  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  return _setPrototypeOf(o, p);
	}

	function _inherits(subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function");
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf(subClass, superClass);
	}

	function _arrayWithoutHoles(arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }

	    return arr2;
	  }
	}

	function _iterableToArray(iter) {
	  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
	}

	function _nonIterableSpread() {
	  throw new TypeError("Invalid attempt to spread non-iterable instance");
	}

	function _toConsumableArray(arr) {
	  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
	}

	function _arrayWithHoles(arr) {
	  if (Array.isArray(arr)) return arr;
	}

	function _iterableToArrayLimit(arr, i) {
	  var _arr = [];
	  var _n = true;
	  var _d = false;
	  var _e = undefined;

	  try {
	    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
	      _arr.push(_s.value);

	      if (i && _arr.length === i) break;
	    }
	  } catch (err) {
	    _d = true;
	    _e = err;
	  } finally {
	    try {
	      if (!_n && _i["return"] != null) _i["return"]();
	    } finally {
	      if (_d) throw _e;
	    }
	  }

	  return _arr;
	}

	function _nonIterableRest() {
	  throw new TypeError("Invalid attempt to destructure non-iterable instance");
	}

	function _slicedToArray(arr, i) {
	  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
	}

	var consoleLogger = {
	  type: 'logger',
	  log: function log(args) {
	    this.output('log', args);
	  },
	  warn: function warn(args) {
	    this.output('warn', args);
	  },
	  error: function error(args) {
	    this.output('error', args);
	  },
	  output: function output(type, args) {
	    var _console;

	    /* eslint no-console: 0 */
	    if (console && console[type]) (_console = console)[type].apply(_console, _toConsumableArray(args));
	  }
	};

	var Logger =
	/*#__PURE__*/
	function () {
	  function Logger(concreteLogger) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Logger);

	    this.init(concreteLogger, options);
	  }

	  _createClass(Logger, [{
	    key: "init",
	    value: function init(concreteLogger) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      this.prefix = options.prefix || 'i18next:';
	      this.logger = concreteLogger || consoleLogger;
	      this.options = options;
	      this.debug = options.debug;
	    }
	  }, {
	    key: "setDebug",
	    value: function setDebug(bool) {
	      this.debug = bool;
	    }
	  }, {
	    key: "log",
	    value: function log() {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      return this.forward(args, 'log', '', true);
	    }
	  }, {
	    key: "warn",
	    value: function warn() {
	      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        args[_key2] = arguments[_key2];
	      }

	      return this.forward(args, 'warn', '', true);
	    }
	  }, {
	    key: "error",
	    value: function error() {
	      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        args[_key3] = arguments[_key3];
	      }

	      return this.forward(args, 'error', '');
	    }
	  }, {
	    key: "deprecate",
	    value: function deprecate() {
	      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	        args[_key4] = arguments[_key4];
	      }

	      return this.forward(args, 'warn', 'WARNING DEPRECATED: ', true);
	    }
	  }, {
	    key: "forward",
	    value: function forward(args, lvl, prefix, debugOnly) {
	      if (debugOnly && !this.debug) return null;
	      if (typeof args[0] === 'string') args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
	      return this.logger[lvl](args);
	    }
	  }, {
	    key: "create",
	    value: function create(moduleName) {
	      return new Logger(this.logger, _objectSpread({}, {
	        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
	      }, this.options));
	    }
	  }]);

	  return Logger;
	}();

	var baseLogger = new Logger();

	var EventEmitter =
	/*#__PURE__*/
	function () {
	  function EventEmitter() {
	    _classCallCheck(this, EventEmitter);

	    this.observers = {};
	  }

	  _createClass(EventEmitter, [{
	    key: "on",
	    value: function on(events, listener) {
	      var _this = this;

	      events.split(' ').forEach(function (event) {
	        _this.observers[event] = _this.observers[event] || [];

	        _this.observers[event].push(listener);
	      });
	      return this;
	    }
	  }, {
	    key: "off",
	    value: function off(event, listener) {
	      var _this2 = this;

	      if (!this.observers[event]) {
	        return;
	      }

	      this.observers[event].forEach(function () {
	        if (!listener) {
	          delete _this2.observers[event];
	        } else {
	          var index = _this2.observers[event].indexOf(listener);

	          if (index > -1) {
	            _this2.observers[event].splice(index, 1);
	          }
	        }
	      });
	    }
	  }, {
	    key: "emit",
	    value: function emit(event) {
	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      if (this.observers[event]) {
	        var cloned = [].concat(this.observers[event]);
	        cloned.forEach(function (observer) {
	          observer.apply(void 0, args);
	        });
	      }

	      if (this.observers['*']) {
	        var _cloned = [].concat(this.observers['*']);

	        _cloned.forEach(function (observer) {
	          observer.apply(observer, [event].concat(args));
	        });
	      }
	    }
	  }]);

	  return EventEmitter;
	}();

	// http://lea.verou.me/2016/12/resolve-promises-externally-with-this-one-weird-trick/
	function defer() {
	  var res;
	  var rej;
	  var promise = new Promise(function (resolve, reject) {
	    res = resolve;
	    rej = reject;
	  });
	  promise.resolve = res;
	  promise.reject = rej;
	  return promise;
	}
	function makeString(object) {
	  if (object == null) return '';
	  /* eslint prefer-template: 0 */

	  return '' + object;
	}
	function copy(a, s, t) {
	  a.forEach(function (m) {
	    if (s[m]) t[m] = s[m];
	  });
	}

	function getLastOfPath(object, path, Empty) {
	  function cleanKey(key) {
	    return key && key.indexOf('###') > -1 ? key.replace(/###/g, '.') : key;
	  }

	  function canNotTraverseDeeper() {
	    return !object || typeof object === 'string';
	  }

	  var stack = typeof path !== 'string' ? [].concat(path) : path.split('.');

	  while (stack.length > 1) {
	    if (canNotTraverseDeeper()) return {};
	    var key = cleanKey(stack.shift());
	    if (!object[key] && Empty) object[key] = new Empty();
	    object = object[key];
	  }

	  if (canNotTraverseDeeper()) return {};
	  return {
	    obj: object,
	    k: cleanKey(stack.shift())
	  };
	}

	function setPath(object, path, newValue) {
	  var _getLastOfPath = getLastOfPath(object, path, Object),
	      obj = _getLastOfPath.obj,
	      k = _getLastOfPath.k;

	  obj[k] = newValue;
	}
	function pushPath(object, path, newValue, concat) {
	  var _getLastOfPath2 = getLastOfPath(object, path, Object),
	      obj = _getLastOfPath2.obj,
	      k = _getLastOfPath2.k;

	  obj[k] = obj[k] || [];
	  if (concat) obj[k] = obj[k].concat(newValue);
	  if (!concat) obj[k].push(newValue);
	}
	function getPath(object, path) {
	  var _getLastOfPath3 = getLastOfPath(object, path),
	      obj = _getLastOfPath3.obj,
	      k = _getLastOfPath3.k;

	  if (!obj) return undefined;
	  return obj[k];
	}
	function deepExtend(target, source, overwrite) {
	  /* eslint no-restricted-syntax: 0 */
	  for (var prop in source) {
	    if (prop in target) {
	      // If we reached a leaf string in target or source then replace with source or skip depending on the 'overwrite' switch
	      if (typeof target[prop] === 'string' || target[prop] instanceof String || typeof source[prop] === 'string' || source[prop] instanceof String) {
	        if (overwrite) target[prop] = source[prop];
	      } else {
	        deepExtend(target[prop], source[prop], overwrite);
	      }
	    } else {
	      target[prop] = source[prop];
	    }
	  }

	  return target;
	}
	function regexEscape(str) {
	  /* eslint no-useless-escape: 0 */
	  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
	}
	/* eslint-disable */

	var _entityMap = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#39;',
	  '/': '&#x2F;'
	};
	/* eslint-enable */

	function escape(data) {
	  if (typeof data === 'string') {
	    return data.replace(/[&<>"'\/]/g, function (s) {
	      return _entityMap[s];
	    });
	  }

	  return data;
	}

	var ResourceStore =
	/*#__PURE__*/
	function (_EventEmitter) {
	  _inherits(ResourceStore, _EventEmitter);

	  function ResourceStore(data) {
	    var _this;

	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
	      ns: ['translation'],
	      defaultNS: 'translation'
	    };

	    _classCallCheck(this, ResourceStore);

	    _this = _possibleConstructorReturn(this, _getPrototypeOf(ResourceStore).call(this));
	    EventEmitter.call(_assertThisInitialized(_this)); // <=IE10 fix (unable to call parent constructor)

	    _this.data = data || {};
	    _this.options = options;

	    if (_this.options.keySeparator === undefined) {
	      _this.options.keySeparator = '.';
	    }

	    return _this;
	  }

	  _createClass(ResourceStore, [{
	    key: "addNamespaces",
	    value: function addNamespaces(ns) {
	      if (this.options.ns.indexOf(ns) < 0) {
	        this.options.ns.push(ns);
	      }
	    }
	  }, {
	    key: "removeNamespaces",
	    value: function removeNamespaces(ns) {
	      var index = this.options.ns.indexOf(ns);

	      if (index > -1) {
	        this.options.ns.splice(index, 1);
	      }
	    }
	  }, {
	    key: "getResource",
	    value: function getResource(lng, ns, key) {
	      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
	      var path = [lng, ns];
	      if (key && typeof key !== 'string') path = path.concat(key);
	      if (key && typeof key === 'string') path = path.concat(keySeparator ? key.split(keySeparator) : key);

	      if (lng.indexOf('.') > -1) {
	        path = lng.split('.');
	      }

	      return getPath(this.data, path);
	    }
	  }, {
	    key: "addResource",
	    value: function addResource(lng, ns, key, value) {
	      var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
	        silent: false
	      };
	      var keySeparator = this.options.keySeparator;
	      if (keySeparator === undefined) keySeparator = '.';
	      var path = [lng, ns];
	      if (key) path = path.concat(keySeparator ? key.split(keySeparator) : key);

	      if (lng.indexOf('.') > -1) {
	        path = lng.split('.');
	        value = ns;
	        ns = path[1];
	      }

	      this.addNamespaces(ns);
	      setPath(this.data, path, value);
	      if (!options.silent) this.emit('added', lng, ns, key, value);
	    }
	  }, {
	    key: "addResources",
	    value: function addResources(lng, ns, resources) {
	      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
	        silent: false
	      };

	      /* eslint no-restricted-syntax: 0 */
	      for (var m in resources) {
	        if (typeof resources[m] === 'string' || Object.prototype.toString.apply(resources[m]) === '[object Array]') this.addResource(lng, ns, m, resources[m], {
	          silent: true
	        });
	      }

	      if (!options.silent) this.emit('added', lng, ns, resources);
	    }
	  }, {
	    key: "addResourceBundle",
	    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
	      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
	        silent: false
	      };
	      var path = [lng, ns];

	      if (lng.indexOf('.') > -1) {
	        path = lng.split('.');
	        deep = resources;
	        resources = ns;
	        ns = path[1];
	      }

	      this.addNamespaces(ns);
	      var pack = getPath(this.data, path) || {};

	      if (deep) {
	        deepExtend(pack, resources, overwrite);
	      } else {
	        pack = _objectSpread({}, pack, resources);
	      }

	      setPath(this.data, path, pack);
	      if (!options.silent) this.emit('added', lng, ns, resources);
	    }
	  }, {
	    key: "removeResourceBundle",
	    value: function removeResourceBundle(lng, ns) {
	      if (this.hasResourceBundle(lng, ns)) {
	        delete this.data[lng][ns];
	      }

	      this.removeNamespaces(ns);
	      this.emit('removed', lng, ns);
	    }
	  }, {
	    key: "hasResourceBundle",
	    value: function hasResourceBundle(lng, ns) {
	      return this.getResource(lng, ns) !== undefined;
	    }
	  }, {
	    key: "getResourceBundle",
	    value: function getResourceBundle(lng, ns) {
	      if (!ns) ns = this.options.defaultNS; // COMPATIBILITY: remove extend in v2.1.0

	      if (this.options.compatibilityAPI === 'v1') return _objectSpread({}, {}, this.getResource(lng, ns));
	      return this.getResource(lng, ns);
	    }
	  }, {
	    key: "getDataByLanguage",
	    value: function getDataByLanguage(lng) {
	      return this.data[lng];
	    }
	  }, {
	    key: "toJSON",
	    value: function toJSON() {
	      return this.data;
	    }
	  }]);

	  return ResourceStore;
	}(EventEmitter);

	var postProcessor = {
	  processors: {},
	  addPostProcessor: function addPostProcessor(module) {
	    this.processors[module.name] = module;
	  },
	  handle: function handle(processors, value, key, options, translator) {
	    var _this = this;

	    processors.forEach(function (processor) {
	      if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options, translator);
	    });
	    return value;
	  }
	};

	var Translator =
	/*#__PURE__*/
	function (_EventEmitter) {
	  _inherits(Translator, _EventEmitter);

	  function Translator(services) {
	    var _this;

	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Translator);

	    _this = _possibleConstructorReturn(this, _getPrototypeOf(Translator).call(this));
	    EventEmitter.call(_assertThisInitialized(_this)); // <=IE10 fix (unable to call parent constructor)

	    copy(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat'], services, _assertThisInitialized(_this));
	    _this.options = options;

	    if (_this.options.keySeparator === undefined) {
	      _this.options.keySeparator = '.';
	    }

	    _this.logger = baseLogger.create('translator');
	    return _this;
	  }

	  _createClass(Translator, [{
	    key: "changeLanguage",
	    value: function changeLanguage(lng) {
	      if (lng) this.language = lng;
	    }
	  }, {
	    key: "exists",
	    value: function exists(key) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
	        interpolation: {}
	      };
	      var resolved = this.resolve(key, options);
	      return resolved && resolved.res !== undefined;
	    }
	  }, {
	    key: "extractFromKey",
	    value: function extractFromKey(key, options) {
	      var nsSeparator = options.nsSeparator || this.options.nsSeparator;
	      if (nsSeparator === undefined) nsSeparator = ':';
	      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator;
	      var namespaces = options.ns || this.options.defaultNS;

	      if (nsSeparator && key.indexOf(nsSeparator) > -1) {
	        var parts = key.split(nsSeparator);
	        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
	        key = parts.join(keySeparator);
	      }

	      if (typeof namespaces === 'string') namespaces = [namespaces];
	      return {
	        key: key,
	        namespaces: namespaces
	      };
	    }
	  }, {
	    key: "translate",
	    value: function translate(keys, options) {
	      var _this2 = this;

	      if (_typeof(options) !== 'object' && this.options.overloadTranslationOptionHandler) {
	        /* eslint prefer-rest-params: 0 */
	        options = this.options.overloadTranslationOptionHandler(arguments);
	      }

	      if (!options) options = {}; // non valid keys handling

	      if (keys === undefined || keys === null) return '';
	      if (!Array.isArray(keys)) keys = [String(keys)]; // separators

	      var keySeparator = options.keySeparator !== undefined ? options.keySeparator : this.options.keySeparator; // get namespace(s)

	      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options),
	          key = _this$extractFromKey.key,
	          namespaces = _this$extractFromKey.namespaces;

	      var namespace = namespaces[namespaces.length - 1]; // return key on CIMode

	      var lng = options.lng || this.language;
	      var appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;

	      if (lng && lng.toLowerCase() === 'cimode') {
	        if (appendNamespaceToCIMode) {
	          var nsSeparator = options.nsSeparator || this.options.nsSeparator;
	          return namespace + nsSeparator + key;
	        }

	        return key;
	      } // resolve from store


	      var resolved = this.resolve(keys, options);
	      var res = resolved && resolved.res;
	      var resUsedKey = resolved && resolved.usedKey || key;
	      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
	      var resType = Object.prototype.toString.apply(res);
	      var noObject = ['[object Number]', '[object Function]', '[object RegExp]'];
	      var joinArrays = options.joinArrays !== undefined ? options.joinArrays : this.options.joinArrays; // object

	      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
	      var handleAsObject = typeof res !== 'string' && typeof res !== 'boolean' && typeof res !== 'number';

	      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === 'string' && resType === '[object Array]')) {
	        if (!options.returnObjects && !this.options.returnObjects) {
	          this.logger.warn('accessing an object - but returnObjects options is not enabled!');
	          return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
	        } // if we got a separator we loop over children - else we just return object as is
	        // as having it set to false means no hierarchy so no lookup for nested values


	        if (keySeparator) {
	          var resTypeIsArray = resType === '[object Array]';
	          var copy$$1 = resTypeIsArray ? [] : {}; // apply child translation on a copy

	          /* eslint no-restricted-syntax: 0 */

	          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;

	          for (var m in res) {
	            if (Object.prototype.hasOwnProperty.call(res, m)) {
	              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m);
	              copy$$1[m] = this.translate(deepKey, _objectSpread({}, options, {
	                joinArrays: false,
	                ns: namespaces
	              }));
	              if (copy$$1[m] === deepKey) copy$$1[m] = res[m]; // if nothing found use orginal value as fallback
	            }
	          }

	          res = copy$$1;
	        }
	      } else if (handleAsObjectInI18nFormat && typeof joinArrays === 'string' && resType === '[object Array]') {
	        // array special treatment
	        res = res.join(joinArrays);
	        if (res) res = this.extendTranslation(res, keys, options);
	      } else {
	        // string, empty or null
	        var usedDefault = false;
	        var usedKey = false; // fallback value

	        if (!this.isValidLookup(res) && options.defaultValue !== undefined) {
	          usedDefault = true;

	          if (options.count !== undefined) {
	            var suffix = this.pluralResolver.getSuffix(lng, options.count);
	            res = options["defaultValue".concat(suffix)];
	          }

	          if (!res) res = options.defaultValue;
	        }

	        if (!this.isValidLookup(res)) {
	          usedKey = true;
	          res = key;
	        } // save missing


	        var updateMissing = options.defaultValue && options.defaultValue !== res && this.options.updateMissing;

	        if (usedKey || usedDefault || updateMissing) {
	          this.logger.log(updateMissing ? 'updateKey' : 'missingKey', lng, namespace, key, updateMissing ? options.defaultValue : res);
	          var lngs = [];
	          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);

	          if (this.options.saveMissingTo === 'fallback' && fallbackLngs && fallbackLngs[0]) {
	            for (var i = 0; i < fallbackLngs.length; i++) {
	              lngs.push(fallbackLngs[i]);
	            }
	          } else if (this.options.saveMissingTo === 'all') {
	            lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
	          } else {
	            lngs.push(options.lng || this.language);
	          }

	          var send = function send(l, k) {
	            if (_this2.options.missingKeyHandler) {
	              _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
	            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
	              _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? options.defaultValue : res, updateMissing, options);
	            }

	            _this2.emit('missingKey', l, namespace, k, res);
	          };

	          if (this.options.saveMissing) {
	            var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';

	            if (this.options.saveMissingPlurals && needsPluralHandling) {
	              lngs.forEach(function (l) {
	                var plurals = _this2.pluralResolver.getPluralFormsOfKey(l, key);

	                plurals.forEach(function (p) {
	                  return send([l], p);
	                });
	              });
	            } else {
	              send(lngs, key);
	            }
	          }
	        } // extend


	        res = this.extendTranslation(res, keys, options, resolved); // append namespace if still key

	        if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key); // parseMissingKeyHandler

	        if (usedKey && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
	      } // return


	      return res;
	    }
	  }, {
	    key: "extendTranslation",
	    value: function extendTranslation(res, key, options, resolved) {
	      var _this3 = this;

	      if (this.i18nFormat && this.i18nFormat.parse) {
	        res = this.i18nFormat.parse(res, options, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
	          resolved: resolved
	        });
	      } else if (!options.skipInterpolation) {
	        // i18next.parsing
	        if (options.interpolation) this.interpolator.init(_objectSpread({}, options, {
	          interpolation: _objectSpread({}, this.options.interpolation, options.interpolation)
	        })); // interpolate

	        var data = options.replace && typeof options.replace !== 'string' ? options.replace : options;
	        if (this.options.interpolation.defaultVariables) data = _objectSpread({}, this.options.interpolation.defaultVariables, data);
	        res = this.interpolator.interpolate(res, data, options.lng || this.language, options); // nesting

	        if (options.nest !== false) res = this.interpolator.nest(res, function () {
	          return _this3.translate.apply(_this3, arguments);
	        }, options);
	        if (options.interpolation) this.interpolator.reset();
	      } // post process


	      var postProcess = options.postProcess || this.options.postProcess;
	      var postProcessorNames = typeof postProcess === 'string' ? [postProcess] : postProcess;

	      if (res !== undefined && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
	        res = postProcessor.handle(postProcessorNames, res, key, options, this);
	      }

	      return res;
	    }
	  }, {
	    key: "resolve",
	    value: function resolve(keys) {
	      var _this4 = this;

	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var found;
	      var usedKey; // plain key

	      var exactUsedKey; // key with context / plural

	      var usedLng;
	      var usedNS;
	      if (typeof keys === 'string') keys = [keys]; // forEach possible key

	      keys.forEach(function (k) {
	        if (_this4.isValidLookup(found)) return;

	        var extracted = _this4.extractFromKey(k, options);

	        var key = extracted.key;
	        usedKey = key;
	        var namespaces = extracted.namespaces;
	        if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
	        var needsPluralHandling = options.count !== undefined && typeof options.count !== 'string';
	        var needsContextHandling = options.context !== undefined && typeof options.context === 'string' && options.context !== '';
	        var codes = options.lngs ? options.lngs : _this4.languageUtils.toResolveHierarchy(options.lng || _this4.language, options.fallbackLng);
	        namespaces.forEach(function (ns) {
	          if (_this4.isValidLookup(found)) return;
	          usedNS = ns;
	          codes.forEach(function (code) {
	            if (_this4.isValidLookup(found)) return;
	            usedLng = code;
	            var finalKey = key;
	            var finalKeys = [finalKey];

	            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
	              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
	            } else {
	              var pluralSuffix;
	              if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options.count); // fallback for plural if context not found

	              if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix); // get key for context if needed

	              if (needsContextHandling) finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options.context)); // get key for plural if needed

	              if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);
	            } // iterate over finalKeys starting with most specific pluralkey (-> contextkey only) -> singularkey only


	            var possibleKey;
	            /* eslint no-cond-assign: 0 */

	            while (possibleKey = finalKeys.pop()) {
	              if (!_this4.isValidLookup(found)) {
	                exactUsedKey = possibleKey;
	                found = _this4.getResource(code, ns, possibleKey, options);
	              }
	            }
	          });
	        });
	      });
	      return {
	        res: found,
	        usedKey: usedKey,
	        exactUsedKey: exactUsedKey,
	        usedLng: usedLng,
	        usedNS: usedNS
	      };
	    }
	  }, {
	    key: "isValidLookup",
	    value: function isValidLookup(res) {
	      return res !== undefined && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === '');
	    }
	  }, {
	    key: "getResource",
	    value: function getResource(code, ns, key) {
	      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
	      if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options);
	      return this.resourceStore.getResource(code, ns, key, options);
	    }
	  }]);

	  return Translator;
	}(EventEmitter);

	function capitalize(string) {
	  return string.charAt(0).toUpperCase() + string.slice(1);
	}

	var LanguageUtil =
	/*#__PURE__*/
	function () {
	  function LanguageUtil(options) {
	    _classCallCheck(this, LanguageUtil);

	    this.options = options;
	    this.whitelist = this.options.whitelist || false;
	    this.logger = baseLogger.create('languageUtils');
	  }

	  _createClass(LanguageUtil, [{
	    key: "getScriptPartFromCode",
	    value: function getScriptPartFromCode(code) {
	      if (!code || code.indexOf('-') < 0) return null;
	      var p = code.split('-');
	      if (p.length === 2) return null;
	      p.pop();
	      return this.formatLanguageCode(p.join('-'));
	    }
	  }, {
	    key: "getLanguagePartFromCode",
	    value: function getLanguagePartFromCode(code) {
	      if (!code || code.indexOf('-') < 0) return code;
	      var p = code.split('-');
	      return this.formatLanguageCode(p[0]);
	    }
	  }, {
	    key: "formatLanguageCode",
	    value: function formatLanguageCode(code) {
	      // http://www.iana.org/assignments/language-tags/language-tags.xhtml
	      if (typeof code === 'string' && code.indexOf('-') > -1) {
	        var specialCases = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'];
	        var p = code.split('-');

	        if (this.options.lowerCaseLng) {
	          p = p.map(function (part) {
	            return part.toLowerCase();
	          });
	        } else if (p.length === 2) {
	          p[0] = p[0].toLowerCase();
	          p[1] = p[1].toUpperCase();
	          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
	        } else if (p.length === 3) {
	          p[0] = p[0].toLowerCase(); // if lenght 2 guess it's a country

	          if (p[1].length === 2) p[1] = p[1].toUpperCase();
	          if (p[0] !== 'sgn' && p[2].length === 2) p[2] = p[2].toUpperCase();
	          if (specialCases.indexOf(p[1].toLowerCase()) > -1) p[1] = capitalize(p[1].toLowerCase());
	          if (specialCases.indexOf(p[2].toLowerCase()) > -1) p[2] = capitalize(p[2].toLowerCase());
	        }

	        return p.join('-');
	      }

	      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
	    }
	  }, {
	    key: "isWhitelisted",
	    value: function isWhitelisted(code) {
	      if (this.options.load === 'languageOnly' || this.options.nonExplicitWhitelist) {
	        code = this.getLanguagePartFromCode(code);
	      }

	      return !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(code) > -1;
	    }
	  }, {
	    key: "getFallbackCodes",
	    value: function getFallbackCodes(fallbacks, code) {
	      if (!fallbacks) return [];
	      if (typeof fallbacks === 'string') fallbacks = [fallbacks];
	      if (Object.prototype.toString.apply(fallbacks) === '[object Array]') return fallbacks;
	      if (!code) return fallbacks["default"] || []; // asume we have an object defining fallbacks

	      var found = fallbacks[code];
	      if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
	      if (!found) found = fallbacks[this.formatLanguageCode(code)];
	      if (!found) found = fallbacks["default"];
	      return found || [];
	    }
	  }, {
	    key: "toResolveHierarchy",
	    value: function toResolveHierarchy(code, fallbackCode) {
	      var _this = this;

	      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
	      var codes = [];

	      var addCode = function addCode(c) {
	        if (!c) return;

	        if (_this.isWhitelisted(c)) {
	          codes.push(c);
	        } else {
	          _this.logger.warn("rejecting non-whitelisted language code: ".concat(c));
	        }
	      };

	      if (typeof code === 'string' && code.indexOf('-') > -1) {
	        if (this.options.load !== 'languageOnly') addCode(this.formatLanguageCode(code));
	        if (this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly') addCode(this.getScriptPartFromCode(code));
	        if (this.options.load !== 'currentOnly') addCode(this.getLanguagePartFromCode(code));
	      } else if (typeof code === 'string') {
	        addCode(this.formatLanguageCode(code));
	      }

	      fallbackCodes.forEach(function (fc) {
	        if (codes.indexOf(fc) < 0) addCode(_this.formatLanguageCode(fc));
	      });
	      return codes;
	    }
	  }]);

	  return LanguageUtil;
	}();

	/* eslint-disable */

	var sets = [{
	  lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'ti', 'tr', 'uz', 'wa'],
	  nr: [1, 2],
	  fc: 1
	}, {
	  lngs: ['af', 'an', 'ast', 'az', 'bg', 'bn', 'ca', 'da', 'de', 'dev', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fi', 'fo', 'fur', 'fy', 'gl', 'gu', 'ha', 'hi', 'hu', 'hy', 'ia', 'it', 'kn', 'ku', 'lb', 'mai', 'ml', 'mn', 'mr', 'nah', 'nap', 'nb', 'ne', 'nl', 'nn', 'no', 'nso', 'pa', 'pap', 'pms', 'ps', 'pt-PT', 'rm', 'sco', 'se', 'si', 'so', 'son', 'sq', 'sv', 'sw', 'ta', 'te', 'tk', 'ur', 'yo'],
	  nr: [1, 2],
	  fc: 2
	}, {
	  lngs: ['ay', 'bo', 'cgg', 'fa', 'id', 'ja', 'jbo', 'ka', 'kk', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
	  nr: [1],
	  fc: 3
	}, {
	  lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],
	  nr: [1, 2, 5],
	  fc: 4
	}, {
	  lngs: ['ar'],
	  nr: [0, 1, 2, 3, 11, 100],
	  fc: 5
	}, {
	  lngs: ['cs', 'sk'],
	  nr: [1, 2, 5],
	  fc: 6
	}, {
	  lngs: ['csb', 'pl'],
	  nr: [1, 2, 5],
	  fc: 7
	}, {
	  lngs: ['cy'],
	  nr: [1, 2, 3, 8],
	  fc: 8
	}, {
	  lngs: ['fr'],
	  nr: [1, 2],
	  fc: 9
	}, {
	  lngs: ['ga'],
	  nr: [1, 2, 3, 7, 11],
	  fc: 10
	}, {
	  lngs: ['gd'],
	  nr: [1, 2, 3, 20],
	  fc: 11
	}, {
	  lngs: ['is'],
	  nr: [1, 2],
	  fc: 12
	}, {
	  lngs: ['jv'],
	  nr: [0, 1],
	  fc: 13
	}, {
	  lngs: ['kw'],
	  nr: [1, 2, 3, 4],
	  fc: 14
	}, {
	  lngs: ['lt'],
	  nr: [1, 2, 10],
	  fc: 15
	}, {
	  lngs: ['lv'],
	  nr: [1, 2, 0],
	  fc: 16
	}, {
	  lngs: ['mk'],
	  nr: [1, 2],
	  fc: 17
	}, {
	  lngs: ['mnk'],
	  nr: [0, 1, 2],
	  fc: 18
	}, {
	  lngs: ['mt'],
	  nr: [1, 2, 11, 20],
	  fc: 19
	}, {
	  lngs: ['or'],
	  nr: [2, 1],
	  fc: 2
	}, {
	  lngs: ['ro'],
	  nr: [1, 2, 20],
	  fc: 20
	}, {
	  lngs: ['sl'],
	  nr: [5, 1, 2, 3],
	  fc: 21
	}, {
	  lngs: ['he'],
	  nr: [1, 2, 20, 21],
	  fc: 22
	}];
	var _rulesPluralsTypes = {
	  1: function _(n) {
	    return Number(n > 1);
	  },
	  2: function _(n) {
	    return Number(n != 1);
	  },
	  3: function _(n) {
	    return 0;
	  },
	  4: function _(n) {
	    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
	  },
	  5: function _(n) {
	    return Number(n === 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
	  },
	  6: function _(n) {
	    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
	  },
	  7: function _(n) {
	    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
	  },
	  8: function _(n) {
	    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
	  },
	  9: function _(n) {
	    return Number(n >= 2);
	  },
	  10: function _(n) {
	    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
	  },
	  11: function _(n) {
	    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
	  },
	  12: function _(n) {
	    return Number(n % 10 != 1 || n % 100 == 11);
	  },
	  13: function _(n) {
	    return Number(n !== 0);
	  },
	  14: function _(n) {
	    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
	  },
	  15: function _(n) {
	    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
	  },
	  16: function _(n) {
	    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
	  },
	  17: function _(n) {
	    return Number(n == 1 || n % 10 == 1 ? 0 : 1);
	  },
	  18: function _(n) {
	    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
	  },
	  19: function _(n) {
	    return Number(n == 1 ? 0 : n === 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
	  },
	  20: function _(n) {
	    return Number(n == 1 ? 0 : n === 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
	  },
	  21: function _(n) {
	    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
	  },
	  22: function _(n) {
	    return Number(n === 1 ? 0 : n === 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
	  }
	};
	/* eslint-enable */

	function createRules() {
	  var rules = {};
	  sets.forEach(function (set) {
	    set.lngs.forEach(function (l) {
	      rules[l] = {
	        numbers: set.nr,
	        plurals: _rulesPluralsTypes[set.fc]
	      };
	    });
	  });
	  return rules;
	}

	var PluralResolver =
	/*#__PURE__*/
	function () {
	  function PluralResolver(languageUtils) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, PluralResolver);

	    this.languageUtils = languageUtils;
	    this.options = options;
	    this.logger = baseLogger.create('pluralResolver');
	    this.rules = createRules();
	  }

	  _createClass(PluralResolver, [{
	    key: "addRule",
	    value: function addRule(lng, obj) {
	      this.rules[lng] = obj;
	    }
	  }, {
	    key: "getRule",
	    value: function getRule(code) {
	      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
	    }
	  }, {
	    key: "needsPlural",
	    value: function needsPlural(code) {
	      var rule = this.getRule(code);
	      return rule && rule.numbers.length > 1;
	    }
	  }, {
	    key: "getPluralFormsOfKey",
	    value: function getPluralFormsOfKey(code, key) {
	      var _this = this;

	      var ret = [];
	      var rule = this.getRule(code);
	      if (!rule) return ret;
	      rule.numbers.forEach(function (n) {
	        var suffix = _this.getSuffix(code, n);

	        ret.push("".concat(key).concat(suffix));
	      });
	      return ret;
	    }
	  }, {
	    key: "getSuffix",
	    value: function getSuffix(code, count) {
	      var _this2 = this;

	      var rule = this.getRule(code);

	      if (rule) {
	        // if (rule.numbers.length === 1) return ''; // only singular
	        var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
	        var suffix = rule.numbers[idx]; // special treatment for lngs only having singular and plural

	        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
	          if (suffix === 2) {
	            suffix = 'plural';
	          } else if (suffix === 1) {
	            suffix = '';
	          }
	        }

	        var returnSuffix = function returnSuffix() {
	          return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
	        }; // COMPATIBILITY JSON
	        // v1


	        if (this.options.compatibilityJSON === 'v1') {
	          if (suffix === 1) return '';
	          if (typeof suffix === 'number') return "_plural_".concat(suffix.toString());
	          return returnSuffix();
	        } else if (
	        /* v2 */
	        this.options.compatibilityJSON === 'v2') {
	          return returnSuffix();
	        } else if (
	        /* v3 - gettext index */
	        this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
	          return returnSuffix();
	        }

	        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
	      }

	      this.logger.warn("no plural rule found for: ".concat(code));
	      return '';
	    }
	  }]);

	  return PluralResolver;
	}();

	var Interpolator =
	/*#__PURE__*/
	function () {
	  function Interpolator() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, Interpolator);

	    this.logger = baseLogger.create('interpolator');
	    this.init(options, true);
	  }
	  /* eslint no-param-reassign: 0 */


	  _createClass(Interpolator, [{
	    key: "init",
	    value: function init() {
	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var reset = arguments.length > 1 ? arguments[1] : undefined;

	      if (reset) {
	        this.options = options;

	        this.format = options.interpolation && options.interpolation.format || function (value) {
	          return value;
	        };
	      }

	      if (!options.interpolation) options.interpolation = {
	        escapeValue: true
	      };
	      var iOpts = options.interpolation;
	      this.escape = iOpts.escape !== undefined ? iOpts.escape : escape;
	      this.escapeValue = iOpts.escapeValue !== undefined ? iOpts.escapeValue : true;
	      this.useRawValueToEscape = iOpts.useRawValueToEscape !== undefined ? iOpts.useRawValueToEscape : false;
	      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || '{{';
	      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || '}}';
	      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ',';
	      this.unescapePrefix = iOpts.unescapeSuffix ? '' : iOpts.unescapePrefix || '-';
	      this.unescapeSuffix = this.unescapePrefix ? '' : iOpts.unescapeSuffix || '';
	      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape('$t(');
	      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(')');
	      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1000; // the regexp

	      this.resetRegExp();
	    }
	  }, {
	    key: "reset",
	    value: function reset() {
	      if (this.options) this.init(this.options);
	    }
	  }, {
	    key: "resetRegExp",
	    value: function resetRegExp() {
	      // the regexp
	      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
	      this.regexp = new RegExp(regexpStr, 'g');
	      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
	      this.regexpUnescape = new RegExp(regexpUnescapeStr, 'g');
	      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
	      this.nestingRegexp = new RegExp(nestingRegexpStr, 'g');
	    }
	  }, {
	    key: "interpolate",
	    value: function interpolate(str, data, lng, options) {
	      var _this = this;

	      var match;
	      var value;
	      var replaces;

	      function regexSafe(val) {
	        return val.replace(/\$/g, '$$$$');
	      }

	      var handleFormat = function handleFormat(key) {
	        if (key.indexOf(_this.formatSeparator) < 0) return getPath(data, key);
	        var p = key.split(_this.formatSeparator);
	        var k = p.shift().trim();
	        var f = p.join(_this.formatSeparator).trim();
	        return _this.format(getPath(data, k), f, lng);
	      };

	      this.resetRegExp();
	      var missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
	      replaces = 0; // unescape if has unescapePrefix/Suffix

	      /* eslint no-cond-assign: 0 */

	      while (match = this.regexpUnescape.exec(str)) {
	        value = handleFormat(match[1].trim());

	        if (value === undefined) {
	          if (typeof missingInterpolationHandler === 'function') {
	            var temp = missingInterpolationHandler(str, match, options);
	            value = typeof temp === 'string' ? temp : '';
	          } else {
	            this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
	            value = '';
	          }
	        }

	        str = str.replace(match[0], regexSafe(value));
	        this.regexpUnescape.lastIndex = 0;
	        replaces++;

	        if (replaces >= this.maxReplaces) {
	          break;
	        }
	      }

	      replaces = 0; // regular escape on demand

	      while (match = this.regexp.exec(str)) {
	        value = handleFormat(match[1].trim());

	        if (value === undefined) {
	          if (typeof missingInterpolationHandler === 'function') {
	            var _temp = missingInterpolationHandler(str, match, options);

	            value = typeof _temp === 'string' ? _temp : '';
	          } else {
	            this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
	            value = '';
	          }
	        } else if (typeof value !== 'string' && !this.useRawValueToEscape) {
	          value = makeString(value);
	        }

	        value = this.escapeValue ? regexSafe(this.escape(value)) : regexSafe(value);
	        str = str.replace(match[0], value);
	        this.regexp.lastIndex = 0;
	        replaces++;

	        if (replaces >= this.maxReplaces) {
	          break;
	        }
	      }

	      return str;
	    }
	  }, {
	    key: "nest",
	    value: function nest(str, fc) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      var match;
	      var value;

	      var clonedOptions = _objectSpread({}, options);

	      clonedOptions.applyPostProcessor = false; // avoid post processing on nested lookup
	      // if value is something like "myKey": "lorem $(anotherKey, { "count": {{aValueInOptions}} })"

	      function handleHasOptions(key, inheritedOptions) {
	        if (key.indexOf(',') < 0) return key;
	        var p = key.split(',');
	        key = p.shift();
	        var optionsString = p.join(',');
	        optionsString = this.interpolate(optionsString, clonedOptions);
	        optionsString = optionsString.replace(/'/g, '"');

	        try {
	          clonedOptions = JSON.parse(optionsString);
	          if (inheritedOptions) clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);
	        } catch (e) {
	          this.logger.error("failed parsing options string in nesting for key ".concat(key), e);
	        }

	        return key;
	      } // regular escape on demand


	      while (match = this.nestingRegexp.exec(str)) {
	        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions); // is only the nesting key (key1 = '$(key2)') return the value without stringify

	        if (value && match[0] === str && typeof value !== 'string') return value; // no string to include or empty

	        if (typeof value !== 'string') value = makeString(value);

	        if (!value) {
	          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
	          value = '';
	        } // Nested keys should not be escaped by default #854
	        // value = this.escapeValue ? regexSafe(utils.escape(value)) : regexSafe(value);


	        str = str.replace(match[0], value);
	        this.regexp.lastIndex = 0;
	      }

	      return str;
	    }
	  }]);

	  return Interpolator;
	}();

	function remove(arr, what) {
	  var found = arr.indexOf(what);

	  while (found !== -1) {
	    arr.splice(found, 1);
	    found = arr.indexOf(what);
	  }
	}

	var Connector =
	/*#__PURE__*/
	function (_EventEmitter) {
	  _inherits(Connector, _EventEmitter);

	  function Connector(backend, store, services) {
	    var _this;

	    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

	    _classCallCheck(this, Connector);

	    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connector).call(this));
	    EventEmitter.call(_assertThisInitialized(_this)); // <=IE10 fix (unable to call parent constructor)

	    _this.backend = backend;
	    _this.store = store;
	    _this.languageUtils = services.languageUtils;
	    _this.options = options;
	    _this.logger = baseLogger.create('backendConnector');
	    _this.state = {};
	    _this.queue = [];

	    if (_this.backend && _this.backend.init) {
	      _this.backend.init(services, options.backend, options);
	    }

	    return _this;
	  }

	  _createClass(Connector, [{
	    key: "queueLoad",
	    value: function queueLoad(languages, namespaces, options, callback) {
	      var _this2 = this;

	      // find what needs to be loaded
	      var toLoad = [];
	      var pending = [];
	      var toLoadLanguages = [];
	      var toLoadNamespaces = [];
	      languages.forEach(function (lng) {
	        var hasAllNamespaces = true;
	        namespaces.forEach(function (ns) {
	          var name = "".concat(lng, "|").concat(ns);

	          if (!options.reload && _this2.store.hasResourceBundle(lng, ns)) {
	            _this2.state[name] = 2; // loaded
	          } else if (_this2.state[name] < 0) ; else if (_this2.state[name] === 1) {
	            if (pending.indexOf(name) < 0) pending.push(name);
	          } else {
	            _this2.state[name] = 1; // pending

	            hasAllNamespaces = false;
	            if (pending.indexOf(name) < 0) pending.push(name);
	            if (toLoad.indexOf(name) < 0) toLoad.push(name);
	            if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);
	          }
	        });
	        if (!hasAllNamespaces) toLoadLanguages.push(lng);
	      });

	      if (toLoad.length || pending.length) {
	        this.queue.push({
	          pending: pending,
	          loaded: {},
	          errors: [],
	          callback: callback
	        });
	      }

	      return {
	        toLoad: toLoad,
	        pending: pending,
	        toLoadLanguages: toLoadLanguages,
	        toLoadNamespaces: toLoadNamespaces
	      };
	    }
	  }, {
	    key: "loaded",
	    value: function loaded(name, err, data) {
	      var _name$split = name.split('|'),
	          _name$split2 = _slicedToArray(_name$split, 2),
	          lng = _name$split2[0],
	          ns = _name$split2[1];

	      if (err) this.emit('failedLoading', lng, ns, err);

	      if (data) {
	        this.store.addResourceBundle(lng, ns, data);
	      } // set loaded


	      this.state[name] = err ? -1 : 2; // consolidated loading done in this run - only emit once for a loaded namespace

	      var loaded = {}; // callback if ready

	      this.queue.forEach(function (q) {
	        pushPath(q.loaded, [lng], ns);
	        remove(q.pending, name);
	        if (err) q.errors.push(err);

	        if (q.pending.length === 0 && !q.done) {
	          // only do once per loaded -> this.emit('loaded', q.loaded);
	          Object.keys(q.loaded).forEach(function (l) {
	            if (!loaded[l]) loaded[l] = [];

	            if (q.loaded[l].length) {
	              q.loaded[l].forEach(function (ns) {
	                if (loaded[l].indexOf(ns) < 0) loaded[l].push(ns);
	              });
	            }
	          });
	          /* eslint no-param-reassign: 0 */

	          q.done = true;

	          if (q.errors.length) {
	            q.callback(q.errors);
	          } else {
	            q.callback();
	          }
	        }
	      }); // emit consolidated loaded event

	      this.emit('loaded', loaded); // remove done load requests

	      this.queue = this.queue.filter(function (q) {
	        return !q.done;
	      });
	    }
	  }, {
	    key: "read",
	    value: function read(lng, ns, fcName) {
	      var _this3 = this;

	      var tried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	      var wait = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 250;
	      var callback = arguments.length > 5 ? arguments[5] : undefined;
	      if (!lng.length) return callback(null, {}); // noting to load

	      return this.backend[fcName](lng, ns, function (err, data) {
	        if (err && data
	        /* = retryFlag */
	        && tried < 5) {
	          setTimeout(function () {
	            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
	          }, wait);
	          return;
	        }

	        callback(err, data);
	      });
	    }
	    /* eslint consistent-return: 0 */

	  }, {
	    key: "prepareLoading",
	    value: function prepareLoading(languages, namespaces) {
	      var _this4 = this;

	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      var callback = arguments.length > 3 ? arguments[3] : undefined;

	      if (!this.backend) {
	        this.logger.warn('No backend was added via i18next.use. Will not load resources.');
	        return callback && callback();
	      }

	      if (typeof languages === 'string') languages = this.languageUtils.toResolveHierarchy(languages);
	      if (typeof namespaces === 'string') namespaces = [namespaces];
	      var toLoad = this.queueLoad(languages, namespaces, options, callback);

	      if (!toLoad.toLoad.length) {
	        if (!toLoad.pending.length) callback(); // nothing to load and no pendings...callback now

	        return null; // pendings will trigger callback
	      }

	      toLoad.toLoad.forEach(function (name) {
	        _this4.loadOne(name);
	      });
	    }
	  }, {
	    key: "load",
	    value: function load(languages, namespaces, callback) {
	      this.prepareLoading(languages, namespaces, {}, callback);
	    }
	  }, {
	    key: "reload",
	    value: function reload(languages, namespaces, callback) {
	      this.prepareLoading(languages, namespaces, {
	        reload: true
	      }, callback);
	    }
	  }, {
	    key: "loadOne",
	    value: function loadOne(name) {
	      var _this5 = this;

	      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

	      var _name$split3 = name.split('|'),
	          _name$split4 = _slicedToArray(_name$split3, 2),
	          lng = _name$split4[0],
	          ns = _name$split4[1];

	      this.read(lng, ns, 'read', null, null, function (err, data) {
	        if (err) _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err);
	        if (!err && data) _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data);

	        _this5.loaded(name, err, data);
	      });
	    }
	  }, {
	    key: "saveMissing",
	    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
	      var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

	      if (this.backend && this.backend.create) {
	        this.backend.create(languages, namespace, key, fallbackValue, null
	        /* unused callback */
	        , _objectSpread({}, options, {
	          isUpdate: isUpdate
	        }));
	      } // write to store to avoid resending


	      if (!languages || !languages[0]) return;
	      this.store.addResource(languages[0], namespace, key, fallbackValue);
	    }
	  }]);

	  return Connector;
	}(EventEmitter);

	function get() {
	  return {
	    debug: false,
	    initImmediate: true,
	    ns: ['translation'],
	    defaultNS: ['translation'],
	    fallbackLng: ['dev'],
	    fallbackNS: false,
	    // string or array of namespaces
	    whitelist: false,
	    // array with whitelisted languages
	    nonExplicitWhitelist: false,
	    load: 'all',
	    // | currentOnly | languageOnly
	    preload: false,
	    // array with preload languages
	    simplifyPluralSuffix: true,
	    keySeparator: '.',
	    nsSeparator: ':',
	    pluralSeparator: '_',
	    contextSeparator: '_',
	    partialBundledLanguages: false,
	    // allow bundling certain languages that are not remotely fetched
	    saveMissing: false,
	    // enable to send missing values
	    updateMissing: false,
	    // enable to update default values if different from translated value (only useful on initial development, or when keeping code as source of truth)
	    saveMissingTo: 'fallback',
	    // 'current' || 'all'
	    saveMissingPlurals: true,
	    // will save all forms not only singular key
	    missingKeyHandler: false,
	    // function(lng, ns, key, fallbackValue) -> override if prefer on handling
	    missingInterpolationHandler: false,
	    // function(str, match)
	    postProcess: false,
	    // string or array of postProcessor names
	    returnNull: true,
	    // allows null value as valid translation
	    returnEmptyString: true,
	    // allows empty string value as valid translation
	    returnObjects: false,
	    joinArrays: false,
	    // or string to join array
	    returnedObjectHandler: false,
	    // function(key, value, options) triggered if key returns object but returnObjects is set to false
	    parseMissingKeyHandler: false,
	    // function(key) parsed a key that was not found in t() before returning
	    appendNamespaceToMissingKey: false,
	    appendNamespaceToCIMode: false,
	    overloadTranslationOptionHandler: function handle(args) {
	      var ret = {};
	      if (_typeof(args[1]) === 'object') ret = args[1];
	      if (typeof args[1] === 'string') ret.defaultValue = args[1];
	      if (typeof args[2] === 'string') ret.tDescription = args[2];

	      if (_typeof(args[2]) === 'object' || _typeof(args[3]) === 'object') {
	        var options = args[3] || args[2];
	        Object.keys(options).forEach(function (key) {
	          ret[key] = options[key];
	        });
	      }

	      return ret;
	    },
	    interpolation: {
	      escapeValue: true,
	      format: function format(value, _format, lng) {
	        return value;
	      },
	      prefix: '{{',
	      suffix: '}}',
	      formatSeparator: ',',
	      // prefixEscaped: '{{',
	      // suffixEscaped: '}}',
	      // unescapeSuffix: '',
	      unescapePrefix: '-',
	      nestingPrefix: '$t(',
	      nestingSuffix: ')',
	      // nestingPrefixEscaped: '$t(',
	      // nestingSuffixEscaped: ')',
	      // defaultVariables: undefined // object that can have values to interpolate on - extends passed in interpolation data
	      maxReplaces: 1000 // max replaces to prevent endless loop

	    }
	  };
	}
	/* eslint no-param-reassign: 0 */

	function transformOptions(options) {
	  // create namespace object if namespace is passed in as string
	  if (typeof options.ns === 'string') options.ns = [options.ns];
	  if (typeof options.fallbackLng === 'string') options.fallbackLng = [options.fallbackLng];
	  if (typeof options.fallbackNS === 'string') options.fallbackNS = [options.fallbackNS]; // extend whitelist with cimode

	  if (options.whitelist && options.whitelist.indexOf('cimode') < 0) {
	    options.whitelist = options.whitelist.concat(['cimode']);
	  }

	  return options;
	}

	function noop() {}

	var I18n =
	/*#__PURE__*/
	function (_EventEmitter) {
	  _inherits(I18n, _EventEmitter);

	  function I18n() {
	    var _this;

	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var callback = arguments.length > 1 ? arguments[1] : undefined;

	    _classCallCheck(this, I18n);

	    _this = _possibleConstructorReturn(this, _getPrototypeOf(I18n).call(this));
	    EventEmitter.call(_assertThisInitialized(_this)); // <=IE10 fix (unable to call parent constructor)

	    _this.options = transformOptions(options);
	    _this.services = {};
	    _this.logger = baseLogger;
	    _this.modules = {
	      external: []
	    };

	    if (callback && !_this.isInitialized && !options.isClone) {
	      // https://github.com/i18next/i18next/issues/879
	      if (!_this.options.initImmediate) {
	        _this.init(options, callback);

	        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
	      }

	      setTimeout(function () {
	        _this.init(options, callback);
	      }, 0);
	    }

	    return _this;
	  }

	  _createClass(I18n, [{
	    key: "init",
	    value: function init() {
	      var _this2 = this;

	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var callback = arguments.length > 1 ? arguments[1] : undefined;

	      if (typeof options === 'function') {
	        callback = options;
	        options = {};
	      }

	      this.options = _objectSpread({}, get(), this.options, transformOptions(options));
	      this.format = this.options.interpolation.format;
	      if (!callback) callback = noop;

	      function createClassOnDemand(ClassOrObject) {
	        if (!ClassOrObject) return null;
	        if (typeof ClassOrObject === 'function') return new ClassOrObject();
	        return ClassOrObject;
	      } // init services


	      if (!this.options.isClone) {
	        if (this.modules.logger) {
	          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
	        } else {
	          baseLogger.init(null, this.options);
	        }

	        var lu = new LanguageUtil(this.options);
	        this.store = new ResourceStore(this.options.resources, this.options);
	        var s = this.services;
	        s.logger = baseLogger;
	        s.resourceStore = this.store;
	        s.languageUtils = lu;
	        s.pluralResolver = new PluralResolver(lu, {
	          prepend: this.options.pluralSeparator,
	          compatibilityJSON: this.options.compatibilityJSON,
	          simplifyPluralSuffix: this.options.simplifyPluralSuffix
	        });
	        s.interpolator = new Interpolator(this.options);
	        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options); // pipe events from backendConnector

	        s.backendConnector.on('*', function (event) {
	          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	            args[_key - 1] = arguments[_key];
	          }

	          _this2.emit.apply(_this2, [event].concat(args));
	        });

	        if (this.modules.languageDetector) {
	          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
	          s.languageDetector.init(s, this.options.detection, this.options);
	        }

	        if (this.modules.i18nFormat) {
	          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
	          if (s.i18nFormat.init) s.i18nFormat.init(this);
	        }

	        this.translator = new Translator(this.services, this.options); // pipe events from translator

	        this.translator.on('*', function (event) {
	          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	            args[_key2 - 1] = arguments[_key2];
	          }

	          _this2.emit.apply(_this2, [event].concat(args));
	        });
	        this.modules.external.forEach(function (m) {
	          if (m.init) m.init(_this2);
	        });
	      } // append api


	      var storeApi = ['getResource', 'addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
	      storeApi.forEach(function (fcName) {
	        _this2[fcName] = function () {
	          var _this2$store;

	          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
	        };
	      });
	      var deferred = defer();

	      var load = function load() {
	        _this2.changeLanguage(_this2.options.lng, function (err, t) {
	          _this2.isInitialized = true;

	          _this2.logger.log('initialized', _this2.options);

	          _this2.emit('initialized', _this2.options);

	          deferred.resolve(t); // not rejecting on err (as err is only a loading translation failed warning)

	          callback(err, t);
	        });
	      };

	      if (this.options.resources || !this.options.initImmediate) {
	        load();
	      } else {
	        setTimeout(load, 0);
	      }

	      return deferred;
	    }
	    /* eslint consistent-return: 0 */

	  }, {
	    key: "loadResources",
	    value: function loadResources() {
	      var _this3 = this;

	      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;

	      if (!this.options.resources || this.options.partialBundledLanguages) {
	        if (this.language && this.language.toLowerCase() === 'cimode') return callback(); // avoid loading resources for cimode

	        var toLoad = [];

	        var append = function append(lng) {
	          if (!lng) return;

	          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);

	          lngs.forEach(function (l) {
	            if (toLoad.indexOf(l) < 0) toLoad.push(l);
	          });
	        };

	        if (!this.language) {
	          // at least load fallbacks in this case
	          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
	          fallbacks.forEach(function (l) {
	            return append(l);
	          });
	        } else {
	          append(this.language);
	        }

	        if (this.options.preload) {
	          this.options.preload.forEach(function (l) {
	            return append(l);
	          });
	        }

	        this.services.backendConnector.load(toLoad, this.options.ns, callback);
	      } else {
	        callback(null);
	      }
	    }
	  }, {
	    key: "reloadResources",
	    value: function reloadResources(lngs, ns, callback) {
	      var deferred = defer();
	      if (!lngs) lngs = this.languages;
	      if (!ns) ns = this.options.ns;
	      if (!callback) callback = noop;
	      this.services.backendConnector.reload(lngs, ns, function (err) {
	        deferred.resolve(); // not rejecting on err (as err is only a loading translation failed warning)

	        callback(err);
	      });
	      return deferred;
	    }
	  }, {
	    key: "use",
	    value: function use(module) {
	      if (module.type === 'backend') {
	        this.modules.backend = module;
	      }

	      if (module.type === 'logger' || module.log && module.warn && module.error) {
	        this.modules.logger = module;
	      }

	      if (module.type === 'languageDetector') {
	        this.modules.languageDetector = module;
	      }

	      if (module.type === 'i18nFormat') {
	        this.modules.i18nFormat = module;
	      }

	      if (module.type === 'postProcessor') {
	        postProcessor.addPostProcessor(module);
	      }

	      if (module.type === '3rdParty') {
	        this.modules.external.push(module);
	      }

	      return this;
	    }
	  }, {
	    key: "changeLanguage",
	    value: function changeLanguage(lng, callback) {
	      var _this4 = this;

	      var deferred = defer();
	      this.emit('languageChanging', lng);

	      var done = function done(err, l) {
	        _this4.translator.changeLanguage(l);

	        if (l) {
	          _this4.emit('languageChanged', l);

	          _this4.logger.log('languageChanged', l);
	        }

	        deferred.resolve(function () {
	          return _this4.t.apply(_this4, arguments);
	        });
	        if (callback) callback(err, function () {
	          return _this4.t.apply(_this4, arguments);
	        });
	      };

	      var setLng = function setLng(l) {
	        if (l) {
	          _this4.language = l;
	          _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
	          if (!_this4.translator.language) _this4.translator.changeLanguage(l);
	          if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);
	        }

	        _this4.loadResources(function (err) {
	          done(err, l);
	        });
	      };

	      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
	        setLng(this.services.languageDetector.detect());
	      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
	        this.services.languageDetector.detect(setLng);
	      } else {
	        setLng(lng);
	      }

	      return deferred;
	    }
	  }, {
	    key: "getFixedT",
	    value: function getFixedT(lng, ns) {
	      var _this5 = this;

	      var fixedT = function fixedT(key, opts) {
	        var options = _objectSpread({}, opts);

	        if (_typeof(opts) !== 'object') {
	          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
	            rest[_key3 - 2] = arguments[_key3];
	          }

	          options = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
	        }

	        options.lng = options.lng || fixedT.lng;
	        options.lngs = options.lngs || fixedT.lngs;
	        options.ns = options.ns || fixedT.ns;
	        return _this5.t(key, options);
	      };

	      if (typeof lng === 'string') {
	        fixedT.lng = lng;
	      } else {
	        fixedT.lngs = lng;
	      }

	      fixedT.ns = ns;
	      return fixedT;
	    }
	  }, {
	    key: "t",
	    value: function t() {
	      var _this$translator;

	      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
	    }
	  }, {
	    key: "exists",
	    value: function exists() {
	      var _this$translator2;

	      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
	    }
	  }, {
	    key: "setDefaultNamespace",
	    value: function setDefaultNamespace(ns) {
	      this.options.defaultNS = ns;
	    }
	  }, {
	    key: "loadNamespaces",
	    value: function loadNamespaces(ns, callback) {
	      var _this6 = this;

	      var deferred = defer();

	      if (!this.options.ns) {
	        callback && callback();
	        return Promise.resolve();
	      }

	      if (typeof ns === 'string') ns = [ns];
	      ns.forEach(function (n) {
	        if (_this6.options.ns.indexOf(n) < 0) _this6.options.ns.push(n);
	      });
	      this.loadResources(function (err) {
	        deferred.resolve();
	        if (callback) callback(err);
	      });
	      return deferred;
	    }
	  }, {
	    key: "loadLanguages",
	    value: function loadLanguages(lngs, callback) {
	      var deferred = defer();
	      if (typeof lngs === 'string') lngs = [lngs];
	      var preloaded = this.options.preload || [];
	      var newLngs = lngs.filter(function (lng) {
	        return preloaded.indexOf(lng) < 0;
	      }); // Exit early if all given languages are already preloaded

	      if (!newLngs.length) {
	        if (callback) callback();
	        return Promise.resolve();
	      }

	      this.options.preload = preloaded.concat(newLngs);
	      this.loadResources(function (err) {
	        deferred.resolve();
	        if (callback) callback(err);
	      });
	      return deferred;
	    }
	  }, {
	    key: "dir",
	    value: function dir(lng) {
	      if (!lng) lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
	      if (!lng) return 'rtl';
	      var rtlLngs = ['ar', 'shu', 'sqr', 'ssh', 'xaa', 'yhd', 'yud', 'aao', 'abh', 'abv', 'acm', 'acq', 'acw', 'acx', 'acy', 'adf', 'ads', 'aeb', 'aec', 'afb', 'ajp', 'apc', 'apd', 'arb', 'arq', 'ars', 'ary', 'arz', 'auz', 'avl', 'ayh', 'ayl', 'ayn', 'ayp', 'bbz', 'pga', 'he', 'iw', 'ps', 'pbt', 'pbu', 'pst', 'prp', 'prd', 'ur', 'ydd', 'yds', 'yih', 'ji', 'yi', 'hbo', 'men', 'xmn', 'fa', 'jpr', 'peo', 'pes', 'prs', 'dv', 'sam'];
	      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? 'rtl' : 'ltr';
	    }
	    /* eslint class-methods-use-this: 0 */

	  }, {
	    key: "createInstance",
	    value: function createInstance() {
	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var callback = arguments.length > 1 ? arguments[1] : undefined;
	      return new I18n(options, callback);
	    }
	  }, {
	    key: "cloneInstance",
	    value: function cloneInstance() {
	      var _this7 = this;

	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

	      var mergedOptions = _objectSpread({}, this.options, options, {
	        isClone: true
	      });

	      var clone = new I18n(mergedOptions);
	      var membersToCopy = ['store', 'services', 'language'];
	      membersToCopy.forEach(function (m) {
	        clone[m] = _this7[m];
	      });
	      clone.translator = new Translator(clone.services, clone.options);
	      clone.translator.on('*', function (event) {
	        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
	          args[_key4 - 1] = arguments[_key4];
	        }

	        clone.emit.apply(clone, [event].concat(args));
	      });
	      clone.init(mergedOptions, callback);
	      clone.translator.options = clone.options; // sync options

	      return clone;
	    }
	  }]);

	  return I18n;
	}(EventEmitter);

	var i18next = new I18n();

	var arr = [];
	var each = arr.forEach;
	var slice = arr.slice;
	function defaults(obj) {
	  each.call(slice.call(arguments, 1), function (source) {
	    if (source) {
	      for (var prop in source) {
	        if (obj[prop] === undefined) obj[prop] = source[prop];
	      }
	    }
	  });
	  return obj;
	}

	function addQueryString(url, params) {
	  if (params && _typeof(params) === 'object') {
	    var queryString = '',
	        e = encodeURIComponent; // Must encode data

	    for (var paramName in params) {
	      queryString += '&' + e(paramName) + '=' + e(params[paramName]);
	    }

	    if (!queryString) {
	      return url;
	    }

	    url = url + (url.indexOf('?') !== -1 ? '&' : '?') + queryString.slice(1);
	  }

	  return url;
	} // https://gist.github.com/Xeoncross/7663273


	function ajax(url, options, callback, data, cache) {
	  if (data && _typeof(data) === 'object') {
	    if (!cache) {
	      data['_t'] = new Date();
	    } // URL encoded form data must be in querystring format


	    data = addQueryString('', data).slice(1);
	  }

	  if (options.queryStringParams) {
	    url = addQueryString(url, options.queryStringParams);
	  }

	  try {
	    var x;

	    if (XMLHttpRequest) {
	      x = new XMLHttpRequest();
	    } else {
	      x = new ActiveXObject('MSXML2.XMLHTTP.3.0');
	    }

	    x.open(data ? 'POST' : 'GET', url, 1);

	    if (!options.crossDomain) {
	      x.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
	    }

	    x.withCredentials = !!options.withCredentials;

	    if (data) {
	      x.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
	    }

	    if (x.overrideMimeType) {
	      x.overrideMimeType("application/json");
	    }

	    var h = options.customHeaders;
	    h = typeof h === 'function' ? h() : h;

	    if (h) {
	      for (var i in h) {
	        x.setRequestHeader(i, h[i]);
	      }
	    }

	    x.onreadystatechange = function () {
	      x.readyState > 3 && callback && callback(x.responseText, x);
	    };

	    x.send(data);
	  } catch (e) {
	    console && console.log(e);
	  }
	}

	function getDefaults() {
	  return {
	    loadPath: '/locales/{{lng}}/{{ns}}.json',
	    addPath: '/locales/add/{{lng}}/{{ns}}',
	    allowMultiLoading: false,
	    parse: JSON.parse,
	    crossDomain: false,
	    ajax: ajax
	  };
	}

	var Backend =
	/*#__PURE__*/
	function () {
	  function Backend(services) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Backend);

	    this.init(services, options);
	    this.type = 'backend';
	  }

	  _createClass(Backend, [{
	    key: "init",
	    value: function init(services) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      this.services = services;
	      this.options = defaults(options, this.options || {}, getDefaults());
	    }
	  }, {
	    key: "readMulti",
	    value: function readMulti(languages, namespaces, callback) {
	      var loadPath = this.options.loadPath;

	      if (typeof this.options.loadPath === 'function') {
	        loadPath = this.options.loadPath(languages, namespaces);
	      }

	      var url = this.services.interpolator.interpolate(loadPath, {
	        lng: languages.join('+'),
	        ns: namespaces.join('+')
	      });
	      this.loadUrl(url, callback);
	    }
	  }, {
	    key: "read",
	    value: function read(language, namespace, callback) {
	      var loadPath = this.options.loadPath;

	      if (typeof this.options.loadPath === 'function') {
	        loadPath = this.options.loadPath([language], [namespace]);
	      }

	      var url = this.services.interpolator.interpolate(loadPath, {
	        lng: language,
	        ns: namespace
	      });
	      this.loadUrl(url, callback);
	    }
	  }, {
	    key: "loadUrl",
	    value: function loadUrl(url, callback) {
	      var _this = this;

	      this.options.ajax(url, this.options, function (data, xhr) {
	        if (xhr.status >= 500 && xhr.status < 600) return callback('failed loading ' + url, true
	        /* retry */
	        );
	        if (xhr.status >= 400 && xhr.status < 500) return callback('failed loading ' + url, false
	        /* no retry */
	        );
	        var ret, err;

	        try {
	          ret = _this.options.parse(data, url);
	        } catch (e) {
	          err = 'failed parsing ' + url + ' to json';
	        }

	        if (err) return callback(err, false);
	        callback(null, ret);
	      });
	    }
	  }, {
	    key: "create",
	    value: function create(languages, namespace, key, fallbackValue) {
	      var _this2 = this;

	      if (typeof languages === 'string') languages = [languages];
	      var payload = {};
	      payload[key] = fallbackValue || '';
	      languages.forEach(function (lng) {
	        var url = _this2.services.interpolator.interpolate(_this2.options.addPath, {
	          lng: lng,
	          ns: namespace
	        });

	        _this2.options.ajax(url, _this2.options, function (data, xhr) {//const statusCode = xhr.status.toString();
	          // TODO: if statusCode === 4xx do log
	        }, payload);
	      });
	    }
	  }]);

	  return Backend;
	}();

	Backend.type = 'backend';

	function _extends() {
	  _extends = Object.assign || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  return _extends.apply(this, arguments);
	}

	/**
	 * 画布
	 * @author tengge / https://github.com/tengge1
	 */

	class Canvas extends React.Component {
	  constructor(props) {
	    super(props);
	    this.dom = React.createRef();
	  }

	  render() {
	    const {
	      className,
	      style,
	      ...others
	    } = this.props;
	    return React.createElement("canvas", _extends({
	      className: bind('Canvas', className),
	      style: style,
	      ref: this.dom
	    }, others));
	  }

	}

	Canvas.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object
	};
	Canvas.defaultProps = {
	  className: null,
	  style: null
	};

	/**
	 * 折叠面板
	 * @author tengge / https://github.com/tengge1
	 */
	class Accordion extends React.Component {
	  render() {
	    return null;
	  }

	}

	/**
	 * 很多按钮
	 * @author tengge / https://github.com/tengge1
	 */
	class Buttons extends React.Component {
	  render() {
	    return null;
	  }

	}

	/**
	 * 列
	 * @author tengge / https://github.com/tengge1
	 */
	class Column extends React.Component {
	  render() {
	    return null;
	  }

	}

	/**
	 * 很多列
	 * @author tengge / https://github.com/tengge1
	 */
	class Columns extends React.Component {
	  render() {
	    return null;
	  }

	}

	/**
	 * 内容
	 * @author tengge / https://github.com/tengge1
	 */
	class Content extends React.Component {
	  render() {
	    return null;
	  }

	}

	/**
	 * 行
	 * @author tengge / https://github.com/tengge1
	 */
	class Row extends React.Component {
	  render() {
	    return null;
	  }

	}

	/**
	 * 很多行
	 * @author tengge / https://github.com/tengge1
	 */
	class Rows extends React.Component {
	  render() {
	    return null;
	  }

	}

	/**
	 * 按钮
	 * @author tengge / https://github.com/tengge1
	 */

	class Button extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onClick);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children,
	      color,
	      disabled
	    } = this.props;
	    return React.createElement("button", {
	      className: bind('Button', color, disabled && 'disabled', className),
	      style: style,
	      disabled: disabled,
	      onClick: this.handleClick
	    }, children);
	  }

	  handleClick(onClick, event) {
	    onClick && onClick(this.props.name, event);
	  }

	}

	Button.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  children: propTypes.node,
	  color: propTypes.oneOf(['primary', 'success', 'warn', 'danger']),
	  disabled: propTypes.bool,
	  onClick: propTypes.func
	};
	Button.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  children: null,
	  color: null,
	  disabled: false,
	  onClick: null
	};

	/**
	 * 复选框
	 * @author tengge / https://github.com/tengge1
	 */

	class CheckBox extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      checked,
	      disabled,
	      onChange
	    } = this.props;
	    return React.createElement("input", {
	      type: 'checkbox',
	      className: bind('CheckBox', checked && 'checked', disabled && 'disabled', className),
	      style: style,
	      checked: checked,
	      disabled: disabled,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(onChange, event) {
	    onChange && onChange(event.target.checked, this.props.name, event);
	  }

	}

	CheckBox.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  checked: propTypes.bool,
	  disabled: propTypes.bool,
	  onChange: propTypes.func
	};
	CheckBox.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  checked: false,
	  disabled: false,
	  onChange: null
	};

	/**
	 * 表单
	 * @author tengge / https://github.com/tengge1
	 */

	class Form extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleSubmit = this.handleSubmit.bind(this, props.onSubmit);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children,
	      direction
	    } = this.props;
	    return React.createElement("form", {
	      className: bind('Form', direction, className),
	      style: style,
	      onSubmit: this.handleSubmit
	    }, children);
	  }

	  handleSubmit(onSubmit) {
	    event.preventDefault();
	    onSubmit && onSubmit();
	  }

	}

	Form.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  direction: propTypes.oneOf(['horizontal', 'vertical']),
	  onSubmit: propTypes.func
	};
	Form.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  direction: 'horizontal',
	  onSubmit: null
	};

	/**
	 * 表单项
	 * @author tengge / https://github.com/tengge1
	 */

	class FormControl extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children
	    } = this.props;
	    return React.createElement("div", {
	      className: bind('FormControl', className),
	      style: style
	    }, children);
	  }

	}

	FormControl.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	FormControl.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 图标按钮
	 * @author tengge / https://github.com/tengge1
	 */

	class IconButton extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onClick);
	  }

	  render() {
	    const {
	      className,
	      style,
	      icon,
	      name,
	      title,
	      selected
	    } = this.props;
	    return React.createElement("button", {
	      className: bind('IconButton', selected && 'selected', className),
	      style: style,
	      title: title,
	      onClick: this.handleClick
	    }, React.createElement("i", {
	      className: bind('iconfont', icon && 'icon-' + icon)
	    }));
	  }

	  handleClick(onClick, event) {
	    onClick && onClick(this.props.name, event);
	  }

	}

	IconButton.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  icon: propTypes.string,
	  name: propTypes.string,
	  title: propTypes.string,
	  selected: propTypes.bool,
	  onClick: propTypes.func
	};
	IconButton.defaultProps = {
	  className: null,
	  style: null,
	  icon: null,
	  name: null,
	  title: null,
	  selected: false,
	  onClick: null
	};

	/**
	 * 图片按钮
	 * @author tengge / https://github.com/tengge1
	 */

	class ImageButton extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onClick);
	  }

	  render() {
	    const {
	      className,
	      style,
	      src,
	      name,
	      title,
	      selected
	    } = this.props;
	    return React.createElement("button", {
	      className: bind('ImageButton', selected && 'selected', className),
	      style: style,
	      title: title,
	      onClick: this.handleClick
	    }, React.createElement("img", {
	      src: src
	    }));
	  }

	  handleClick(onClick, event) {
	    onClick && onClick(this.props.name, event);
	  }

	}

	ImageButton.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  src: propTypes.string,
	  name: propTypes.string,
	  title: propTypes.string,
	  selected: propTypes.bool,
	  onClick: propTypes.func
	};
	ImageButton.defaultProps = {
	  className: null,
	  style: null,
	  src: null,
	  name: null,
	  title: null,
	  selected: false,
	  onClick: null
	};

	/**
	 * 输入框
	 * @author tengge / https://github.com/tengge1
	 */

	class Input extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	    this.handleInput = this.handleInput.bind(this, props.onInput);
	  }

	  render() {
	    const {
	      className,
	      style,
	      name,
	      type,
	      value,
	      min,
	      max,
	      step,
	      show,
	      disabled
	    } = this.props;
	    let val = value === undefined || value === null ? '' : value;
	    return React.createElement("input", {
	      className: bind('Input', !show && 'hidden', className),
	      style: style,
	      type: type,
	      value: val,
	      min: min,
	      max: max,
	      step: step,
	      disabled: disabled,
	      onChange: this.handleChange,
	      onInput: this.handleInput
	    });
	  }

	  handleChange(onChange, event) {
	    const value = event.target.value;

	    if (this.props.type === 'number') {
	      if (value.trim() !== '') {
	        const precision = this.props.precision;

	        if (precision === 0) {
	          onChange && onChange(parseInt(value), this.props.name, event);
	        } else {
	          onChange && onChange(parseInt(parseFloat(value) * 10 ** precision) / 10 ** precision, this.props.name, event);
	        }
	      } else {
	        onChange && onChange(null, this.props.name, event);
	      }
	    } else {
	      onChange && onChange(value, this.props.name, event);
	    }
	  }

	  handleInput(onInput, event) {
	    const value = event.target.value;

	    if (this.props.type === 'number') {
	      if (value.trim() !== '') {
	        onInput && onInput(parseFloat(value), this.props.name, event);
	      } else {
	        onInput && onInput(null, this.props.name, event);
	      }
	    } else {
	      onInput && onInput(value, this.props.name, event);
	    }
	  }

	}

	Input.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  type: propTypes.oneOf(['text', 'number', 'color']),
	  value: propTypes.oneOfType([propTypes.string, propTypes.number]),
	  min: propTypes.number,
	  max: propTypes.number,
	  step: propTypes.number,
	  precision: propTypes.number,
	  disabled: propTypes.bool,
	  show: propTypes.bool,
	  onChange: propTypes.func,
	  onInput: propTypes.func
	};
	Input.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  type: 'text',
	  value: '',
	  min: null,
	  max: null,
	  step: null,
	  precision: 3,
	  disabled: false,
	  show: true,
	  onChange: null,
	  onInput: null
	};

	/**
	 * 标签
	 * @author tengge / https://github.com/tengge1
	 */

	class Label extends React.Component {
	  constructor(props) {
	    super(props);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children
	    } = this.props;
	    return React.createElement("label", {
	      className: bind('Label', className),
	      style: style
	    }, children);
	  }

	}

	Label.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	Label.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 单选框
	 * @author tengge / https://github.com/tengge1
	 */

	class Radio extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      checked,
	      disabled
	    } = this.props;
	    return React.createElement("input", {
	      type: 'radio',
	      className: bind('Radio', checked && 'checked', disabled && 'disabled', className),
	      style: style,
	      checked: checked,
	      disabled: disabled,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(onChange, event) {
	    onChange && onChange(event.target.checked, this.props.name, event);
	  }

	}

	Radio.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  checked: propTypes.bool,
	  disabled: propTypes.bool,
	  onChange: propTypes.func
	};
	Radio.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  checked: false,
	  disabled: false,
	  onChange: null
	};

	/**
	 * 搜索框
	 * @author tengge / https://github.com/tengge1
	 */

	class SearchField extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      value: props.value,
	      categories: [],
	      filterShow: false
	    };
	    this.handleAdd = this.handleAdd.bind(this, props.onAdd);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	    this.handleInput = this.handleInput.bind(this, props.onInput);
	    this.handleReset = this.handleReset.bind(this, props.onInput, props.onChange);
	    this.handleShowFilter = this.handleShowFilter.bind(this);
	    this.handleHideFilter = this.handleHideFilter.bind(this);
	    this.handleCheckBoxChange = this.handleCheckBoxChange.bind(this, props.onInput, props.onChange);
	    this.stopPropagation = this.stopPropagation.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      data,
	      placeholder,
	      addHidden
	    } = this.props;
	    const {
	      value,
	      categories,
	      filterShow
	    } = this.state;
	    return React.createElement("div", {
	      className: bind('SearchField', className),
	      onClick: this.stopPropagation
	    }, React.createElement(IconButton, {
	      className: bind(addHidden && 'hidden'),
	      icon: 'add',
	      onClick: this.handleAdd
	    }), React.createElement("input", {
	      className: 'input',
	      style: style,
	      placeholder: placeholder,
	      value: value,
	      onChange: this.handleChange,
	      onInput: this.handleInput,
	      onKeyDown: this.handleKeyDown
	    }), React.createElement(IconButton, {
	      icon: 'close',
	      onClick: this.handleReset
	    }), React.createElement(IconButton, {
	      icon: 'filter',
	      className: bind(filterShow && 'selected'),
	      onClick: this.handleShowFilter
	    }), React.createElement("div", {
	      className: bind('category', !filterShow && 'hidden')
	    }, React.createElement("div", {
	      className: 'item',
	      key: ''
	    }, React.createElement(CheckBox, {
	      name: '',
	      checked: categories.indexOf('') > -1,
	      onChange: this.handleCheckBoxChange
	    }), React.createElement("label", {
	      className: 'title'
	    }, _t('No Type'))), data.map(n => {
	      return React.createElement("div", {
	        className: 'item',
	        key: n.ID
	      }, React.createElement(CheckBox, {
	        name: n.ID,
	        checked: categories.indexOf(n.ID) > -1,
	        onChange: this.handleCheckBoxChange
	      }), React.createElement("label", {
	        className: 'title'
	      }, n.Name));
	    })));
	  }

	  componentDidMount() {
	    document.addEventListener(`click`, this.handleHideFilter);
	  }

	  handleAdd(onAdd, event) {
	    onAdd && onAdd(event);
	  }

	  handleChange(onChange, event) {
	    event.stopPropagation();
	    const value = event.target.value;
	    this.setState({
	      value
	    });
	    onChange && onChange(value, this.state.categories, event);
	  }

	  handleInput(onInput, event) {
	    event.stopPropagation();
	    const value = event.target.value;
	    this.setState({
	      value
	    });
	    onInput && onInput(value, this.state.categories, event);
	  }

	  handleReset(onInput, onChange, event) {
	    const value = '';
	    this.setState({
	      value
	    });
	    onInput && onInput(value, this.state.categories, event);
	    onChange && onChange(value, this.state.categories, event);
	  }

	  handleShowFilter(name, event) {
	    this.setState({
	      filterShow: !this.state.filterShow
	    });
	  }

	  handleHideFilter() {
	    this.setState({
	      filterShow: false
	    });
	  }

	  handleCheckBoxChange(onInput, onChange, checked, name, event) {
	    let categories = this.state.categories;
	    let index = categories.indexOf(name);

	    if (checked && index === -1) {
	      categories.push(name);
	    } else if (!checked && index > -1) {
	      categories.splice(index, 1);
	    } else {
	      console.warn(`SearchField: handleCheckBoxChange error.`);
	      return;
	    }

	    const value = this.state.value;
	    this.setState({
	      categories
	    }, () => {
	      onInput && onInput(value, categories, event);
	      onChange && onChange(value, categories, event);
	    });
	  }

	  stopPropagation(event) {
	    event.nativeEvent.stopImmediatePropagation();
	  }

	}

	SearchField.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  value: propTypes.string,
	  data: propTypes.array,
	  placeholder: propTypes.string,
	  onAdd: propTypes.func,
	  onChange: propTypes.func,
	  onInput: propTypes.func,
	  addHidden: propTypes.bool
	};
	SearchField.defaultProps = {
	  className: null,
	  style: null,
	  value: '',
	  data: [],
	  placeholder: 'Enter a keyword',
	  onAdd: null,
	  onChange: null,
	  onInput: null,
	  addHidden: false
	};

	/**
	 * 输入框
	 * @author tengge / https://github.com/tengge1
	 */

	class Select extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      options,
	      value,
	      disabled
	    } = this.props;
	    return React.createElement("select", {
	      className: bind('Select', className),
	      style: style,
	      value: value,
	      disabled: disabled,
	      onChange: this.handleChange
	    }, options && Object.keys(options).map(n => {
	      return React.createElement("option", {
	        value: n,
	        key: n
	      }, options[n]);
	    }));
	  }

	  handleChange(onChange, event) {
	    const selectedIndex = event.target.selectedIndex;

	    if (selectedIndex === -1) {
	      onChange && onChange(null, event);
	      return;
	    }

	    const value = event.target.options[selectedIndex].value; // 注意：options的key一定是字符串，所以value也一定是字符串

	    onChange && onChange(value, this.props.name, event);
	  }

	}

	Select.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  options: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.oneOfType([propTypes.string, propTypes.number]),
	  disabled: propTypes.bool,
	  onChange: propTypes.func
	};
	Select.defaultProps = {
	  className: null,
	  style: null,
	  options: null,
	  name: null,
	  value: null,
	  disabled: false,
	  onChange: null
	};

	/**
	 * 文本域
	 * @author tengge / https://github.com/tengge1
	 */

	class TextArea extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	    this.handleInput = this.handleInput.bind(this, props.onInput);
	  }

	  render() {
	    const {
	      className,
	      style,
	      value
	    } = this.props;
	    return React.createElement("textarea", {
	      className: bind('TextArea', className),
	      style: style,
	      value: this.state.value,
	      onChange: this.handleChange,
	      onInput: this.handleInput
	    });
	  }

	  handleChange(onChange, event) {
	    onChange && onChange(event.target.value, this.props.name, event);
	  }

	  handleInput(onInput, event) {
	    onInput && onInput(event.target.value, this.props.name, event);
	  }

	}

	TextArea.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.string,
	  onChange: propTypes.func,
	  onInput: propTypes.func
	};
	TextArea.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: '',
	  onChange: null,
	  onInput: null
	};

	/**
	 * 开关
	 * @author tengge / https://github.com/tengge1
	 */

	class Toggle extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      checked,
	      disabled,
	      onChange
	    } = this.props;
	    return React.createElement("div", {
	      className: bind('Toggle', checked && 'checked', disabled && 'disabled', className),
	      style: style,
	      onClick: disabled ? null : this.handleChange
	    });
	  }

	  handleChange(onChange, event) {
	    var checked = event.target.classList.contains('checked');
	    onChange && onChange(!checked, this.props.name, event);
	  }

	}

	Toggle.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  checked: propTypes.bool,
	  disabled: propTypes.bool,
	  onChange: propTypes.func
	};
	Toggle.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  checked: false,
	  disabled: false,
	  onChange: null
	};

	/**
	 * 图标
	 * @author tengge / https://github.com/tengge1
	 */

	class Icon extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onClick);
	  }

	  render() {
	    const {
	      className,
	      style,
	      name,
	      value,
	      icon,
	      title
	    } = this.props;
	    return React.createElement("i", {
	      className: bind('Icon', 'iconfont', icon && 'icon-' + icon, className),
	      style: style,
	      name: name,
	      value: value,
	      title: title,
	      onClick: this.handleClick
	    });
	  }

	  handleClick(onClick, event) {
	    const name = event.target.getAttribute('name');
	    onClick && onClick(name, event);
	  }

	}

	Icon.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.string,
	  icon: propTypes.string,
	  title: propTypes.string,
	  onClick: propTypes.func
	};
	Icon.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: null,
	  icon: null,
	  title: null,
	  onClick: null
	};

	/**
	 * 图片
	 * @author tengge / https://github.com/tengge1
	 */

	class Image$1 extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleError = this.handleError.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      src,
	      title
	    } = this.props;
	    return React.createElement("img", {
	      className: bind('Image', className),
	      style: style,
	      src: src,
	      title: title,
	      onError: this.handleError
	    });
	  }

	  handleError(event) {
	    let target = event.target;
	    let parent = target.parentNode;
	    parent.removeChild(target);
	    let img = document.createElement('div');
	    img.className = 'no-img';
	    let icon = document.createElement('i');
	    icon.className = 'Icon iconfont icon-scenes';
	    img.appendChild(icon);
	    let title = parent.children[0];
	    parent.insertBefore(img, title);
	  }

	}

	Image$1.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  src: propTypes.string,
	  title: propTypes.string
	};
	Image$1.defaultProps = {
	  className: null,
	  style: null,
	  src: null,
	  title: null
	};

	/**
	 * 图片列表
	 * @author tengge / https://github.com/tengge1
	 */

	class ImageList extends React.Component {
	  constructor(props) {
	    super(props);
	    const {
	      onClick,
	      onEdit,
	      onDelete
	    } = props;
	    this.state = {
	      pageSize: 10,
	      pageNum: 0
	    };
	    this.handleFirstPage = this.handleFirstPage.bind(this);
	    this.handleLastPage = this.handleLastPage.bind(this);
	    this.handlePreviousPage = this.handlePreviousPage.bind(this);
	    this.handleNextPage = this.handleNextPage.bind(this);
	    this.handleClick = this.handleClick.bind(this, onClick);
	    this.handleEdit = this.handleEdit.bind(this, onEdit);
	    this.handleDelete = this.handleDelete.bind(this, onDelete);
	    this.handleError = this.handleError.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      data,
	      firstPageText,
	      lastPageText,
	      currentPageText,
	      previousPageText,
	      nextPageText
	    } = this.props;
	    const {
	      pageSize,
	      pageNum
	    } = this.state;
	    const totalPage = this.getTotalPage();
	    const current = data.filter((n, i) => {
	      return i >= pageSize * pageNum && i < pageSize * (pageNum + 1);
	    });
	    return React.createElement("div", {
	      className: bind('ImageList', className),
	      style: style
	    }, React.createElement("div", {
	      className: 'content'
	    }, current.map(n => {
	      return React.createElement("div", {
	        className: 'item',
	        name: n.id,
	        key: n.id,
	        onClick: this.handleClick
	      }, n.src ? React.createElement("img", {
	        className: 'img',
	        src: n.src,
	        onError: this.handleError
	      }) : React.createElement("div", {
	        className: 'no-img'
	      }, React.createElement(Icon, {
	        icon: n.icon
	      })), React.createElement("div", {
	        className: 'title'
	      }, n.title), n.cornerText && React.createElement("div", {
	        className: 'cornerText'
	      }, n.cornerText), React.createElement(IconButton, {
	        className: 'edit',
	        icon: 'edit',
	        name: n.id,
	        onClick: this.handleEdit
	      }), React.createElement(IconButton, {
	        className: 'delete',
	        icon: 'delete',
	        name: n.id,
	        onClick: this.handleDelete
	      }));
	    })), React.createElement("div", {
	      className: 'page'
	    }, React.createElement(IconButton, {
	      icon: 'backward',
	      title: firstPageText,
	      onClick: this.handleFirstPage
	    }), React.createElement(IconButton, {
	      icon: 'left-triangle2',
	      title: previousPageText,
	      onClick: this.handlePreviousPage
	    }), React.createElement(Input, {
	      className: 'current',
	      value: (pageNum + 1).toString(),
	      title: currentPageText,
	      disabled: true
	    }), React.createElement(IconButton, {
	      icon: 'right-triangle2',
	      title: nextPageText,
	      onClick: this.handleNextPage
	    }), React.createElement(IconButton, {
	      icon: 'forward',
	      title: lastPageText,
	      onClick: this.handleLastPage
	    }), React.createElement("div", {
	      className: 'info'
	    }, _t('Total {{totalPage}} Pages', {
	      totalPage: totalPage
	    }))));
	  }

	  handleFirstPage() {
	    this.setState({
	      pageNum: 0
	    });
	  }

	  handleLastPage() {
	    const totalPage = this.getTotalPage();
	    this.setState({
	      pageNum: totalPage < 1 ? 0 : totalPage - 1
	    });
	  }

	  handleNextPage() {
	    this.setState(state => {
	      const totalPage = this.getTotalPage();
	      return {
	        pageNum: state.pageNum < totalPage - 1 ? state.pageNum + 1 : totalPage - 1
	      };
	    });
	  }

	  handlePreviousPage() {
	    this.setState(state => {
	      return {
	        pageNum: state.pageNum > 0 ? state.pageNum - 1 : 0
	      };
	    });
	  }

	  handleClick(onClick, event) {
	    event.stopPropagation();
	    const id = event.target.getAttribute('name');
	    const data = this.props.data.filter(n => n.id === id)[0];
	    onClick && onClick(data, event);
	  }

	  handleEdit(onEdit, name, event) {
	    event.stopPropagation();
	    const data = this.props.data.filter(n => n.id === name)[0];
	    onEdit && onEdit(data, event);
	  }

	  handleDelete(onDelete, name, event) {
	    event.stopPropagation();
	    const data = this.props.data.filter(n => n.id === name)[0];
	    onDelete && onDelete(data, event);
	  }

	  handleError(event) {
	    let target = event.target;
	    let parent = target.parentNode;
	    parent.removeChild(target);
	    let img = document.createElement('div');
	    img.className = 'no-img';
	    let icon = document.createElement('i');
	    icon.className = 'Icon iconfont icon-scenes';
	    img.appendChild(icon);
	    let title = parent.children[0];
	    parent.insertBefore(img, title);
	  }

	  getTotalPage() {
	    const total = this.props.data.length;
	    const pageSize = this.state.pageSize;
	    return total % pageSize === 0 ? total / pageSize : parseInt(total / pageSize) + 1;
	  }

	}

	ImageList.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  data: propTypes.array,
	  onClick: propTypes.func,
	  onEdit: propTypes.func,
	  onDelete: propTypes.func,
	  firstPageText: propTypes.string,
	  lastPageText: propTypes.string,
	  currentPageText: propTypes.string,
	  previousPageText: propTypes.string,
	  nextPageText: propTypes.string
	};
	ImageList.defaultProps = {
	  className: null,
	  style: null,
	  data: [],
	  onClick: null,
	  onEdit: null,
	  onDelete: null,
	  firstPageText: 'First Page',
	  lastPageText: 'Last Page',
	  currentPageText: 'Current Page',
	  previousPageText: 'Previous Page',
	  nextPageText: 'Next Page'
	};

	/**
	 * 图片上传控件
	 * @author tengge / https://github.com/tengge1
	 */

	class ImageUploader extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      url,
	      server,
	      noImageText
	    } = this.props;

	    if (url && url != 'null') {
	      return React.createElement("img", {
	        className: bind('ImageUploader', className),
	        src: server + url,
	        onClick: this.handleSelect
	      });
	    } else {
	      return React.createElement("div", {
	        className: bind('ImageUploader', 'empty', className),
	        onClick: this.handleSelect
	      }, noImageText);
	    }
	  }

	  componentDidMount() {
	    var input = document.createElement('input');
	    input.type = 'file';
	    input.style.display = 'none';
	    input.addEventListener('change', this.handleChange);
	    document.body.appendChild(input);
	    this.input = input;
	  }

	  componentWillUnmount() {
	    var input = this.input;
	    input.removeEventListener('change', this.handleChange);
	    document.body.removeChild(input);
	    this.input = null;
	  }

	  handleSelect() {
	    this.input.click();
	  }

	  handleChange(onChange, event) {
	    onChange && onChange(event.target.files[0], event);
	  }

	}

	ImageUploader.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  url: propTypes.string,
	  server: propTypes.string,
	  noImageText: propTypes.string,
	  onChange: propTypes.func
	};
	ImageUploader.defaultProps = {
	  className: null,
	  style: null,
	  url: null,
	  server: '',
	  noImageText: 'No Image',
	  onChange: null
	};

	/**
	 * 绝对定位布局
	 * @author tengge / https://github.com/tengge1
	 */

	class AbsoluteLayout extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      left,
	      top,
	      ...others
	    } = this.props;
	    const position = {
	      left: left || 0,
	      top: top || 0
	    };
	    return React.createElement("div", _extends({
	      className: bind('AbsoluteLayout', className),
	      style: style ? Object.assign({}, style, position) : position
	    }, others), children);
	  }

	}

	AbsoluteLayout.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  left: propTypes.string,
	  top: propTypes.string
	};
	AbsoluteLayout.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  left: '0',
	  top: '0'
	};

	/**
	 * 单个折叠面板
	 * @private
	 * @author tengge / https://github.com/tengge1
	 */

	class AccordionPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      maximized: props.maximized
	    };
	    this.handleClick = this.handleClick.bind(this, props.onClick, props.index, props.name);
	    this.handleMaximize = this.handleMaximize.bind(this, props.onMaximize);
	  }

	  handleClick(onClick, index, name, event) {
	    onClick && onClick(index, name, event);
	  }

	  handleMaximize(onMaximize, event) {
	    this.setState(state => ({
	      maximized: !state.maximized
	    }));
	    onMaximize && onMaximize(event);
	  }

	  render() {
	    const {
	      title,
	      className,
	      style,
	      children,
	      show,
	      total,
	      index,
	      collpased,
	      maximizable,
	      maximized,
	      onMaximize
	    } = this.props;
	    const maximizeControl = maximizable && React.createElement("div", {
	      className: 'control',
	      onClick: this.handleMaximize
	    }, this.state.maximized ? React.createElement("i", {
	      className: 'iconfont icon-minimize'
	    }) : React.createElement("i", {
	      className: 'iconfont icon-maximize'
	    }));

	    const _style = collpased ? style : Object.assign({}, style, {
	      height: `calc(100% - ${26 * (total - 1)}px`
	    });

	    return React.createElement("div", {
	      className: bind('AccordionPanel', this.state.maximized && 'maximized', collpased && 'collpased', !show && 'hidden', className),
	      style: _style
	    }, React.createElement("div", {
	      className: 'header',
	      onClick: this.handleClick
	    }, React.createElement("span", {
	      className: "title"
	    }, title), React.createElement("div", {
	      className: "controls"
	    }, maximizeControl)), React.createElement("div", {
	      className: 'body'
	    }, children));
	  }

	}

	AccordionPanel.propTypes = {
	  name: propTypes.string,
	  title: propTypes.string,
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  show: propTypes.bool,
	  total: propTypes.number,
	  index: propTypes.number,
	  collpased: propTypes.bool,
	  maximizable: propTypes.bool,
	  maximized: propTypes.bool,
	  onMaximize: propTypes.bool,
	  onClick: propTypes.func
	};
	AccordionPanel.defaultProps = {
	  name: null,
	  title: null,
	  className: null,
	  style: null,
	  children: null,
	  show: true,
	  total: 1,
	  index: 0,
	  collpased: true,
	  maximizable: false,
	  maximized: false,
	  onMaximize: null,
	  onClick: null
	};

	/**
	 * 折叠布局
	 * @author tengge / https://github.com/tengge1
	 */

	class AccordionLayout extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      activeIndex: props.activeIndex
	    };
	    this.handleClick = this.handleClick.bind(this, props.onActive);
	  }

	  handleClick(onActive, index, name, event) {
	    onActive && onActive(index, name, event);
	    this.setState({
	      activeIndex: index
	    });
	  }

	  render() {
	    const {
	      className,
	      style,
	      children
	    } = this.props;
	    const content = Array.isArray(children) ? children : [children];
	    return React.createElement("div", {
	      className: bind('AccordionLayout', className),
	      style: style
	    }, content.map((n, i) => {
	      return React.createElement(AccordionPanel, {
	        name: n.props.name,
	        title: n.props.title,
	        show: n.props.show,
	        total: content.length,
	        index: i,
	        collpased: i !== this.state.activeIndex,
	        maximizable: n.props.maximizable,
	        onClick: this.handleClick,
	        key: i
	      }, n.props.children);
	    }));
	  }

	}

	AccordionLayout.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  activeIndex: propTypes.number,
	  onActive: propTypes.func
	};
	AccordionLayout.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  activeIndex: 0,
	  onActive: null
	};

	/**
	 * 边框布局
	 * @author tengge / https://github.com/tengge1
	 */

	class BorderLayout extends React.Component {
	  constructor(props) {
	    super(props);
	    const children = this.props.children;
	    const north = children && children.filter(n => n.props.region === 'north')[0];
	    const south = children && children.filter(n => n.props.region === 'south')[0];
	    const west = children && children.filter(n => n.props.region === 'west')[0];
	    const east = children && children.filter(n => n.props.region === 'east')[0];
	    const center = children && children.filter(n => n.props.region === 'center')[0];
	    const northSplit = north && north.props.split || false;
	    const southSplit = south && south.props.split || false;
	    const westSplit = west && west.props.split || false;
	    const eastSplit = east && east.props.split || false;
	    const northCollapsed = north && north.props.collapsed || false;
	    const southCollapsed = south && south.props.collapsed || false;
	    const westCollapsed = west && west.props.collapsed || false;
	    const eastCollapsed = east && east.props.collapsed || false;
	    const onNorthToggle = north && north.props.onToggle || null;
	    const onSouthToggle = south && south.props.onToggle || null;
	    const onWestToggle = west && west.props.onToggle || null;
	    const onEastToggle = east && east.props.onToggle || null;
	    this.northRef = React.createRef();
	    this.southRef = React.createRef();
	    this.westRef = React.createRef();
	    this.eastRef = React.createRef();
	    this.state = {
	      northSplit,
	      southSplit,
	      westSplit,
	      eastSplit,
	      northCollapsed,
	      southCollapsed,
	      westCollapsed,
	      eastCollapsed
	    };
	    this.handleNorthClick = this.handleNorthClick.bind(this, onNorthToggle);
	    this.handleSouthClick = this.handleSouthClick.bind(this, onSouthToggle);
	    this.handleWestClick = this.handleWestClick.bind(this, onWestToggle);
	    this.handleEastClick = this.handleEastClick.bind(this, onEastToggle);
	    this.handleTransitionEnd = this.handleTransitionEnd.bind(this, onNorthToggle, onSouthToggle, onWestToggle, onEastToggle);
	  }

	  handleNorthClick() {
	    if (!this.state.northSplit) {
	      return;
	    }

	    this.setState((state, props) => {
	      const collapsed = !state.northCollapsed;
	      const dom = this.northRef.current;
	      const height = dom.clientHeight;

	      if (collapsed) {
	        dom.style.marginTop = `-${height - 8}px`;
	      } else {
	        dom.style.marginTop = null;
	      }

	      return {
	        northCollapsed: collapsed
	      };
	    });
	  }

	  handleSouthClick() {
	    if (!this.state.southSplit) {
	      return;
	    }

	    this.setState((state, props) => {
	      const collapsed = !state.southCollapsed;
	      const dom = this.southRef.current;
	      const height = dom.clientHeight;

	      if (collapsed) {
	        dom.style.marginBottom = `-${height - 8}px`;
	      } else {
	        dom.style.marginBottom = null;
	      }

	      return {
	        southCollapsed: collapsed
	      };
	    });
	  }

	  handleWestClick() {
	    if (!this.state.westSplit) {
	      return;
	    }

	    const dom = this.westRef.current;
	    this.setState((state, props) => {
	      const collapsed = !state.westCollapsed;
	      const width = dom.clientWidth;

	      if (collapsed) {
	        dom.style.marginLeft = `-${width - 8}px`;
	      } else {
	        dom.style.marginLeft = null;
	      }

	      return {
	        westCollapsed: collapsed
	      };
	    });
	  }

	  handleEastClick() {
	    if (!this.state.eastSplit) {
	      return;
	    }

	    this.setState((state, props) => {
	      const collapsed = !state.eastCollapsed;
	      const dom = this.eastRef.current;
	      const width = dom.clientWidth;

	      if (collapsed) {
	        dom.style.marginRight = `-${width - 8}px`;
	      } else {
	        dom.style.marginRight = null;
	      }

	      return {
	        eastCollapsed: collapsed
	      };
	    });
	  }

	  handleTransitionEnd(onNorthToggle, onSouthToggle, onWestToggle, onEastToggle, event) {
	    const region = event.target.getAttribute('region');

	    switch (region) {
	      case 'north':
	        onNorthToggle && onNorthToggle(!this.state.northCollapsed);
	        break;

	      case 'south':
	        onSouthToggle && onSouthToggle(!this.state.southCollapsed);
	        break;

	      case 'west':
	        onWestToggle && onWestToggle(!this.state.westCollapsed);
	        break;

	      case 'east':
	        onEastToggle && onEastToggle(!this.state.eastCollapsed);
	        break;
	    }
	  }

	  render() {
	    const {
	      className,
	      style,
	      children
	    } = this.props;
	    let north = [],
	        south = [],
	        west = [],
	        east = [],
	        center = [],
	        others = [];
	    children && children.forEach(n => {
	      switch (n.props.region) {
	        case 'north':
	          north.push(n);
	          break;

	        case 'south':
	          south.push(n);
	          break;

	        case 'west':
	          west.push(n);
	          break;

	        case 'east':
	          east.push(n);
	          break;

	        case 'center':
	          center.push(n);
	          break;

	        default:
	          others.push(n);
	          break;
	      }
	    });

	    if (center.length === 0) {
	      console.warn(`BorderLayout: center region is not defined.`);
	    } // north region


	    const northRegion = north.length > 0 && React.createElement("div", {
	      className: bind('north', this.state.northSplit && 'split', this.state.northCollapsed && 'collapsed'),
	      region: 'north',
	      onTransitionEnd: this.handleTransitionEnd,
	      ref: this.northRef
	    }, React.createElement("div", {
	      className: 'content'
	    }, north), this.state.northSplit && React.createElement("div", {
	      className: 'control'
	    }, React.createElement("div", {
	      className: 'button',
	      onClick: this.handleNorthClick
	    }))); // south region

	    const southRegion = south.length > 0 && React.createElement("div", {
	      className: bind('south', this.state.northSplit && 'split', this.state.southCollapsed && 'collapsed'),
	      region: 'south',
	      onTransitionEnd: this.handleTransitionEnd,
	      ref: this.southRef
	    }, this.state.southSplit && React.createElement("div", {
	      className: 'control'
	    }, React.createElement("div", {
	      className: 'button',
	      onClick: this.handleSouthClick
	    })), React.createElement("div", {
	      className: 'content'
	    }, south)); // west region

	    const westRegion = west.length > 0 && React.createElement("div", {
	      className: bind('west', this.state.westSplit && 'split', this.state.westCollapsed && 'collapsed'),
	      region: 'west',
	      onTransitionEnd: this.handleTransitionEnd,
	      ref: this.westRef
	    }, React.createElement("div", {
	      className: 'content'
	    }, west), this.state.westSplit && React.createElement("div", {
	      className: 'control'
	    }, React.createElement("div", {
	      className: 'button',
	      onClick: this.handleWestClick
	    }))); // east region

	    const eastRegion = east.length > 0 && React.createElement("div", {
	      className: bind('east', this.state.eastSplit && 'split', this.state.eastCollapsed && 'collapsed'),
	      region: 'east',
	      onTransitionEnd: this.handleTransitionEnd,
	      ref: this.eastRef
	    }, React.createElement("div", {
	      className: 'control'
	    }, React.createElement("div", {
	      className: 'button',
	      onClick: this.handleEastClick
	    })), React.createElement("div", {
	      className: 'content'
	    }, east)); // center region

	    const centerRegion = center.length > 0 && React.createElement("div", {
	      className: 'center'
	    }, center);
	    const otherRegion = others.length > 0 && others;
	    return React.createElement("div", {
	      className: bind('BorderLayout', className),
	      style: style
	    }, northRegion, React.createElement("div", {
	      className: 'middle'
	    }, westRegion, centerRegion, eastRegion), southRegion, otherRegion);
	  }

	}

	BorderLayout.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	BorderLayout.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 水平布局
	 * @author tengge / https://github.com/tengge1
	 */

	class HBoxLayout extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return React.createElement("div", _extends({
	      className: bind('HBoxLayout', className),
	      style: style
	    }, others), children);
	  }

	}

	HBoxLayout.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	HBoxLayout.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 选项卡布局
	 * @author tengge / https://github.com/tengge1
	 */

	class TabLayout extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onActiveTabChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children,
	      activeTabIndex
	    } = this.props;
	    return React.createElement("div", {
	      className: bind('TabLayout', className),
	      style: style
	    }, React.createElement("div", {
	      className: 'tabs'
	    }, React.Children.map(children, (n, i) => {
	      return React.createElement("div", {
	        className: bind('tab', i === activeTabIndex ? 'selected' : null),
	        key: i,
	        tbindex: i,
	        onClick: this.handleClick
	      }, n.props.title);
	    })), React.createElement("div", {
	      className: 'contents'
	    }, React.Children.map(children, (n, i) => {
	      return React.createElement("div", {
	        className: bind('content', i === activeTabIndex ? 'show' : null),
	        key: i
	      }, n);
	    })));
	  }

	  handleClick(onActiveTabChange, event) {
	    const index = event.target.getAttribute('tbindex');
	    onActiveTabChange && onActiveTabChange(parseInt(index), event.target, event);
	  }

	}

	TabLayout.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  activeTabIndex: propTypes.number,
	  onActiveTabChange: propTypes.func
	};
	TabLayout.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  activeTabIndex: 0,
	  onActiveTabChange: null
	};

	/**
	 * 竖直布局
	 * @author tengge / https://github.com/tengge1
	 */

	class VBoxLayout extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return React.createElement("div", _extends({
	      className: bind('VBoxLayout', className),
	      style: style
	    }, others), children);
	  }

	}

	VBoxLayout.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	VBoxLayout.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 菜单栏
	 * @author tengge / https://github.com/tengge1
	 */

	class MenuBar extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return React.createElement("ul", _extends({
	      className: bind('MenuBar', className),
	      style: style
	    }, others), children);
	  }

	}

	MenuBar.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	MenuBar.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 菜单栏填充
	 * @author tengge / https://github.com/tengge1
	 */

	class MenuBarFiller extends React.Component {
	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    return React.createElement("li", {
	      className: bind('MenuItem', 'MenuBarFiller', className),
	      style: style
	    });
	  }

	}

	MenuBarFiller.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object
	};
	MenuBarFiller.defaultProps = {
	  className: null,
	  style: null
	};

	/**
	 * 菜单项
	 * @author tengge / https://github.com/tengge1
	 */

	class MenuItem extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onClick);
	  }

	  render() {
	    const {
	      title,
	      className,
	      style,
	      children,
	      show,
	      disabled,
	      onClick
	    } = this.props;
	    const subMenu = React.Children.count(children) ? React.createElement(React.Fragment, null, React.createElement("div", {
	      className: 'suffix'
	    }, React.createElement("i", {
	      className: 'iconfont icon-right-triangle'
	    })), React.createElement("div", {
	      className: 'sub'
	    }, React.createElement("ul", {
	      className: 'wrap'
	    }, children))) : null;
	    return React.createElement("li", {
	      className: bind('MenuItem', disabled && 'disabled', !show && 'hidden', className),
	      style: style,
	      onClick: this.handleClick
	    }, React.createElement("span", null, title), subMenu);
	  }

	  handleClick(onClick, event) {
	    event.stopPropagation();

	    if (!event.target.classList.contains('disabled')) {
	      onClick && onClick(event);
	    }
	  }

	}

	MenuItem.propTypes = {
	  title: propTypes.string,
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  show: propTypes.bool,
	  disabled: propTypes.bool,
	  onClick: propTypes.func
	};
	MenuItem.defaultProps = {
	  title: null,
	  className: null,
	  style: null,
	  children: null,
	  show: true,
	  disabled: false,
	  onClick: null
	};

	/**
	 * 菜单项分隔符
	 * @author tengge / https://github.com/tengge1
	 */

	class MenuItemSeparator extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      direction,
	      show
	    } = this.props;
	    return React.createElement("li", {
	      className: bind('MenuItemSeparator', direction && direction, !show && 'hidden', className),
	      style: style
	    }, React.createElement("div", {
	      className: "separator"
	    }));
	  }

	}

	MenuItemSeparator.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  direction: propTypes.oneOf(['horizontal', 'vertical']),
	  show: propTypes.bool
	};
	MenuItemSeparator.defaultProps = {
	  className: null,
	  style: null,
	  direction: 'vertical',
	  show: true
	};

	/**
	 * 菜单选项卡
	 * @author tengge / https://github.com/tengge1
	 */

	class MenuTab extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onClick);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children,
	      selected,
	      show,
	      disabled,
	      onClick
	    } = this.props;
	    return React.createElement("li", {
	      className: bind('MenuTab', selected && 'selected', disabled && 'disabled', !show && 'hidden', className),
	      style: style,
	      onClick: this.handleClick
	    }, children);
	  }

	  handleClick(onClick, event) {
	    event.stopPropagation();

	    if (!event.target.classList.contains('disabled')) {
	      onClick && onClick(this.props.name, event);
	    }
	  }

	}

	MenuTab.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  name: propTypes.string,
	  selected: propTypes.bool,
	  show: propTypes.bool,
	  disabled: propTypes.bool,
	  onClick: propTypes.func
	};
	MenuTab.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  name: null,
	  selected: false,
	  show: true,
	  disabled: false,
	  onClick: null
	};

	/**
	 * 面板
	 * @author tengge / https://github.com/tengge1
	 */

	class Panel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      collapsed: props.collapsed,
	      maximized: props.maximized,
	      closed: props.closed
	    };
	    this.handleCollapse = this.handleCollapse.bind(this, props.onCollapse);
	    this.handleMaximize = this.handleMaximize.bind(this, props.onMaximize);
	    this.handleClose = this.handleClose.bind(this, props.onClose);
	  }

	  handleCollapse(onCollapse, event) {
	    this.setState(state => ({
	      collapsed: !state.collapsed
	    }));
	    onCollapse && onCollapse(event);
	  }

	  handleMaximize(onMaximize, event) {
	    this.setState(state => ({
	      maximized: !state.maximized
	    }));
	    onMaximize && onMaximize(event);
	  }

	  handleClose(onClose, event) {
	    this.setState(state => ({
	      closed: !state.closed
	    }));
	    onClose && onClose(event);
	  }

	  render() {
	    const {
	      title,
	      className,
	      style,
	      children,
	      show,
	      header,
	      collapsible,
	      collapsed,
	      onCollapse,
	      maximizable,
	      maximized,
	      onMaximize,
	      closable,
	      closed,
	      onClose
	    } = this.props;
	    const collapseControl = collapsible && React.createElement("div", {
	      className: 'control',
	      onClick: this.handleCollapse
	    }, this.state.collapsed ? React.createElement("i", {
	      className: 'iconfont icon-down-arrow'
	    }) : React.createElement("i", {
	      className: 'iconfont icon-up-arrow'
	    }));
	    const maximizeControl = maximizable && React.createElement("div", {
	      className: 'control',
	      onClick: this.handleMaximize
	    }, this.state.maximized ? React.createElement("i", {
	      className: 'iconfont icon-minimize'
	    }) : React.createElement("i", {
	      className: 'iconfont icon-maximize'
	    }));
	    const closeControl = closable && React.createElement("div", {
	      className: 'control',
	      onClick: this.handleClose
	    }, React.createElement("i", {
	      className: 'iconfont icon-close-thin'
	    }));
	    return React.createElement("div", {
	      className: bind('Panel', this.state.maximized && 'maximized', this.state.collapsed && 'collapsed', this.state.closed && 'hidden', !show && 'hidden', className),
	      style: style
	    }, React.createElement("div", {
	      className: bind('header', header ? null : 'hidden')
	    }, React.createElement("span", {
	      className: "title"
	    }, title), React.createElement("div", {
	      className: "controls"
	    }, collapseControl, maximizeControl, closeControl)), React.createElement("div", {
	      className: 'body'
	    }, children));
	  }

	}

	Panel.propTypes = {
	  title: propTypes.string,
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  show: propTypes.bool,
	  header: propTypes.bool,
	  collapsible: propTypes.bool,
	  collapsed: propTypes.bool,
	  onCollapse: propTypes.func,
	  maximizable: propTypes.bool,
	  maximized: propTypes.bool,
	  onMaximize: propTypes.bool,
	  closable: propTypes.bool,
	  closed: propTypes.bool,
	  onClose: propTypes.func
	};
	Panel.defaultProps = {
	  title: null,
	  className: null,
	  style: null,
	  children: null,
	  show: true,
	  header: true,
	  collapsible: false,
	  collapsed: false,
	  onCollapse: null,
	  maximizable: false,
	  maximized: false,
	  onMaximize: null,
	  closable: false,
	  closed: false,
	  onClose: null
	};

	/**
	 * 加载动画
	 * @author tengge / https://github.com/tengge1
	 */

	class LoadMask extends React.Component {
	  constructor(props) {
	    super(props);
	  }

	  render() {
	    const {
	      className,
	      style,
	      show,
	      text
	    } = this.props;
	    return React.createElement("div", {
	      className: bind('LoadMask', className, !show && 'hidden'),
	      style: style
	    }, React.createElement("div", {
	      className: 'box'
	    }, React.createElement("div", {
	      className: 'msg'
	    }, text)));
	  }

	}

	LoadMask.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool,
	  text: propTypes.string
	};
	LoadMask.defaultProps = {
	  className: null,
	  style: null,
	  show: true,
	  text: 'Waiting...'
	};

	/**
	 * 属性表
	 * @author tengge / https://github.com/tengge1
	 */

	class PropertyGrid extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children
	    } = this.props;
	    return React.createElement("div", {
	      className: bind('PropertyGrid', className),
	      style: style
	    }, children);
	  }

	}

	PropertyGrid.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	PropertyGrid.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 属性组
	 * @author tengge / https://github.com/tengge1
	 */

	class PropertyGroup extends React.Component {
	  constructor(props) {
	    super(props);
	    this.contentRef = React.createRef();
	    this.handleExpand = this.handleExpand.bind(this, props.onExpand);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children,
	      title,
	      show,
	      expanded
	    } = this.props;
	    return React.createElement("div", {
	      className: bind('PropertyGroup', !show && 'hidden'),
	      style: style
	    }, React.createElement("div", {
	      className: 'head',
	      expanded: expanded ? 'true' : 'false',
	      onClick: this.handleExpand
	    }, React.createElement("div", {
	      className: 'icon'
	    }, React.createElement("i", {
	      className: expanded ? 'icon-expand' : 'icon-collapse'
	    })), React.createElement("div", {
	      className: 'title'
	    }, title)), React.createElement("div", {
	      className: bind('content', !expanded && 'collapsed'),
	      ref: this.contentRef
	    }, React.Children.map(children, (n, i) => {
	      if (n.props.show === false) {
	        return null;
	      }

	      let typeName = n.type.name;

	      if (typeName.indexOf('$') > -1) {
	        typeName = typeName.split('$')[0];
	      }

	      return React.createElement("div", {
	        className: bind('property', typeName),
	        key: i
	      }, React.createElement("div", {
	        className: 'label'
	      }, n.props.label), React.createElement("div", {
	        className: 'field'
	      }, n));
	    })));
	  }

	  componentDidUpdate() {
	    let content = this.contentRef.current;
	    let height = 0;

	    for (let i = 0; i < content.children.length; i++) {
	      let child = content.children[i];
	      height += child.offsetHeight; // offsetHeight包含下边框
	    }

	    content.style.height = `${height}px`;
	  }

	  handleExpand(onExpand, event) {
	    const expanded = event.target.getAttribute('expanded') === 'true';
	    onExpand && onExpand(!expanded, event);
	  }

	}

	PropertyGroup.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node,
	  title: propTypes.string,
	  show: propTypes.bool,
	  expanded: propTypes.bool,
	  onExpand: propTypes.func
	};
	PropertyGroup.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  title: 'Group',
	  show: true,
	  expanded: true,
	  onExpand: null
	};

	/**
	 * 展示属性
	 * @author tengge / https://github.com/tengge1
	 */

	class DisplayProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onClick);
	  }

	  render() {
	    const {
	      className,
	      style,
	      name,
	      value,
	      btnShow,
	      btnText
	    } = this.props;
	    return React.createElement("div", {
	      className: bind('wrap', className),
	      style: style
	    }, React.createElement("div", {
	      className: 'label'
	    }, value), btnShow && React.createElement(Button, {
	      className: 'button',
	      onClick: this.handleClick
	    }, btnText));
	  }

	  handleClick(onClick, name, event) {
	    onClick && onClick(this.props.name, event);
	  }

	}

	DisplayProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.string,
	  btnShow: propTypes.bool,
	  btnText: propTypes.string,
	  onClick: propTypes.func
	};
	DisplayProperty.defaultProps = {
	  className: null,
	  style: null,
	  name: 'name',
	  value: '',
	  btnShow: false,
	  btnText: 'Button',
	  onClick: null
	};

	/**
	 * 文本属性
	 * @author tengge / https://github.com/tengge1
	 */

	class TextProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      name,
	      value
	    } = this.props;
	    return React.createElement(Input, {
	      className: bind('input', className),
	      style: style,
	      name: name,
	      value: value,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(onChange, value, name, event) {
	    onChange && onChange(value, name, event);
	  }

	}

	TextProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.string,
	  onChange: propTypes.func
	};
	TextProperty.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: '',
	  onChange: null
	};

	/**
	 * 复选框属性
	 * @author tengge / https://github.com/tengge1
	 */

	class CheckBoxProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      name,
	      value
	    } = this.props;
	    return React.createElement(CheckBox, {
	      className: bind('checkbox', className),
	      style: style,
	      name: name,
	      checked: value,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(onChange, value, name, event) {
	    onChange && onChange(value, name, event);
	  }

	}

	CheckBoxProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.bool,
	  onChange: propTypes.func
	};
	CheckBoxProperty.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: false,
	  onChange: null
	};

	/**
	 * 数字属性
	 * @author tengge / https://github.com/tengge1
	 */

	class NumberProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      name,
	      value,
	      min,
	      max,
	      step
	    } = this.props;
	    return React.createElement(Input, {
	      className: bind('input', className),
	      style: style,
	      name: name,
	      type: 'number',
	      value: value,
	      min: min,
	      max: max,
	      step: step,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(onChange, value, name, event) {
	    onChange && onChange(value, name, event);
	  }

	}

	NumberProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.number,
	  min: propTypes.number,
	  max: propTypes.number,
	  step: propTypes.number,
	  onChange: propTypes.func
	};
	NumberProperty.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: 0,
	  min: null,
	  max: null,
	  step: null,
	  onChange: null
	};

	/**
	 * 按钮属性
	 * @author tengge / https://github.com/tengge1
	 */

	class ButtonProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      text
	    } = this.props;
	    return React.createElement(Button, {
	      className: bind('button', className),
	      style: style,
	      onClick: this.handleChange
	    }, text);
	  }

	  handleChange(onChange, name, value, event) {
	    onChange && onChange(name, value, event);
	  }

	}

	ButtonProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  text: propTypes.string,
	  onChange: propTypes.func
	};
	ButtonProperty.defaultProps = {
	  className: null,
	  style: null,
	  text: 'Button',
	  onChange: null
	};

	/**
	 * 颜色属性
	 * @author tengge / https://github.com/tengge1
	 */

	class ColorProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      name,
	      value
	    } = this.props;
	    return React.createElement(Input, {
	      className: bind('input', className),
	      style: style,
	      name: name,
	      type: 'color',
	      value: value,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(onChange, value, name, event) {
	    onChange && onChange(value, name, event);
	  }

	}

	ColorProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.string,
	  onChange: propTypes.func
	};
	ColorProperty.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: '',
	  onChange: null
	};

	/**
	 * 文本属性
	 * @author tengge / https://github.com/tengge1
	 */

	class SelectProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      options,
	      name,
	      value,
	      disabled
	    } = this.props;
	    return React.createElement(Select, {
	      className: bind('select', className),
	      style: style,
	      options: options,
	      name: name,
	      value: value,
	      disabled: disabled,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(onChange, value, name, event) {
	    onChange && onChange(value, name, event);
	  }

	}

	SelectProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  options: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.oneOfType([propTypes.string, propTypes.number]),
	  disabled: propTypes.bool,
	  onChange: propTypes.func
	};
	SelectProperty.defaultProps = {
	  className: null,
	  style: null,
	  options: {},
	  name: null,
	  value: null,
	  disabled: false,
	  onChange: null
	};

	/**
	 * 整数属性
	 * @author tengge / https://github.com/tengge1
	 */

	class IntegerProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      name,
	      value,
	      min,
	      max
	    } = this.props;
	    return React.createElement(Input, {
	      className: bind('input', className),
	      style: style,
	      name: name,
	      type: 'number',
	      value: value,
	      min: min,
	      max: max,
	      step: 1,
	      precision: 0,
	      onChange: this.handleChange
	    });
	  }

	  handleChange(onChange, value, name, event) {
	    if (value === null) {
	      onChange && onChange(value, name, event);
	    } else {
	      onChange && onChange(parseInt(value), name, event);
	    }
	  }

	}

	IntegerProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: propTypes.number,
	  min: propTypes.number,
	  max: propTypes.number,
	  onChange: propTypes.func
	};
	IntegerProperty.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: 0,
	  min: null,
	  max: null,
	  onChange: null
	};

	/**
	 * 按钮组属性
	 * @author tengge / https://github.com/tengge1
	 */

	class ButtonsProperty extends React.Component {
	  constructor(props) {
	    super(props);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children
	    } = this.props;
	    return React.createElement("div", {
	      className: bind('buttons', className),
	      style: style
	    }, children);
	  }

	}

	ButtonsProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	ButtonsProperty.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 纹理属性
	 * @author tengge / https://github.com/tengge1
	 */

	class TextureProperty extends React.Component {
	  constructor(props) {
	    super(props);
	    this.canvasRef = React.createRef();
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleEnable = this.handleEnable.bind(this, props.onChange);
	    this.handleChange = this.handleChange.bind(this, props.onChange);
	  }

	  render() {
	    const {
	      className,
	      style,
	      value,
	      showScale,
	      scale
	    } = this.props;
	    return React.createElement("div", {
	      className: bind('texture', className),
	      style: style
	    }, React.createElement(CheckBox, {
	      checked: value !== null,
	      onChange: this.handleEnable
	    }), React.createElement("canvas", {
	      title: value ? value.sourceFile : '',
	      ref: this.canvasRef,
	      onClick: this.handleSelect
	    }), React.createElement(Input, {
	      type: 'number',
	      value: scale,
	      show: showScale
	    }));
	  }

	  componentDidMount() {
	    this.componentDidUpdate();
	  }

	  componentDidUpdate() {
	    let texture = this.props.value;
	    const canvas = this.canvasRef.current;
	    const context = canvas.getContext('2d');

	    if (texture !== null) {
	      let image = texture.image;

	      if (image !== undefined && image.width > 0) {
	        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
	      } else {
	        context.clearRect(0, 0, canvas.width, canvas.height);
	      }
	    } else if (context !== null) {
	      context.clearRect(0, 0, canvas.width, canvas.height);
	    }
	  }

	  handleSelect() {
	    app.toast(_t('Please click the image in the MapPanel.'));
	    app.on(`selectMap.TextureProperty`, this.handleChange);
	  }

	  handleEnable(onChange, enabled, name, event) {
	    const value = this.props.value;

	    if (enabled && value === null) {
	      this.input.value = null;
	      this.input.click();
	      return;
	    }

	    if (enabled) {
	      onChange && onChange(value, this.props.name, event);
	    } else {
	      onChange && onChange(null, this.props.name, event);
	    }
	  }

	  handleChange(onChange, data) {
	    app.on(`selectMap.TextureProperty`, null);
	    const name = data.Name;
	    const type = data.Type;
	    const url = data.Url;

	    if (type === 'targa') {
	      const loader = new THREE.TGALoader();
	      loader.load(url, obj => {
	        let texture = new THREE.CanvasTexture(obj, THREE.UVMapping);
	        texture.sourceFile = name;
	        onChange && onChange(texture, this.props.name, data);
	      });
	    } else if (type === 'video') {
	      let video = document.createElement('video');
	      video.setAttribute('src', data.Url);
	      video.setAttribute('autoplay', 'autoplay');
	      video.setAttribute('loop', 'loop');
	      video.setAttribute('crossorigin', 'anonymous');
	      let texture = new THREE.VideoTexture(video);
	      texture.minFilter = THREE.LinearFilter;
	      texture.magFilter = THREE.LinearFilter;
	      texture.format = THREE.RGBFormat;
	      onChange && onChange(texture, this.props.name, data);
	    } else {
	      const loader = new THREE.TextureLoader();
	      loader.load(url, obj => {
	        obj.sourceFile = name;
	        obj.format = url.endsWith('jpg') || url.endsWith('jpeg') ? THREE.RGBFormat : THREE.RGBAFormat;
	        obj.needsUpdate = true;
	        onChange && onChange(obj, this.props.name, data);
	      });
	    }
	  }

	}

	TextureProperty.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  name: propTypes.string,
	  value: (props, propName, componentName) => {
	    const value = props.value;

	    if (value === null) {
	      return;
	    }

	    if (!(value instanceof THREE.Texture)) {
	      return new TypeError(`Invalid prop \`${propName}\` of type \`${typeof value}\` supplied to \`${componentName}\`, expected \`THREE.Texture\`.`);
	    }
	  },
	  showScale: propTypes.bool,
	  scale: propTypes.number,
	  onChange: propTypes.func
	};
	TextureProperty.defaultProps = {
	  className: null,
	  style: null,
	  name: null,
	  value: null,
	  showScale: false,
	  scale: 1.0,
	  onChange: null
	};

	/**
	 * SVG
	 * @author tengge / https://github.com/tengge1
	 */

	class SVG extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      ...others
	    } = this.props;
	    return React.createElement("svg", _extends({
	      className: bind('SVG', className),
	      style: style
	    }, others));
	  }

	}

	SVG.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object
	};
	SVG.defaultProps = {
	  className: null,
	  style: null
	};

	/**
	 * 数据表格
	 * @author tengge / https://github.com/tengge1
	 */

	class DataGrid extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onSelect);
	  }

	  handleClick(onSelect, event) {
	    const id = event.currentTarget.getAttribute('data-id');
	    const record = this.props.data.filter(n => n.id === id)[0];
	    onSelect && onSelect(record);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children,
	      data,
	      selected
	    } = this.props;
	    const columns = children.props.children.map(n => {
	      return {
	        type: n.props.type,
	        field: n.props.field,
	        title: n.props.title
	      };
	    });
	    const header = React.createElement("thead", null, React.createElement("tr", null, columns.map(n => {
	      let field = n.type === 'number' ? 'number' : n.field;
	      return React.createElement("td", {
	        name: n.field,
	        key: field
	      }, n.title);
	    })));
	    const body = React.createElement("tbody", null, data.map((n, i) => {
	      return React.createElement("tr", {
	        className: selected === n.id ? 'selected' : null,
	        "data-id": n.id,
	        key: n.id,
	        onClick: this.handleClick
	      }, columns.map((m, j) => {
	        if (m.type === 'number') {
	          return React.createElement("td", {
	            key: 'number'
	          }, i + 1);
	        } else {
	          return React.createElement("td", {
	            key: m.field
	          }, n[m.field]);
	        }
	      }));
	    }));
	    return React.createElement("table", {
	      className: bind('DataGrid', className),
	      style: style
	    }, header, body);
	  }

	}

	DataGrid.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: (props, propName, componentName) => {
	    const children = props[propName];

	    if (children.type !== Columns) {
	      return new TypeError(`Invalid prop \`${propName}\` of type \`${children.type.name}\` supplied to \`${componentName}\`, expected \`Columns\`.`);
	    }
	  },
	  data: propTypes.array,
	  selected: propTypes.string,
	  onSelect: propTypes.func
	};
	DataGrid.defaultProps = {
	  className: null,
	  style: null,
	  children: null,
	  data: [],
	  selected: null,
	  onSelect: null
	};

	/**
	 * 表格
	 * @author tengge / https://github.com/tengge1
	 */

	class Table extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return React.createElement("table", _extends({
	      className: bind('Table', className),
	      style: style
	    }, others), children);
	  }

	}

	Table.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	Table.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 表格内容
	 * @author tengge / https://github.com/tengge1
	 */

	class TableBody extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return React.createElement("tbody", _extends({
	      className: bind('TableBody', className),
	      style: style
	    }, others), children);
	  }

	}

	TableBody.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	TableBody.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 表格单元格
	 * @author tengge / https://github.com/tengge1
	 */

	class TableCell extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return React.createElement("td", _extends({
	      className: bind('TableCell', className),
	      style: style
	    }, others), children);
	  }

	}

	TableCell.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	TableCell.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 表格头部
	 * @author tengge / https://github.com/tengge1
	 */

	class TableHead extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return React.createElement("thead", _extends({
	      className: bind('TableHead', className),
	      style: style
	    }, others), children);
	  }

	}

	TableHead.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	TableHead.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 表格行
	 * @author tengge / https://github.com/tengge1
	 */

	class TableRow extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      ...others
	    } = this.props;
	    return React.createElement("tr", _extends({
	      className: bind('TableRow', className),
	      style: style
	    }, others), children);
	  }

	}

	TableRow.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	TableRow.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 工具栏
	 * @author tengge / https://github.com/tengge1
	 */

	class Toolbar extends React.Component {
	  render() {
	    const {
	      className,
	      style,
	      children,
	      direction
	    } = this.props;
	    return React.createElement("div", {
	      className: bind('Toolbar', direction, className),
	      style: style
	    }, children);
	  }

	}

	Toolbar.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  direction: propTypes.oneOf(['horizontal', 'vertical']),
	  children: propTypes.node
	};
	Toolbar.defaultProps = {
	  className: null,
	  style: null,
	  direction: 'horizontal',
	  children: null
	};

	/**
	 * 工具栏分割线
	 * @author tengge / https://github.com/tengge1
	 */

	class ToolbarSeparator extends React.Component {
	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    return React.createElement("div", {
	      className: bind('ToolbarSeparator', className),
	      style: style
	    }, React.createElement("div", {
	      className: "separator"
	    }));
	  }

	}

	ToolbarSeparator.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object
	};
	ToolbarSeparator.defaultProps = {
	  className: null,
	  style: null
	};

	/**
	 * 工具栏填充
	 * @author tengge / https://github.com/tengge1
	 */

	class ToolbarFiller extends React.Component {
	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    return React.createElement("div", {
	      className: bind('ToolbarFiller', className),
	      style: style
	    });
	  }

	}

	ToolbarFiller.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object
	};
	ToolbarFiller.defaultProps = {
	  className: null,
	  style: null
	};

	/**
	 * 时间轴
	 * @author tengge / https://github.com/tengge1
	 */

	class Timeline extends React.Component {
	  constructor(props) {
	    super(props);
	    this.duration = 120; // 持续时长(秒)

	    this.scale = 30; // 尺寸，1秒=30像素

	    this.time = 0; // 当前时间

	    this.speed = 16; // 当前速度

	    this.canvasRef = React.createRef();
	    this.layersRef = React.createRef();
	    this.leftRef = React.createRef();
	    this.rightRef = React.createRef();
	    this.sliderRef = React.createRef();
	    this.handleAddLayer = this.handleAddLayer.bind(this, props.onAddLayer);
	    this.handleEditLayer = this.handleEditLayer.bind(this, props.onEditLayer);
	    this.handleDeleteLayer = this.handleDeleteLayer.bind(this, props.onDeleteLayer);
	    this.commitDeleteLayer = this.commitDeleteLayer.bind(this);
	    this.handleSelectedLayerChange = this.handleSelectedLayerChange.bind(this, props.onSelectedLayerChange);
	    this.handleBackward = this.handleBackward.bind(this);
	    this.handlePlay = this.handlePlay.bind(this);
	    this.handlePause = this.handlePause.bind(this);
	    this.handleForward = this.handleForward.bind(this);
	    this.handleStop = this.handleStop.bind(this);
	    this.handleClick = this.handleClick.bind(this, props.onClickAnimation);
	    this.handleDoubleClick = this.handleDoubleClick.bind(this, props.onAddAnimation);
	    this.handleRightScroll = this.handleRightScroll.bind(this);
	    this.handleDragStart = this.handleDragStart.bind(this);
	    this.handleDragEnd = this.handleDragEnd.bind(this);
	    this.handleDragEnter = this.handleDragEnter.bind(this);
	    this.handleDragOver = this.handleDragOver.bind(this);
	    this.handleDragLeave = this.handleDragLeave.bind(this);
	    this.handleDrop = this.handleDrop.bind(this, props.onDropAnimation);
	  }

	  render() {
	    const {
	      className,
	      style,
	      animations,
	      selectedLayer,
	      selected
	    } = this.props;
	    return React.createElement("div", {
	      className: bind('Timeline', className),
	      style: style
	    }, React.createElement(Toolbar, {
	      className: bind('controls', className),
	      style: style
	    }, React.createElement(IconButton, {
	      icon: 'add',
	      title: _t('Add Layer'),
	      onClick: this.handleAddLayer
	    }), React.createElement(IconButton, {
	      icon: 'edit',
	      title: _t('Edit Layer'),
	      onClick: this.handleEditLayer
	    }), React.createElement(IconButton, {
	      icon: 'delete',
	      title: _t('Delete Layer'),
	      onClick: this.handleDeleteLayer
	    }), React.createElement(ToolbarSeparator, null), React.createElement(IconButton, {
	      icon: 'backward',
	      title: _t('Slower'),
	      onClick: this.handleBackward
	    }), React.createElement(IconButton, {
	      icon: 'play',
	      title: _t('Play'),
	      onClick: this.handlePlay
	    }), React.createElement(IconButton, {
	      icon: 'pause',
	      title: _t('Pause'),
	      onClick: this.handlePause
	    }), React.createElement(IconButton, {
	      icon: 'forward',
	      title: _t('Faster'),
	      onClick: this.handleForward
	    }), React.createElement(IconButton, {
	      icon: 'stop',
	      title: _t('Stop'),
	      onClick: this.handleStop
	    }), React.createElement(ToolbarSeparator, null), React.createElement(Label, {
	      className: 'time'
	    }, this.parseTime(this.time)), React.createElement(Label, {
	      className: 'speed'
	    }, this.parseSpeed(this.speed)), React.createElement(ToolbarFiller, null), React.createElement(Label, null, _t('Illustrate: Double-click the area below the timeline to add an animation.'))), React.createElement("div", {
	      className: "box"
	    }, React.createElement("div", {
	      className: 'timeline'
	    }, React.createElement("div", {
	      className: "mask"
	    }), React.createElement("canvas", {
	      ref: this.canvasRef
	    })), React.createElement("div", {
	      className: 'layers'
	    }, React.createElement("div", {
	      className: 'left',
	      ref: this.leftRef
	    }, animations.map(layer => {
	      return React.createElement("div", {
	        className: 'info',
	        key: layer.uuid
	      }, React.createElement(CheckBox, {
	        name: layer.uuid,
	        checked: selectedLayer === layer.uuid,
	        onChange: this.handleSelectedLayerChange
	      }), React.createElement(Label, null, layer.layerName));
	    })), React.createElement("div", {
	      className: 'right',
	      ref: this.rightRef,
	      onScroll: this.handleRightScroll
	    }, animations.map(layer => {
	      return React.createElement("div", {
	        className: 'layer',
	        droppable: 'true',
	        "data-type": 'layer',
	        "data-id": layer.uuid,
	        onDoubleClick: this.handleDoubleClick,
	        onDragEnter: this.handleDragEnter,
	        onDragOver: this.handleDragOver,
	        onDragLeave: this.handleDragLeave,
	        onDrop: this.handleDrop,
	        key: layer.uuid
	      }, layer.animations.map(animation => {
	        return React.createElement("div", {
	          className: bind('animation', selected === animation.uuid && 'selected'),
	          title: animation.name,
	          draggable: 'true',
	          droppable: 'false',
	          "data-type": 'animation',
	          "data-id": animation.uuid,
	          "data-pid": layer.uuid,
	          style: {
	            left: animation.beginTime * this.scale + 'px',
	            width: (animation.endTime - animation.beginTime) * this.scale + 'px'
	          },
	          onClick: this.handleClick,
	          onDragStart: this.handleDragStart,
	          onDragEnd: this.handleDragEnd,
	          key: animation.uuid
	        }, animation.name);
	      }));
	    })), React.createElement("div", {
	      className: "slider",
	      ref: this.sliderRef
	    }))));
	  }

	  componentDidMount() {
	    this.renderTimeline();
	  }

	  renderTimeline() {
	    const {
	      duration,
	      scale
	    } = this;
	    const width = duration * scale; // 画布宽度

	    const scale5 = scale / 5; // 0.2秒像素数

	    const margin = 0; // 时间轴前后间距

	    const canvas = this.canvasRef.current;
	    canvas.style.width = width + margin * 2 + 'px';
	    canvas.width = canvas.clientWidth;
	    canvas.height = 32;
	    const context = canvas.getContext('2d'); // 时间轴背景

	    context.fillStyle = '#fafafa';
	    context.fillRect(0, 0, canvas.width, canvas.height); // 时间轴刻度

	    context.strokeStyle = '#555';
	    context.beginPath();

	    for (let i = margin; i <= width + margin; i += scale) {
	      // 绘制每一秒
	      for (let j = 0; j < 5; j++) {
	        // 绘制每个小格
	        if (j === 0) {
	          // 长刻度
	          context.moveTo(i + scale5 * j, 22);
	          context.lineTo(i + scale5 * j, 30);
	        } else {
	          // 短刻度
	          context.moveTo(i + scale5 * j, 26);
	          context.lineTo(i + scale5 * j, 30);
	        }
	      }
	    }

	    context.stroke(); // 时间轴文字

	    context.font = '12px Arial';
	    context.fillStyle = '#888';

	    for (let i = 0; i <= duration; i += 2) {
	      // 对于每两秒
	      let minute = Math.floor(i / 60);
	      let second = Math.floor(i % 60);
	      let text = (minute > 0 ? minute + ':' : '') + ('0' + second).slice(-2);

	      if (i === 0) {
	        context.textAlign = 'left';
	      } else if (i === duration) {
	        context.textAlign = 'right';
	      } else {
	        context.textAlign = 'center';
	      }

	      context.fillText(text, margin + i * scale, 16);
	    }
	  }

	  handleAddLayer(onAddLayer, event) {
	    onAddLayer && onAddLayer(event);
	  }

	  handleEditLayer(onEditLayer, event) {
	    const {
	      selectedLayer
	    } = this.props;
	    onEditLayer && onEditLayer(selectedLayer, event);
	  }

	  handleDeleteLayer(onDeleteLayer, event) {
	    const {
	      selectedLayer
	    } = this.props;
	    onDeleteLayer && onDeleteLayer(selectedLayer, event);
	  }

	  commitDeleteLayer() {}

	  handleSelectedLayerChange(onSelectedLayerChange, value, name, event) {
	    onSelectedLayerChange && onSelectedLayerChange(value ? name : null, event);
	  }

	  handleBackward(event) {}

	  handlePlay(event) {}

	  handlePause(event) {}

	  handleForward(event) {}

	  handleStop(event) {}

	  handleClick(onClickAnimation, event) {
	    const type = event.target.getAttribute('data-type');

	    if (type !== 'animation') {
	      return;
	    }

	    const pid = event.target.getAttribute('data-pid');
	    const id = event.target.getAttribute('data-id');
	    onClickAnimation && onClickAnimation(id, pid, event);
	  }

	  handleDoubleClick(onAddAnimation, event) {
	    const type = event.target.getAttribute('data-type');

	    if (type !== 'layer') {
	      return;
	    }

	    const layerID = event.target.getAttribute('data-id');
	    const beginTime = event.nativeEvent.offsetX / this.scale;
	    const endTime = beginTime + 2;
	    onAddAnimation && onAddAnimation(layerID, beginTime, endTime, event);
	  }

	  handleRightScroll(scroll) {
	    let left = this.leftRef.current;
	    let canvas = this.canvasRef.current;
	    left.scrollTop = event.target.scrollTop;
	    canvas.style.left = `${100 - event.target.scrollLeft}px`;
	  }

	  handleDragStart(event) {
	    const type = event.target.getAttribute('data-type');

	    if (type !== 'animation') {
	      return;
	    }

	    const id = event.target.getAttribute('data-id');
	    const pid = event.target.getAttribute('data-pid');
	    event.nativeEvent.dataTransfer.setData('id', id);
	    event.nativeEvent.dataTransfer.setData('pid', pid);
	    event.nativeEvent.dataTransfer.setData('offsetX', event.nativeEvent.offsetX);
	  }

	  handleDragEnd(event) {
	    event.nativeEvent.dataTransfer.clearData();
	  }

	  handleDragEnter(event) {
	    event.preventDefault();
	  }

	  handleDragOver(event) {
	    event.preventDefault();
	  }

	  handleDragLeave(event) {
	    event.preventDefault();
	  }

	  handleDrop(onDropAnimation, event) {
	    const type = event.target.getAttribute('data-type');

	    if (type !== 'layer') {
	      return;
	    }

	    const id = event.nativeEvent.dataTransfer.getData('id');
	    const oldLayerID = event.nativeEvent.dataTransfer.getData('pid');
	    const offsetX = event.nativeEvent.dataTransfer.getData('offsetX');
	    const newLayerID = event.target.getAttribute('data-id');
	    const beginTime = (event.nativeEvent.offsetX - offsetX) / this.scale;
	    onDropAnimation && onDropAnimation(id, oldLayerID, newLayerID, beginTime, event);
	  }

	  parseTime(time) {
	    let minute = `0${parseInt(time / 60)}`;
	    let second = `0${parseInt(time % 60)}`;
	    return `${minute.substr(minute.length - 2, 2)}:${second.substr(second.length - 2, 2)}`;
	  }

	  parseSpeed(speed) {
	    return speed;
	  }

	}

	Timeline.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  animations: propTypes.array,
	  selectedLayer: propTypes.string,
	  selected: propTypes.string,
	  onAddLayer: propTypes.func,
	  onEditLayer: propTypes.func,
	  onDeleteLayer: propTypes.func,
	  onSelectedLayerChange: propTypes.func,
	  onAddAnimation: propTypes.func,
	  onDropAnimation: propTypes.func,
	  onClickAnimation: propTypes.func
	};
	Timeline.defaultProps = {
	  className: null,
	  style: null,
	  animations: [],
	  selectedLayer: null,
	  selected: null,
	  onAddLayer: null,
	  onEditLayer: null,
	  onDeleteLayer: null,
	  onSelectedLayerChange: null,
	  onAddAnimation: null,
	  onDropAnimation: null,
	  onClickAnimation: null
	};

	/**
	 * 树
	 * @author tengge / https://github.com/tengge1
	 */

	class Tree extends React.Component {
	  constructor(props) {
	    super(props);
	    this.treeRef = React.createRef();
	    const {
	      onExpand,
	      onSelect,
	      onCheck,
	      onDoubleClick,
	      onDrop
	    } = this.props;
	    this.handleExpandNode = this.handleExpandNode.bind(this, onExpand);
	    this.handleClick = this.handleClick.bind(this, onSelect);
	    this.handleCheck = this.handleCheck.bind(this, onCheck);
	    this.handleDoubleClick = this.handleDoubleClick.bind(this, onDoubleClick);
	    this.handleClickIcon = this.handleClickIcon.bind(this, props.onClickIcon);
	    this.handleDrag = this.handleDrag.bind(this);
	    this.handleDragStart = this.handleDragStart.bind(this);
	    this.handleDragOver = this.handleDragOver.bind(this);
	    this.handleDragLeave = this.handleDragLeave.bind(this);
	    this.handleDrop = this.handleDrop.bind(this, onDrop);
	  }

	  render() {
	    const {
	      className,
	      style,
	      data
	    } = this.props; // 创建节点

	    var list = [];
	    Array.isArray(data) && data.forEach(n => {
	      list.push(this.createNode(n));
	    });
	    return React.createElement("ul", {
	      className: bind('Tree', className),
	      style: style,
	      ref: this.treeRef
	    }, list);
	  }

	  createNode(data) {
	    const leaf = !data.children || data.children.length === 0;
	    const children = leaf ? null : React.createElement("ul", {
	      className: bind('sub', data.expanded ? null : 'collpase')
	    }, data.children.map(n => {
	      return this.createNode(n);
	    }));
	    let checkbox = null;

	    if (data.checked === true || data.checked === false) {
	      checkbox = React.createElement(CheckBox, {
	        name: data.value,
	        checked: data.checked,
	        onChange: this.handleCheck
	      });
	    }

	    return React.createElement("li", {
	      className: bind('node', this.props.selected === data.value && 'selected'),
	      value: data.value,
	      key: data.value,
	      onClick: this.handleClick,
	      onDoubleClick: this.handleDoubleClick,
	      draggable: 'true',
	      droppable: 'true',
	      onDrag: this.handleDrag,
	      onDragStart: this.handleDragStart,
	      onDragOver: this.handleDragOver,
	      onDragLeave: this.handleDragLeave,
	      onDrop: this.handleDrop
	    }, React.createElement("i", {
	      className: bind('expand', leaf ? null : data.expanded ? 'minus' : 'plus'),
	      value: data.value,
	      onClick: this.handleExpandNode
	    }), checkbox, React.createElement("i", {
	      className: bind('type', leaf ? 'node' : data.expanded ? 'open' : 'close')
	    }), React.createElement("a", {
	      href: 'javascript:;'
	    }, data.text), data.icons && data.icons.map(n => {
	      return React.createElement(Icon, {
	        className: 'control',
	        name: n.name,
	        value: data.value,
	        icon: n.icon,
	        key: n.name,
	        onClick: this.handleClickIcon
	      });
	    }), leaf ? null : children);
	  } // 暂时屏蔽树节点动画，有bug。
	  // componentDidUpdate() {
	  //     let tree = this.treeRef.current;
	  //     // 将每棵子树设置高度，以便显示动画
	  //     this.handleSetTreeHeight(tree);
	  // }


	  handleSetTreeHeight(node) {
	    if (node.children.length === 0) {
	      return;
	    }

	    let height = 0;

	    for (let i = 0; i < node.children.length; i++) {
	      let child = node.children[i];
	      height += child.offsetHeight;
	      this.handleSetTreeHeight(child);
	    }

	    if (node.classList.contains('sub')) {
	      // 子树
	      node.style.height = `${height}px`;
	    }
	  }

	  handleExpandNode(onExpand, event) {
	    event.stopPropagation();
	    const value = event.target.getAttribute('value');
	    onExpand && onExpand(value, event);
	  }

	  handleClick(onSelect, event) {
	    event.stopPropagation();
	    var value = event.target.getAttribute('value');

	    if (value) {
	      onSelect && onSelect(value, event);
	    }
	  }

	  handleCheck(onCheck, value, name, event) {
	    event.stopPropagation();
	    onCheck && onCheck(value, name, event);
	  }

	  handleDoubleClick(onDoubleClick, event) {
	    const value = event.target.getAttribute('value');

	    if (value) {
	      onDoubleClick && onDoubleClick(value, event);
	    }
	  }

	  handleClickIcon(onClickIcon, name, event) {
	    const value = event.target.getAttribute('value');
	    event.stopPropagation();
	    onClickIcon && onClickIcon(value, name, event);
	  } // --------------------- 拖拽事件 ---------------------------


	  handleDrag(event) {
	    event.stopPropagation();
	    this.currentDrag = event.currentTarget;
	  }

	  handleDragStart(event) {
	    event.stopPropagation();
	    event.dataTransfer.setData('text', 'foo');
	  }

	  handleDragOver(event) {
	    event.preventDefault();
	    event.stopPropagation();
	    var target = event.currentTarget;

	    if (target === this.currentDrag) {
	      return;
	    }

	    var area = event.nativeEvent.offsetY / target.clientHeight;

	    if (area < 0.25) {
	      target.classList.add('dragTop');
	    } else if (area > 0.75) {
	      target.classList.add('dragBottom');
	    } else {
	      target.classList.add('drag');
	    }
	  }

	  handleDragLeave(event) {
	    event.preventDefault();
	    event.stopPropagation();
	    var target = event.currentTarget;

	    if (target === this.currentDrag) {
	      return;
	    }

	    target.classList.remove('dragTop');
	    target.classList.remove('dragBottom');
	    target.classList.remove('drag');
	  }

	  handleDrop(onDrop, event) {
	    event.preventDefault();
	    event.stopPropagation();
	    var target = event.currentTarget;

	    if (target === this.currentDrag) {
	      return;
	    }

	    target.classList.remove('dragTop');
	    target.classList.remove('dragBottom');
	    target.classList.remove('drag');

	    if (typeof onDrop === 'function') {
	      const area = event.nativeEvent.offsetY / target.clientHeight;
	      const currentValue = this.currentDrag.getAttribute('value');

	      if (area < 0.25) {
	        // 放在当前元素前面
	        onDrop(currentValue, // 拖动要素
	        target.parentNode.parentNode.getAttribute('value'), // 新位置父级
	        target.getAttribute('value') // 新位置索引
	        ); // 拖动, 父级, 索引
	      } else if (area > 0.75) {
	        // 放在当前元素后面
	        onDrop(currentValue, target.parentNode.parentNode.getAttribute('value'), target.nextSibling == null ? null : target.nextSibling.getAttribute('value') // target.nextSibling为null，说明是最后一个位置
	        );
	      } else {
	        // 成为该元素子级
	        onDrop(currentValue, target.getAttribute('value'), null);
	      }
	    }
	  }

	}

	Tree.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  data: propTypes.array,
	  selected: propTypes.string,
	  onExpand: propTypes.func,
	  onSelect: propTypes.func,
	  onCheck: propTypes.func,
	  onDoubleClick: propTypes.func,
	  onClickIcon: propTypes.func,
	  onDrop: propTypes.func
	};
	Tree.defaultProps = {
	  className: null,
	  style: null,
	  data: [],
	  selected: null,
	  onExpand: null,
	  onSelect: null,
	  onCheck: null,
	  onDoubleClick: null,
	  onClickIcon: null,
	  onDrop: null
	};

	/**
	 * 窗口
	 */

	class Window extends React.Component {
	  constructor(props) {
	    super(props);
	    this.dom = React.createRef();
	    this.isDown = false;
	    this.offsetX = 0;
	    this.offsetY = 0;
	    this.handleMouseDown = this.handleMouseDown.bind(this);
	    this.handleMouseMove = this.handleMouseMove.bind(this);
	    this.handleMouseUp = this.handleMouseUp.bind(this);
	    this.handleClose = this.handleClose.bind(this, props.onClose);
	  }

	  render() {
	    const {
	      className,
	      style,
	      title,
	      children,
	      hidden,
	      mask
	    } = this.props;
	    let _children = null;

	    if (children && Array.isArray(children)) {
	      _children = children;
	    } else if (children) {
	      _children = [children];
	    }

	    const content = _children.filter(n => {
	      return n.type === Content;
	    })[0];

	    const buttons = _children.filter(n => {
	      return n.type === Buttons;
	    })[0];

	    return React.createElement("div", {
	      className: bind('WindowMask', mask && 'mask', hidden && 'hidden')
	    }, React.createElement("div", {
	      className: bind('Window', className),
	      style: style,
	      ref: this.dom
	    }, React.createElement("div", {
	      className: 'wrap'
	    }, React.createElement("div", {
	      className: 'title',
	      onMouseDown: this.handleMouseDown
	    }, React.createElement("span", null, title), React.createElement("div", {
	      className: 'controls'
	    }, React.createElement("i", {
	      className: 'iconfont icon-close icon',
	      onClick: this.handleClose
	    }))), React.createElement("div", {
	      className: 'content'
	    }, content && content.props.children), React.createElement("div", {
	      className: 'buttons'
	    }, React.createElement("div", {
	      className: 'button-wrap'
	    }, buttons && buttons.props.children)))));
	  }

	  handleMouseDown(event) {
	    this.isDown = true;
	    var dom = this.dom.current;
	    var left = dom.style.left === '' ? 0 : parseInt(dom.style.left.replace('px', ''));
	    var top = dom.style.top === '' ? 0 : parseInt(dom.style.top.replace('px', ''));
	    this.offsetX = event.clientX - left;
	    this.offsetY = event.clientY - top;
	  }

	  handleMouseMove(event) {
	    if (!this.isDown) {
	      return;
	    }

	    var dx = event.clientX - this.offsetX;
	    var dy = event.clientY - this.offsetY;
	    var dom = this.dom.current;
	    dom.style.left = `${dx}px`;
	    dom.style.top = `${dy}px`;
	  }

	  handleMouseUp(event) {
	    this.isDown = false;
	    this.offsetX = 0;
	    this.offsetY = 0;
	  }

	  handleClose(onClose, event) {
	    onClose && onClose(event);
	  }

	  componentDidMount() {
	    document.body.addEventListener('mousemove', this.handleMouseMove);
	    document.body.addEventListener('mouseup', this.handleMouseUp);
	  }

	  componentWillUnmount() {
	    document.body.removeEventListener('mousemove', this.handleMouseMove);
	    document.body.removeEventListener('mouseup', this.handleMouseUp);
	  }

	}

	Window.show = function () {};

	Window.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  title: propTypes.string,
	  children: propTypes.node,
	  hidden: propTypes.bool,
	  mask: propTypes.bool,
	  onClose: propTypes.func
	};
	Window.defaultProps = {
	  className: null,
	  style: null,
	  title: 'Window',
	  children: null,
	  hidden: false,
	  mask: true,
	  onClose: null
	};

	/**
	 * 提示框
	 */

	class Alert extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleOK = this.handleOK.bind(this, props.onOK);
	    this.handleClose = this.handleClose.bind(this, props.onClose);
	  }

	  render() {
	    const {
	      className,
	      style,
	      title,
	      children,
	      hidden,
	      mask,
	      okText
	    } = this.props;
	    return React.createElement(Window, {
	      className: bind('Alert', className),
	      style: style,
	      title: title,
	      hidden: hidden,
	      mask: mask,
	      onClose: this.handleClose
	    }, React.createElement(Content, null, children), React.createElement(Buttons, null, React.createElement(Button, {
	      onClick: this.handleOK
	    }, okText)));
	  }

	  handleOK(onOK, event) {
	    onOK && onOK(event);
	  }

	  handleClose(onClose, event) {
	    onClose && onClose(event);
	  }

	}

	Alert.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  title: propTypes.string,
	  children: propTypes.node,
	  hidden: propTypes.bool,
	  mask: propTypes.bool,
	  okText: propTypes.string,
	  onOK: propTypes.func,
	  onClose: propTypes.func
	};
	Alert.defaultProps = {
	  className: null,
	  style: null,
	  title: 'Message',
	  children: null,
	  hidden: false,
	  mask: false,
	  okText: 'OK',
	  onOK: null,
	  onClose: null
	};

	/**
	 * 询问框
	 */

	class Confirm extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleOK = this.handleOK.bind(this, props.onOK);
	    this.handleCancel = this.handleCancel.bind(this, props.onCancel);
	    this.handleClose = this.handleClose.bind(this, props.onClose);
	  }

	  render() {
	    const {
	      className,
	      style,
	      title,
	      children,
	      hidden,
	      mask,
	      okText,
	      cancelText
	    } = this.props;
	    return React.createElement(Window, {
	      className: bind('Confirm', className),
	      style: style,
	      title: title,
	      hidden: hidden,
	      mask: mask,
	      onClose: this.handleClose
	    }, React.createElement(Content, null, children), React.createElement(Buttons, null, React.createElement(Button, {
	      onClick: this.handleOK
	    }, okText), React.createElement(Button, {
	      onClick: this.handleCancel
	    }, cancelText)));
	  }

	  handleOK(onOK, event) {
	    onOK && onOK(event);
	  }

	  handleCancel(onCancel, event) {
	    onCancel && onCancel(event);
	  }

	  handleClose(onClose, event) {
	    onClose && onClose(event);
	  }

	}

	Confirm.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  title: propTypes.string,
	  children: propTypes.node,
	  hidden: propTypes.bool,
	  mask: propTypes.bool,
	  okText: propTypes.string,
	  cancelText: propTypes.string,
	  onOK: propTypes.func,
	  onCancel: propTypes.func,
	  onClose: propTypes.func
	};
	Confirm.defaultProps = {
	  className: null,
	  style: null,
	  title: 'Confirm',
	  children: null,
	  hidden: false,
	  mask: false,
	  okText: 'OK',
	  cancelText: 'Cancel',
	  onOK: null,
	  onCancel: null,
	  onClose: null
	};

	/**
	 * 图片查看器
	 */

	class Photo extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onClick);
	    this.handleClickImage = this.handleClickImage.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      url
	    } = this.props;
	    return React.createElement("div", {
	      className: 'PhotoMark',
	      onClick: this.handleClick
	    }, React.createElement("img", {
	      src: url,
	      onClick: this.handleClickImage
	    }));
	  }

	  handleClick(onClick, event) {
	    onClick && onClick(event);
	  }

	  handleClickImage(event) {
	    event.stopPropagation();
	  }

	}

	Photo.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  url: propTypes.string,
	  onClick: propTypes.func
	};
	Photo.defaultProps = {
	  className: null,
	  style: null,
	  url: null,
	  onClick: null
	};

	/**
	 * 弹窗输入框
	 */

	class Prompt extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      value: props.value
	    };
	    this.handleOK = this.handleOK.bind(this, props.onOK);
	    this.handleClose = this.handleClose.bind(this, props.onClose);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      title,
	      content,
	      hidden,
	      mask,
	      okText
	    } = this.props;
	    return React.createElement(Window, {
	      className: bind('Prompt', className),
	      style: style,
	      title: title,
	      hidden: hidden,
	      mask: mask,
	      onClose: this.handleClose
	    }, React.createElement(Content, null, content, React.createElement(Input, {
	      value: this.state.value,
	      onChange: this.handleChange
	    })), React.createElement(Buttons, null, React.createElement(Button, {
	      onClick: this.handleOK
	    }, okText)));
	  }

	  handleOK(onOK, event) {
	    onOK && onOK(this.state.value, event);
	  }

	  handleClose(onClose, event) {
	    onClose && onClose(event);
	  }

	  handleChange(value) {
	    this.setState({
	      value
	    });
	  }

	}

	Prompt.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  title: propTypes.string,
	  content: propTypes.node,
	  value: propTypes.string,
	  hidden: propTypes.bool,
	  mask: propTypes.bool,
	  okText: propTypes.string,
	  onOK: propTypes.func,
	  onClose: propTypes.func
	};
	Prompt.defaultProps = {
	  className: null,
	  style: null,
	  title: 'Prompt',
	  content: null,
	  value: '',
	  hidden: false,
	  mask: false,
	  okText: 'OK',
	  onOK: null,
	  onClose: null
	};

	/**
	 * 提示窗
	 */

	class Toast extends React.Component {
	  constructor(props) {
	    super(props);
	  }

	  render() {
	    const {
	      className,
	      style,
	      children
	    } = this.props;
	    return React.createElement("div", {
	      className: 'ToastMark'
	    }, React.createElement("div", {
	      className: bind('Toast', className),
	      style: style
	    }, children));
	  }

	}

	Toast.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  children: propTypes.node
	};
	Toast.defaultProps = {
	  className: null,
	  style: null,
	  children: null
	};

	/**
	 * 视频查看器
	 */

	class Video extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleClick = this.handleClick.bind(this, props.onClick);
	    this.handleClickImage = this.handleClickVideo.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style,
	      url
	    } = this.props;
	    return React.createElement("div", {
	      className: 'VideoMark',
	      onClick: this.handleClick
	    }, React.createElement("video", {
	      src: url,
	      autoPlay: 'autoplay',
	      controls: 'controls',
	      onClick: this.handleClickVideo
	    }));
	  }

	  handleClick(onClick, event) {
	    onClick && onClick(event);
	  }

	  handleClickVideo(event) {
	    event.stopPropagation();
	  }

	}

	Video.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  url: propTypes.string,
	  onClick: propTypes.func
	};
	Video.defaultProps = {
	  className: null,
	  style: null,
	  url: null,
	  onClick: null
	};

	/**
	 * 语言加载器
	 * @author tengge / https://github.com/tengge1
	 */

	class LanguageLoader {
	  constructor() {
	    window._t = i18next.t.bind(i18next);
	  }

	  load() {
	    let lang = window.localStorage.getItem('lang');

	    if (!lang) {
	      let language = window.navigator.language.toLocaleLowerCase();

	      if (language === 'zh-cn') {
	        lang = 'zh-CN';
	      } else {
	        lang = 'en-US';
	      }
	    }

	    return new Promise(resolve => {
	      i18next.use(Backend).init({
	        lng: lang,
	        debug: false,
	        whitelist: ['en-US', 'zh-CN', 'zh-TW', 'ja-JP', 'ko-KR', 'ru-RU', 'fr-FR'],
	        backend: {
	          // for all available options read the backend's repository readme file
	          loadPath: 'locales/{{lng}}.json'
	        },
	        // allow keys to be phrases having `:`, `.`
	        nsSeparator: false,
	        keySeparator: false,
	        // do not load a fallback
	        fallbackLng: false
	      }, (err, t) => {
	        resolve();
	      });
	    });
	  }

	}

	/**
	 * 存储类
	 */
	function Storage() {
	  if (this.get('showGrid') === undefined) {
	    this.set('showGrid', true);
	  }

	  if (this.get('showCamera') === undefined) {
	    this.set('showCamera', false);
	  }

	  if (this.get('showPointLight') === undefined) {
	    this.set('showPointLight', true);
	  }

	  if (this.get('showDirectionalLight') === undefined) {
	    this.set('showDirectionalLight', true);
	  }

	  if (this.get('showSpotLight') === undefined) {
	    this.set('showSpotLight', true);
	  }

	  if (this.get('showHemisphereLight') === undefined) {
	    this.set('showHemisphereLight', true);
	  }

	  if (this.get('showRectAreaLight') === undefined) {
	    this.set('showRectAreaLight', true);
	  }

	  if (this.get('showSkeleton') === undefined) {
	    this.set('showSkeleton', false);
	  }
	}

	Storage.prototype.get = function (key) {
	  var configs = this._getConfigs();

	  return configs[key];
	};

	Storage.prototype.set = function (key, value) {
	  var configs = this._getConfigs();

	  configs[key] = value;

	  this._setConfigs(configs);
	};

	Storage.prototype.setConfigs = function (configs) {
	  if (typeof configs !== 'object') {
	    console.warn(`Storage: configs should be an object.`);
	    return;
	  }

	  var _configs = this._getConfigs();

	  Object.keys(configs).forEach(n => {
	    _configs[n] = configs[n];
	  });

	  this._setConfigs(_configs);
	};

	Storage.prototype.remove = function (key) {
	  var configs = this._getConfigs();

	  delete configs[key];

	  this._setConfigs(configs);
	};

	Storage.prototype.clear = function () {
	  window.localStorage.removeItem('configs');
	};

	Storage.prototype._getConfigs = function () {
	  var configs = window.localStorage.getItem('configs');

	  if (!configs) {
	    configs = '{}';
	  }

	  return JSON.parse(configs);
	};

	Storage.prototype._setConfigs = function (configs) {
	  window.localStorage.setItem('configs', JSON.stringify(configs));
	};

	/**
	 * 自定义事件列表
	 * @author tengge / https://github.com/tengge1
	 */
	var EventList = [// dom事件
	'click', // 点击
	'contextmenu', // 右键
	'dblclick', // 双击
	'keydown', // 按下键盘按键
	'keyup', // 抬起键盘按键
	'mousedown', // 按下鼠标按键
	'mousemove', // 鼠标移动
	'mouseup', // 抬起鼠标按键
	'mousewheel', // 鼠标滚轮
	'resize', // 窗口大小改变
	'dragover', // 拖动到某元素上
	'drop', // 放置到某元素上
	// app事件
	'appStart', // 应用程序开始前调用
	'appStarted', // 应用程序开始后调用
	'appStop', // 程序开始结束前调用
	'appStoped', // 程序结束后调用
	'showMask', // 是否显示加载器
	// 配置
	'optionsChanged', // 配置改变事件（参数：无）
	'storageChanged', // 存储改变事件（参数：key, value）
	// 工具栏事件
	'changeMode', // 改变模式（select, translate, rotate, scale, delete）
	'changeView', // 改变视图（perspective, front, side, top）
	'viewChanged', // 视图已经改变
	// editor事件
	'sceneSaved', // 场景保存成功
	'select', // 选中事件
	'clear', // 清空场景
	'load', // 加载场景
	'log', // 日志事件
	'intersect', // 碰撞事件
	'editScript', // 编辑脚本事件 uuid, name, type, source
	'editorCleared', // 编辑器已经清空事件
	'snapChanged', // 对齐单元格事件
	'spaceChanged', // 空间坐标系改变事件
	'sceneGraphChanged', // 场景内容改变事件
	'cameraChanged', // 相机改变事件
	'rendererChanged', // 渲染器改变
	'geometryChanged', // 几何体改变事件
	'objectSelected', // 物体选中改变
	'objectFocused', // 物体交点改变事件
	'objectAdded', // 添加物体事件
	'objectChanged', // 物体改变事件
	'objectRemoved', // 物体移除事件
	'scriptAdded', // 添加脚本事件
	'scriptChanged', // 脚本改变事件
	'scriptRemoved', // 脚本移除事件
	'historyChanged', // 历史改变事件
	'refreshScriptEditor', // 刷新脚本编辑器事件
	'sceneLoaded', // 场景载入
	'postProcessingChanged', // 后期处理设置改变
	// 场景编辑区
	'transformControlsChange', // 变形控件改变
	'transformControlsMouseDown', // 变形控件按下鼠标键
	'transformControlsMouseUp', // 变形控件抬起鼠标键
	'raycast', // 光线投射事件
	'beforeRender', // 渲染前执行
	'afterRender', // 渲染后执行
	'animate', // 进行动画
	// 侧边栏
	'animationSelected', // 动画选中事件
	'animationChanged', // 动画发生改变事件
	'resetAnimation', // 重制动画时间轴
	'startAnimation', // 开始播放动画
	'animationTime', // 时间轴发送当前动画时间
	// 底部面板事件
	'selectBottomPanel', // 点击选择某个面板
	'showBottomPanel', // 显示某个底部面板以后
	'selectModel', // 选择模型
	'selectMap', // 选择贴图
	'selectMaterial', // 选择材质
	'selectAudio', // 选择音频
	'selectAnimation', // 选择动画
	'selectParticle', // 选择粒子
	// 状态栏事件
	'enableThrowBall'];

	var ID$7 = -1;
	/**
	 * 事件基类
	 * @author tengge / https://github.com/tengge1
	 */

	function BaseEvent(app) {
	  this.id = `${this.constructor.name}${ID$7--}`;
	}

	BaseEvent.prototype.start = function () {};

	BaseEvent.prototype.stop = function () {};

	/**
	* 命令基类
	* @author dforrer / https://github.com/dforrer
	* Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	* @param editorRef pointer to main editor object used to initialize each command object with a reference to the editor
	* @constructor
	*/
	function Command(editorRef) {
	  this.id = -1;
	  this.inMemory = false;
	  this.updatable = false;
	  this.type = '';
	  this.name = '';

	  if (editorRef !== undefined) {
	    Command.editor = editorRef;
	  }

	  this.editor = Command.editor;
	}

	Command.prototype.toJSON = function () {
	  var output = {};
	  output.type = this.type;
	  output.id = this.id;
	  output.name = this.name;
	  return output;
	};

	Command.prototype.fromJSON = function (json) {
	  this.inMemory = true;
	  this.type = json.type;
	  this.id = json.id;
	  this.name = json.name;
	};

	/**
	 * 移除物体命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param object THREE.Object3D
	 * @constructor
	 */

	function RemoveObjectCommand(object) {
	  Command.call(this);
	  this.type = 'RemoveObjectCommand';
	  this.name = _t('Remove Object');
	  this.object = object;
	  this.parent = object !== undefined ? object.parent : undefined;

	  if (this.parent !== undefined) {
	    this.index = this.parent.children.indexOf(this.object);
	  }
	}
	RemoveObjectCommand.prototype = Object.create(Command.prototype);
	Object.assign(RemoveObjectCommand.prototype, {
	  constructor: RemoveObjectCommand,
	  execute: function () {
	    var scope = this.editor;
	    this.parent.remove(this.object);

	    if (this.object === this.editor.selected) {
	      this.editor.select(null);
	    }

	    app.call('objectRemoved', this, this.object);
	  },
	  undo: function () {
	    var scope = this.editor;
	    this.parent.children.splice(this.index, 0, this.object);
	    this.object.parent = this.parent;
	    this.editor.select(this.object);
	    app.call('objectAdded', this, this.object);
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.object = this.object.toJSON();
	    output.index = this.index;
	    output.parentUuid = this.parent.uuid;
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.parent = this.editor.objectByUuid(json.parentUuid);

	    if (this.parent === undefined) {
	      this.parent = this.editor.scene;
	    }

	    this.index = json.index;
	    this.object = this.editor.objectByUuid(json.object.object.uuid);

	    if (this.object === undefined) {
	      var loader = new THREE.ObjectLoader();
	      this.object = loader.parse(json.object);
	    }
	  }
	});

	/**
	 * 键盘按键事件
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function KeyDownEvent(app) {
	  BaseEvent.call(this, app);
	}

	KeyDownEvent.prototype = Object.create(BaseEvent.prototype);
	KeyDownEvent.prototype.constructor = KeyDownEvent;

	KeyDownEvent.prototype.start = function () {
	  app.on(`keydown.${this.id}`, this.onKeyDown.bind(this));
	};

	KeyDownEvent.prototype.stop = function () {
	  app.on(`keydown.${this.id}`, null);
	};

	KeyDownEvent.prototype.onKeyDown = function (event) {
	  var editor = app.editor;

	  switch (event.keyCode) {
	    // bug: 会导致搜索框无法删除
	    // case 8: // 回退键
	    //     event.preventDefault(); // 阻止浏览器返回
	    //     break;
	    case 46:
	      // 删除键
	      var object = editor.selected;

	      if (object == null) {
	        return;
	      }

	      app.confirm({
	        title: _t('Confirm'),
	        content: `${_t('Delete')} ${object.name} ?`,
	        onOK: () => {
	          var parent = object.parent;

	          if (parent !== null) {
	            editor.execute(new RemoveObjectCommand(object));
	            app.call(`objectRemoved`, this, object);
	          }
	        }
	      });
	      break;

	    case 90:
	      // 注册Ctrl-Z撤销, Ctrl-Shift-Z重做
	      if (event.ctrlKey && event.shiftKey) {
	        editor.redo();
	      } else if (event.ctrlKey) {
	        editor.undo();
	      }

	      break;
	    // TODO： 和第一人称控制器ASDW冲突
	    // case 87: // 注册 W 移动模式
	    //     app.call('changeMode', this, 'translate');
	    //     break;
	    // case 69: // 注册 E 旋转模式
	    //     app.call('changeMode', this, 'rotate');
	    //     break;
	    // case 82: // 注册 R 缩放模式
	    //     app.call('changeMode', this, 'scale');
	    //     break;
	  }
	};

	/**
	 * 渲染事件
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function RenderEvent(app) {
	  BaseEvent.call(this, app);
	  this.clock = new THREE.Clock();
	  this.running = true;
	  this.render = this.render.bind(this);
	  this.createRenderer = this.createRenderer.bind(this);
	  this.onViewChanged = this.onViewChanged.bind(this);
	}

	RenderEvent.prototype = Object.create(BaseEvent.prototype);
	RenderEvent.prototype.constructor = RenderEvent;

	RenderEvent.prototype.start = function () {
	  this.running = true;
	  app.on(`appStarted.${this.id}`, this.render);
	  app.on(`viewChanged.${this.id}`, this.onViewChanged);
	};

	RenderEvent.prototype.stop = function () {
	  this.running = false;
	  app.on(`appStarted.${this.id}`, null);
	  app.on(`viewChanged.${this.id}`, null);
	};

	RenderEvent.prototype.render = function () {
	  const {
	    scene,
	    sceneHelpers,
	    renderer
	  } = app.editor;
	  const deltaTime = this.clock.getDelta();
	  app.call('animate', this, this.clock, deltaTime);
	  app.stats.begin();
	  scene.updateMatrixWorld();
	  sceneHelpers.updateMatrixWorld();
	  app.editor.renderer.clear();
	  app.call('beforeRender', this);

	  if (this.renderer === undefined) {
	    this.createRenderer().then(() => {
	      this.render();
	    });
	    app.on(`sceneLoaded.${this.id}`, this.createRenderer);
	    app.on(`postProcessingChanged.${this.id}`, this.createRenderer);
	    return;
	  } else {
	    this.renderer.render();
	  }

	  app.call('afterRender', this);
	  app.stats.end();

	  if (this.running) {
	    requestAnimationFrame(this.render);
	  }
	};

	RenderEvent.prototype.createRenderer = function () {
	  const {
	    scene,
	    sceneHelpers,
	    camera,
	    renderer
	  } = app.editor;
	  this.renderer = new EffectRenderer();
	  return this.renderer.create([scene, sceneHelpers], app.editor.view === 'perspective' ? camera : app.editor.orthCamera, renderer);
	};

	RenderEvent.prototype.onViewChanged = function (view) {
	  this.createRenderer();
	};

	/**
	 * 窗口大小改变事件
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function ResizeEvent(app) {
	  BaseEvent.call(this, app);
	}

	ResizeEvent.prototype = Object.create(BaseEvent.prototype);
	ResizeEvent.prototype.constructor = ResizeEvent;

	ResizeEvent.prototype.start = function () {
	  app.on(`resize.${this.id}`, this.onResize.bind(this));
	};

	ResizeEvent.prototype.stop = function () {
	  app.on(`resize.${this.id}`, null);
	};

	ResizeEvent.prototype.onResize = function () {
	  let {
	    editor,
	    viewport
	  } = app;
	  let {
	    DEFAULT_CAMERA,
	    camera,
	    orthCamera,
	    renderer
	  } = editor;
	  const width = viewport.clientWidth;
	  const height = viewport.clientHeight;

	  if (this.width === undefined || this.height === undefined) {
	    this.width = width;
	    this.height = height;
	  }

	  DEFAULT_CAMERA.aspect = width / height;
	  DEFAULT_CAMERA.updateProjectionMatrix();
	  camera.aspect = width / height;
	  camera.updateProjectionMatrix();

	  if (width !== this.width) {
	    let dwidth = (orthCamera.right - orthCamera.left) * (width / this.width - 1);
	    orthCamera.left -= dwidth / 2;
	    orthCamera.right += dwidth / 2;
	    this.width = width;
	  }

	  if (height !== this.height) {
	    let dheight = (orthCamera.top - orthCamera.bottom) * (height / this.height - 1);
	    orthCamera.top += dheight / 2;
	    orthCamera.bottom -= dheight / 2;
	    this.height = height;
	  }

	  orthCamera.updateProjectionMatrix();
	  renderer.setSize(width, height);
	};

	/**
	 * 滤镜事件
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function FilterEvent(app) {
	  BaseEvent.call(this, app);
	}

	FilterEvent.prototype = Object.create(BaseEvent.prototype);
	FilterEvent.prototype.constructor = FilterEvent;

	FilterEvent.prototype.start = function () {
	  app.on(`editorCleared.${this.id}`, this.onEditorCleared.bind(this));
	  app.on(`optionsChanged.${this.id}`, this.onOptionsChanged.bind(this));
	};

	FilterEvent.prototype.stop = function () {
	  app.on(`editorCleared.${this.id}`, null);
	  app.on(`optionsChanged.${this.id}`, null);
	};

	FilterEvent.prototype.onEditorCleared = function () {
	  app.editor.renderer.domElement.style.filter = '';
	};

	FilterEvent.prototype.onOptionsChanged = function () {
	  app.editor.renderer.domElement.style.filter = CssUtils.serializeFilter(app.options);
	};

	/**
	 * 正交相机控制器
	 * @author tengge / https://github.com/tengge1
	 * @param {THREE.OrthographicCamera} camera 正交相机
	 * @param {HTMLElement} domElement DOM
	 */
	function OrthographicCameraControls(camera, domElement) {
	  this.camera = camera;
	  this.domElement = domElement;
	  this.enabled = false;
	  this.isDown = false;
	  this.offsetXY = new THREE.Vector2();
	  this.onMouseDown = this.onMouseDown.bind(this);
	  this.onMouseMove = this.onMouseMove.bind(this);
	  this.onMouseUp = this.onMouseUp.bind(this);
	  this.onMouseWheel = this.onMouseWheel.bind(this);
	}

	OrthographicCameraControls.prototype.enable = function () {
	  if (this.enabled) {
	    return;
	  }

	  this.enabled = true;
	  this.domElement.addEventListener('mousedown', this.onMouseDown);
	  this.domElement.addEventListener('mousemove', this.onMouseMove);
	  this.domElement.addEventListener('mouseup', this.onMouseUp);
	  this.domElement.addEventListener('mousewheel', this.onMouseWheel);
	};

	OrthographicCameraControls.prototype.disable = function () {
	  if (!this.enabled) {
	    return;
	  }

	  this.enabled = false;
	  this.domElement.removeEventListener('mousedown', this.onMouseDown);
	  this.domElement.removeEventListener('mousemove', this.onMouseMove);
	  this.domElement.removeEventListener('mouseup', this.onMouseUp);
	  this.domElement.removeEventListener('mousewheel', this.onMouseWheel);
	};

	OrthographicCameraControls.prototype.onMouseDown = function (event) {
	  this.isDown = true;
	  this.offsetXY.set(event.offsetX, event.offsetY);
	};

	OrthographicCameraControls.prototype.onMouseMove = function (event) {
	  if (!this.isDown) {
	    return;
	  }

	  let camera = this.camera;
	  let width = this.domElement.clientWidth;
	  let height = this.domElement.clientHeight;
	  let dx = (event.offsetX - this.offsetXY.x) * (this.camera.right - this.camera.left) / width;
	  let dy = (event.offsetY - this.offsetXY.y) * (this.camera.top - this.camera.bottom) / height;
	  this.camera.left -= dx;
	  this.camera.right -= dx;
	  this.camera.top += dy;
	  this.camera.bottom += dy;
	  this.camera.updateProjectionMatrix();
	  this.offsetXY.set(event.offsetX, event.offsetY);
	};

	OrthographicCameraControls.prototype.onMouseUp = function (event) {
	  this.isDown = false;
	};

	OrthographicCameraControls.prototype.onMouseWheel = function (event) {
	  const delta = -event.wheelDelta / 1000;
	  let camera = this.camera;
	  let width = this.domElement.clientWidth;
	  let height = this.domElement.clientHeight;
	  let pointerX = camera.left + (camera.right - camera.left) * event.offsetX / width;
	  let pointerY = camera.top - (camera.top - camera.bottom) * event.offsetY / height;
	  camera.left = camera.left - Math.abs(pointerX - camera.left) * delta;
	  camera.right = camera.right + Math.abs(camera.right - pointerX) * delta;
	  camera.top = camera.top + Math.abs(camera.top - pointerY) * delta;
	  camera.bottom = camera.bottom - Math.abs(pointerY - camera.bottom) * delta;
	  camera.updateProjectionMatrix();
	};

	/**
	 * 视图事件
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function ViewEvent(app) {
	  BaseEvent.call(this, app);
	  this.changeView = this.changeView.bind(this);
	}

	ViewEvent.prototype = Object.create(BaseEvent.prototype);
	ViewEvent.prototype.constructor = ViewEvent;

	ViewEvent.prototype.start = function () {
	  app.on(`changeView.${this.id}`, this.changeView);
	};

	ViewEvent.prototype.stop = function () {
	  app.on(`changeView.${this.id}`, null);
	};

	ViewEvent.prototype.changeView = function (view) {
	  if (view === app.editor.view) {
	    return;
	  }

	  app.editor.view = view;

	  if (this.controls === undefined) {
	    this.controls = new OrthographicCameraControls(app.editor.orthCamera, app.editor.renderer.domElement);
	  }

	  if (view === 'perspective') {
	    app.editor.controls.enabled = true;
	    app.editor.showViewHelper = true;
	    this.controls.disable();
	    app.call(`viewChanged`, this, view);
	    return;
	  }

	  let camera = app.editor.orthCamera; // 使用透视相机离原点最远距离设置正交相机

	  let distance = Math.max(app.editor.camera.position.x, app.editor.camera.position.y, app.editor.camera.position.z);

	  switch (view) {
	    case 'front':
	      camera.position.set(distance, 0, 0);
	      camera.lookAt(new THREE.Vector3());
	      break;

	    case 'side':
	      camera.position.set(0, 0, distance);
	      camera.lookAt(new THREE.Vector3());
	      break;

	    case 'top':
	      camera.position.set(0, distance, 0);
	      camera.lookAt(new THREE.Vector3());
	      break;
	  }

	  app.editor.select(null);
	  app.editor.controls.enabled = false;
	  app.editor.showViewHelper = false;
	  this.controls.enable();
	  app.call(`viewChanged`, this, view);
	};

	/**
	 * 设置位置命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param object THREE.Object3D
	 * @param newPosition THREE.Vector3
	 * @param optionalOldPosition THREE.Vector3
	 * @constructor
	 */

	function SetPositionCommand(object, newPosition, optionalOldPosition) {
	  Command.call(this);
	  this.type = 'SetPositionCommand';
	  this.name = _t('Set Position');
	  this.updatable = true;
	  this.object = object;

	  if (object !== undefined && newPosition !== undefined) {
	    this.oldPosition = object.position.clone();
	    this.newPosition = newPosition.clone();
	  }

	  if (optionalOldPosition !== undefined) {
	    this.oldPosition = optionalOldPosition.clone();
	  }
	}
	SetPositionCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetPositionCommand.prototype, {
	  constructor: SetPositionCommand,
	  execute: function () {
	    this.object.position.copy(this.newPosition);
	    this.object.updateMatrixWorld(true);
	    app.call('objectChanged', this, this.object);
	  },
	  undo: function () {
	    this.object.position.copy(this.oldPosition);
	    this.object.updateMatrixWorld(true);
	    app.call('objectChanged', this, this.object);
	  },
	  update: function (command) {
	    this.newPosition.copy(command.newPosition);
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.oldPosition = this.oldPosition.toArray();
	    output.newPosition = this.newPosition.toArray();
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.oldPosition = new THREE.Vector3().fromArray(json.oldPosition);
	    this.newPosition = new THREE.Vector3().fromArray(json.newPosition);
	  }
	});

	/**
	 * 设置旋转命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param object THREE.Object3D
	 * @param newRotation THREE.Euler
	 * @param optionalOldRotation THREE.Euler
	 * @constructor
	 */

	function SetRotationCommand(object, newRotation, optionalOldRotation) {
	  Command.call(this);
	  this.type = 'SetRotationCommand';
	  this.name = _t('Set Rotation');
	  this.updatable = true;
	  this.object = object;

	  if (object !== undefined && newRotation !== undefined) {
	    this.oldRotation = object.rotation.clone();
	    this.newRotation = newRotation.clone();
	  }

	  if (optionalOldRotation !== undefined) {
	    this.oldRotation = optionalOldRotation.clone();
	  }
	}
	SetRotationCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetRotationCommand.prototype, {
	  constructor: SetRotationCommand,
	  execute: function () {
	    this.object.rotation.copy(this.newRotation);
	    this.object.updateMatrixWorld(true);
	    app.call('objectChanged', this, this.object);
	  },
	  undo: function () {
	    this.object.rotation.copy(this.oldRotation);
	    this.object.updateMatrixWorld(true);
	    app.call('objectChanged', this, this.object);
	  },
	  update: function (command) {
	    this.newRotation.copy(command.newRotation);
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.oldRotation = this.oldRotation.toArray();
	    output.newRotation = this.newRotation.toArray();
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.oldRotation = new THREE.Euler().fromArray(json.oldRotation);
	    this.newRotation = new THREE.Euler().fromArray(json.newRotation);
	  }
	});

	/**
	 * 设置缩放命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param object THREE.Object3D
	 * @param newScale THREE.Vector3
	 * @param optionalOldScale THREE.Vector3
	 * @constructor
	 */

	function SetScaleCommand(object, newScale, optionalOldScale) {
	  Command.call(this);
	  this.type = 'SetScaleCommand';
	  this.name = _t('Set Scale');
	  this.updatable = true;
	  this.object = object;

	  if (object !== undefined && newScale !== undefined) {
	    this.oldScale = object.scale.clone();
	    this.newScale = newScale.clone();
	  }

	  if (optionalOldScale !== undefined) {
	    this.oldScale = optionalOldScale.clone();
	  }
	}
	SetScaleCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetScaleCommand.prototype, {
	  constructor: SetScaleCommand,
	  execute: function () {
	    this.object.scale.copy(this.newScale);
	    this.object.updateMatrixWorld(true);
	    app.call('objectChanged', this, this.object);
	  },
	  undo: function () {
	    this.object.scale.copy(this.oldScale);
	    this.object.updateMatrixWorld(true);
	    app.call('objectChanged', this, this.object);
	  },
	  update: function (command) {
	    this.newScale.copy(command.newScale);
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.oldScale = this.oldScale.toArray();
	    output.newScale = this.newScale.toArray();
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.oldScale = new THREE.Vector3().fromArray(json.oldScale);
	    this.newScale = new THREE.Vector3().fromArray(json.newScale);
	  }
	});

	/**
	 * 平移旋转缩放控件事件
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function TransformControlsEvent(app) {
	  BaseEvent.call(this, app);
	  this.mode = 'translate';
	  this.objectPosition = null;
	  this.objectRotation = null;
	  this.objectScale = null;
	}

	TransformControlsEvent.prototype = Object.create(BaseEvent.prototype);
	TransformControlsEvent.prototype.constructor = TransformControlsEvent;

	TransformControlsEvent.prototype.start = function () {
	  app.on(`appStarted.${this.id}`, this.onAppStarted.bind(this));
	};

	TransformControlsEvent.prototype.onAppStarted = function () {
	  let transformControls = app.editor.transformControls;
	  transformControls.addEventListener('mouseDown', this.onMouseDown.bind(this));
	  transformControls.addEventListener('mouseUp', this.onMouseUp.bind(this));
	  app.on('objectSelected.' + this.id, this.onObjectSelected.bind(this));
	  app.on('changeMode.' + this.id, this.onChangeMode.bind(this));
	  app.on('snapChanged.' + this.id, this.onSnapChanged.bind(this));
	  app.on('spaceChanged.' + this.id, this.onSpaceChanged.bind(this));
	};
	/**
	 * 点击鼠标，记录选中物体当前平移、旋转和缩放值
	 */


	TransformControlsEvent.prototype.onMouseDown = function () {
	  if (app.editor.view !== 'perspective') {
	    return;
	  }

	  if (['translate', 'rotate', 'scale'].indexOf(this.mode) === -1) {
	    return;
	  }

	  var object = app.editor.transformControls.object;
	  this.objectPosition = object.position.clone();
	  this.objectRotation = object.rotation.clone();
	  this.objectScale = object.scale.clone();
	  app.editor.controls.enabled = false; // EditorControls
	};
	/**
	 * 抬起鼠标，更新选中物体的平移、旋转和缩放值
	 */


	TransformControlsEvent.prototype.onMouseUp = function () {
	  if (app.editor.view !== 'perspective') {
	    return;
	  }

	  if (['translate', 'rotate', 'scale'].indexOf(this.mode) === -1) {
	    return;
	  }

	  var editor = app.editor;
	  var transformControls = editor.transformControls;
	  var object = transformControls.object;

	  if (object == null) {
	    return;
	  }

	  switch (transformControls.getMode()) {
	    case 'translate':
	      if (!this.objectPosition.equals(object.position)) {
	        editor.execute(new SetPositionCommand(object, object.position, this.objectPosition));
	      }

	      break;

	    case 'rotate':
	      if (!this.objectRotation.equals(object.rotation)) {
	        editor.execute(new SetRotationCommand(object, object.rotation, this.objectRotation));
	      }

	      break;

	    case 'scale':
	      if (!this.objectScale.equals(object.scale)) {
	        editor.execute(new SetScaleCommand(object, object.scale, this.objectScale));
	      }

	      break;
	  }

	  app.editor.controls.enabled = true; // EditorControls
	};
	/**
	 * 物体已经选中
	 * @param {*} object 选中的物体
	 */


	TransformControlsEvent.prototype.onObjectSelected = function (object) {
	  app.editor.transformControls.detach();

	  if (['translate', 'rotate', 'scale'].indexOf(this.mode) === -1) {
	    return;
	  }

	  if (!object || object === app.editor.scene || object === app.editor.camera) {
	    return;
	  }

	  app.editor.transformControls.attach(object);
	};
	/**
	 * 切换平移、旋转、缩放模式
	 * @param {*} mode 模式
	 */


	TransformControlsEvent.prototype.onChangeMode = function (mode) {
	  this.mode = mode;
	  var transformControls = app.editor.transformControls;

	  if (mode === 'translate' || mode === 'rotate' || mode === 'scale') {
	    // 设置模式在选中物体上
	    transformControls.setMode(mode);
	    var object = app.editor.selected;

	    if (object != null) {
	      transformControls.attach(object);
	    }
	  } else {
	    // 取消对选中物体平移、旋转、缩放
	    transformControls.detach();
	  }
	};
	/**
	 * 设置平移移动的大小
	 * @param {*} dist 
	 */


	TransformControlsEvent.prototype.onSnapChanged = function (dist) {
	  app.editor.transformControls.setTranslationSnap(dist);
	};
	/**
	 * 设置世界坐标系还是物体坐标系
	 * @param {*} space 
	 */


	TransformControlsEvent.prototype.onSpaceChanged = function (space) {
	  app.editor.transformControls.setSpace(space);
	};

	/**
	 * 物体事件
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function ObjectEvent(app) {
	  BaseEvent.call(this, app);
	  this.box = new THREE.Box3();
	}

	ObjectEvent.prototype = Object.create(BaseEvent.prototype);
	ObjectEvent.prototype.constructor = ObjectEvent;

	ObjectEvent.prototype.start = function () {
	  app.on('objectAdded.' + this.id, this.onObjectAdded.bind(this));
	  app.on('objectChanged.' + this.id, this.onObjectChanged.bind(this));
	  app.on('objectRemoved.' + this.id, this.onObjectRemoved.bind(this));
	  app.on('objectFocused.' + this.id, this.onObjectFocused.bind(this));
	};

	ObjectEvent.prototype.stop = function () {
	  app.on('objectAdded.' + this.id, null);
	  app.on('objectChanged.' + this.id, null);
	  app.on('objectRemoved.' + this.id, null);
	  app.on('objectFocused.' + this.id, null);
	};

	ObjectEvent.prototype.onObjectAdded = function (object) {
	  var objects = app.editor.objects;
	  object.traverse(function (child) {
	    objects.push(child);
	  });
	};

	ObjectEvent.prototype.onObjectChanged = function (object) {
	  var editor = app.editor;

	  if (object instanceof THREE.PerspectiveCamera) {
	    object.updateProjectionMatrix();
	  }
	};

	ObjectEvent.prototype.onObjectRemoved = function (object) {
	  var objects = app.editor.objects;
	  object.traverse(function (child) {
	    objects.splice(objects.indexOf(child), 1);
	  });
	};

	ObjectEvent.prototype.onObjectFocused = function (object) {
	  var controls = app.editor.controls;
	  controls.focus(object);
	};

	/**
	 * 光线投射事件
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function RaycastEvent(app) {
	  BaseEvent.call(this, app);
	  this.mouse = new THREE.Vector2();
	  this.raycaster = new THREE.Raycaster();
	}

	RaycastEvent.prototype = Object.create(BaseEvent.prototype);
	RaycastEvent.prototype.constructor = RaycastEvent;

	RaycastEvent.prototype.start = function () {
	  app.on(`mousedown.${this.id}`, this.onMouseDown.bind(this));
	  app.on(`mouseup.${this.id}`, this.onMouseUp.bind(this));
	};

	RaycastEvent.prototype.stop = function () {
	  app.on(`mousedown.${this.id}`, null);
	  app.on(`mouseup.${this.id}`, null);
	};

	RaycastEvent.prototype.onMouseDown = function (event) {
	  if (event.target !== app.editor.renderer.domElement) {
	    return;
	  }

	  this.isDown = true;
	  this.x = event.offsetX;
	  this.y = event.offsetY;
	};

	RaycastEvent.prototype.onMouseUp = function (event) {
	  if (event.target !== app.editor.renderer.domElement) {
	    return;
	  }

	  if (!this.isDown || this.x !== event.offsetX || this.y !== event.offsetY) {
	    return;
	  }

	  var domElement = app.editor.renderer.domElement;
	  this.mouse.x = event.offsetX / domElement.clientWidth * 2 - 1;
	  this.mouse.y = -event.offsetY / domElement.clientHeight * 2 + 1;
	  this.raycaster.setFromCamera(this.mouse, app.editor.camera);
	  var intersects = this.raycaster.intersectObjects(app.editor.scene.children, false);

	  if (intersects.length > 0) {
	    app.call('raycast', this, intersects[0], intersects);
	  }
	};

	/**
	 * 选取事件
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function PickEvent(app) {
	  BaseEvent.call(this, app);
	  this.raycaster = new THREE.Raycaster();
	  this.mouse = new THREE.Vector2();
	  this.onDownPosition = new THREE.Vector2();
	  this.onUpPosition = new THREE.Vector2();
	  this.onDoubleClickPosition = new THREE.Vector2();
	}

	PickEvent.prototype = Object.create(BaseEvent.prototype);
	PickEvent.prototype.constructor = PickEvent;

	PickEvent.prototype.start = function () {
	  app.on(`appStarted.${this.id}`, this.onAppStarted.bind(this));
	};

	PickEvent.prototype.onAppStarted = function () {
	  var viewport = app.viewport;
	  viewport.addEventListener('mousedown', this.onMouseDown.bind(this), false);
	  viewport.addEventListener('dblclick', this.onDoubleClick.bind(this), false);
	};

	PickEvent.prototype.onMouseDown = function (event) {
	  if (event.button !== 0) {
	    // 只允许左键选中
	    return;
	  } // 这样处理选中的原因是避免把拖动误认为点击


	  event.preventDefault();
	  var array = this.getMousePosition(app.viewport, event.clientX, event.clientY);
	  this.onDownPosition.fromArray(array);
	  document.addEventListener('mouseup', this.onMouseUp.bind(this), false);
	};

	PickEvent.prototype.onMouseUp = function (event) {
	  var array = this.getMousePosition(app.viewport, event.clientX, event.clientY);
	  this.onUpPosition.fromArray(array);
	  this.handleClick();
	  document.removeEventListener('mouseup', this.onMouseUp, false);
	};

	PickEvent.prototype.onDoubleClick = function (event) {
	  var objects = app.editor.objects;
	  var array = this.getMousePosition(app.viewport, event.clientX, event.clientY);
	  this.onDoubleClickPosition.fromArray(array);
	  var intersects = this.getIntersects(this.onDoubleClickPosition, objects);

	  if (intersects.length > 0) {
	    var intersect = intersects[0];
	    app.call('objectFocused', this, intersect.object);
	  }
	};

	PickEvent.prototype.getIntersects = function (point, objects) {
	  this.mouse.set(point.x * 2 - 1, -(point.y * 2) + 1);
	  this.raycaster.setFromCamera(this.mouse, app.editor.camera);
	  return this.raycaster.intersectObjects(objects);
	};

	PickEvent.prototype.getMousePosition = function (dom, x, y) {
	  var rect = dom.getBoundingClientRect();
	  return [(x - rect.left) / rect.width, (y - rect.top) / rect.height];
	};

	PickEvent.prototype.handleClick = function () {
	  var editor = app.editor;
	  var objects = editor.objects;

	  if (this.onDownPosition.distanceTo(this.onUpPosition) === 0) {
	    var intersects = this.getIntersects(this.onUpPosition, objects);

	    if (intersects.length > 0) {
	      var object = intersects[0].object;

	      if (object.userData.object !== undefined) {
	        // helper
	        editor.select(object.userData.object);
	      } else {
	        editor.select(this.partToMesh(object));
	      }
	    } else {
	      editor.select(null);
	    } // objects in sceneHelpers


	    var sceneHelpers = app.editor.sceneHelpers;
	    var intersects = this.getIntersects(this.onUpPosition, sceneHelpers.children);

	    if (intersects.length > 0) {
	      if (!(intersects[0].object instanceof THREE.GridHelper)) {
	        // 禁止选中网格
	        editor.select(intersects[0].object);
	      }
	    }
	  }
	};
	/**
	 * 如果选中的是模型的一部分，改为选择整个模型
	 * @param {*} obj 
	 */


	PickEvent.prototype.partToMesh = function (obj) {
	  var scene = app.editor.scene;

	  if (obj === scene || obj.userData && obj.userData.Server === true) {
	    // 场景或服务端模型
	    return obj;
	  } // 判断obj是否是模型的一部分


	  var model = obj;
	  var isPart = false;

	  while (model) {
	    if (model === scene) {
	      break;
	    }

	    if (model.userData && model.userData.Server === true) {
	      isPart = true;
	      break;
	    }

	    model = model.parent;
	  }

	  if (isPart) {
	    return model;
	  }

	  return obj;
	};

	/**
	 * 编辑器控件事件
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function EditorControlsEvent(app) {
	  BaseEvent.call(this, app);
	}

	EditorControlsEvent.prototype = Object.create(BaseEvent.prototype);
	EditorControlsEvent.prototype.constructor = EditorControlsEvent;

	EditorControlsEvent.prototype.start = function () {
	  app.on(`appStarted.${this.id}`, this.onAppStarted.bind(this));
	  app.on(`editorCleared.${this.id}`, this.onEditorCleared.bind(this));
	};

	EditorControlsEvent.prototype.onAppStarted = function () {
	  app.editor.controls.addEventListener('change', this.onChange.bind(this));
	};

	EditorControlsEvent.prototype.onChange = function () {
	  app.call('cameraChanged', this, app.editor.camera);
	};

	EditorControlsEvent.prototype.onEditorCleared = function () {
	  var controls = app.editor.controls;
	  controls.center.set(0, 0, 0);
	};

	/**
	 * 拖动事件
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function DraggableEvent(app) {
	  BaseEvent.call(this, app);
	}

	DraggableEvent.prototype = Object.create(BaseEvent.prototype);
	DraggableEvent.prototype.constructor = DraggableEvent;

	DraggableEvent.prototype.start = function () {
	  app.on(`appStarted.${this.id}`, this.onAppStarted.bind(this));
	};

	DraggableEvent.prototype.onAppStarted = function () {
	  var visual = app.editor.visual;
	  var component = null;
	  var drag = d3.drag().on('start', function () {
	    var target = d3.event.sourceEvent.target;
	    var id = d3.select(target).attr('data-id');

	    if (!id) {
	      return;
	    }

	    component = visual.get(id);
	  }).on('drag', function () {
	    if (!component) {
	      return;
	    }

	    if (component.setTranslate) {
	      component.setTranslate(d3.event.dx, d3.event.dy);
	    }
	  }).on('end', function () {
	    component = null;
	  });
	  d3.select(app.editor.svg).call(drag);
	};

	/**
	 * 事件执行器
	 * @author tengge / https://github.com/tengge1
	 */

	function EventDispatcher(app) {
	  this.dispatch = d3.dispatch.apply(d3.dispatch, EventList);
	  this.addDomEventListener();
	  this.events = [// 核心事件
	  new KeyDownEvent(app), new RenderEvent(app), new ResizeEvent(app), new FilterEvent(app), new ViewEvent(app), // viewport中的事件
	  new TransformControlsEvent(app), new ObjectEvent(app), new RaycastEvent(app), new PickEvent(app), new EditorControlsEvent(app), // 可视化
	  new DraggableEvent(app)];
	}

	EventDispatcher.prototype = Object.create(BaseEvent.prototype);
	EventDispatcher.prototype.constructor = EventDispatcher;
	/**
	 * 启动
	 */

	EventDispatcher.prototype.start = function () {
	  this.events.forEach(n => {
	    n.start();
	  });
	};
	/**
	 * 停止
	 */


	EventDispatcher.prototype.stop = function () {
	  this.events.forEach(n => {
	    n.stop();
	  });
	};
	/**
	 * 执行事件
	 * @param {*} eventName 
	 * @param {*} _this 
	 * @param {*} others 
	 */


	EventDispatcher.prototype.call = function (eventName, _this, ...others) {
	  this.dispatch.call(eventName, _this, ...others);
	};
	/**
	 * 监听事件
	 * @param {*} eventName 
	 * @param {*} callback 
	 */


	EventDispatcher.prototype.on = function (eventName, callback) {
	  this.dispatch.on(eventName, callback);
	};
	/**
	 * 监听dom事件
	 */


	EventDispatcher.prototype.addDomEventListener = function () {
	  var container = app.container;
	  container.addEventListener('click', event => {
	    this.dispatch.call('click', this, event);
	  });
	  container.addEventListener('contextmenu', event => {
	    this.dispatch.call('contextmenu', this, event);
	    event.preventDefault();
	    return false;
	  });
	  container.addEventListener('dblclick', event => {
	    this.dispatch.call('dblclick', this, event);
	  });
	  document.addEventListener('keydown', event => {
	    this.dispatch.call('keydown', this, event);
	  });
	  document.addEventListener('keyup', event => {
	    this.dispatch.call('keyup', this, event);
	  });
	  container.addEventListener('mousedown', event => {
	    this.dispatch.call('mousedown', this, event);
	  });
	  container.addEventListener('mousemove', event => {
	    this.dispatch.call('mousemove', this, event);
	  });
	  container.addEventListener('mouseup', event => {
	    this.dispatch.call('mouseup', this, event);
	  });
	  container.addEventListener('mousewheel', event => {
	    this.dispatch.call('mousewheel', this, event);
	  });
	  window.addEventListener('resize', event => {
	    this.dispatch.call('resize', this, event);
	  }, false);
	  document.addEventListener('dragover', event => {
	    this.dispatch.call('dragover', this, event);
	  }, false);
	  document.addEventListener('drop', event => {
	    this.dispatch.call('drop', this, event);
	  }, false);
	};

	/**
	 * 获取MIME-Type后缀名
	 * @param {*} mimeType MIME-Type
	 */
	function getExtension(mimeType) {
	  switch (mimeType) {
	    case 'image/jpeg':
	      return 'jpg';

	    case 'image/png':
	      return 'png';

	    case 'image/gif':
	      return 'gif';

	    case 'image/bmp':
	      return 'bmp';

	    default:
	      console.error(`MIMETypeUtils: unknown MIME-Type: ${mimeType}`);
	      return 'unknown';
	  }
	}
	/**
	 * 获取MIME-Type类型
	 * @param {*} extension 文件名后缀
	 */


	function getMIMEType(extension) {
	  extension = extension.trimLeft('.');

	  switch (extension.toLowerCase()) {
	    case 'jpg':
	    case 'jpeg':
	      return 'image/jpeg';

	    case 'png':
	      return 'image/png';

	    case 'gif':
	      return 'image/gif';

	    case 'bmp':
	      return 'image/bmp';

	    default:
	      console.warn(`MIMETypeUtils: unknown extension ${extension}.`);
	      return 'application/octet-stream';
	  }
	}
	/**
	 * MIME-Type工具类
	 */


	const MIMETypeUtils = {
	  getExtension: getExtension,
	  getMIMEType: getMIMEType
	};

	/**
	 * ajax
	 * @author tengge / https://github.com/tengge1
	 * @param {*} params 参数
	 */

	function ajax$1(params) {
	  const url = params.url || '';
	  const method = params.method || 'GET';
	  const data = params.data || null;
	  const callback = params.callback || null;
	  const xhr = new XMLHttpRequest();
	  xhr.open(method, url, true);

	  xhr.onreadystatechange = function () {
	    if (xhr.readyState === 4) {
	      var data = xhr.responseText;
	      typeof callback === 'function' && callback(data);
	    }
	  };

	  if (data === null) {
	    // 不需要POST数据
	    xhr.send(null);
	    return;
	  } // 判断是发送表单还是上传文件
	  // 由于API Controller只能序列化Content-Type为`application/x-www-form-urlencoded`的数据，所以发送表单和上传文件只能二选一。
	  // 否则报错："No MediaTypeFormatter is available to read an object of type 'EditTextureModel' from content with media type 'multipart/form-data'.


	  var hasFile = false;

	  for (var name in data) {
	    if (data[name] instanceof Blob) {
	      hasFile = true;
	      break;
	    }
	  }

	  if (hasFile) {
	    // 上传文件
	    var formData = new FormData();

	    for (var name in data) {
	      if (data[name] instanceof File) {
	        formData.append(name, data[name]);
	      } else if (data[name] instanceof Blob) {
	        formData.append(name, data[name], `${data[name].name}.${MIMETypeUtils.getExtension(data[name].type)}`);
	      }
	    }

	    xhr.send(formData);
	  } else {
	    // 发送表单
	    var bodies = [];

	    for (var name in data) {
	      bodies.push(name + '=' + encodeURIComponent(data[name]));
	    }

	    var body = bodies.join('&');

	    if (body.length) {
	      xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
	    }

	    xhr.send(body);
	  }
	}
	/**
	 * get请求
	 * @param {*} url 地址
	 * @param {*} callback 回调函数
	 */


	function get$1(url, callback) {
	  ajax$1({
	    url: url,
	    callback: callback
	  });
	}
	/**
	 * get请求并解析json数据
	 * @param {*} url 
	 * @param {*} callback 
	 */


	function getJson(url, callback) {
	  ajax$1({
	    url: url,
	    callback: function (data) {
	      typeof callback === 'function' && callback(JSON.parse(data));
	    }
	  });
	}
	/**
	 * post请求
	 * @param {*} url 地址
	 * @param {*} data 数据
	 * @param {*} callback 回调函数
	 */


	function post(url, data, callback) {
	  const _data = typeof data === 'function' ? null : data;

	  const _callback = typeof data === 'function' ? data : callback;

	  ajax$1({
	    url: url,
	    method: 'POST',
	    data: _data,
	    callback: _callback
	  });
	}
	/**
	 * Ajax
	 */


	const Ajax = {
	  ajax: ajax$1,
	  get: get$1,
	  getJson: getJson,
	  post: post
	};

	/**
	 * GIS场景
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 应用程序
	 * @param {Object} options 配置
	 * @param {Boolean} options.useCameraPosition 是否使用相机位置
	 */

	function Scene(app, options = {}) {
	  this.options = options;
	  this.options.useCameraPosition = this.options.useCameraPosition || false;
	}

	Scene.prototype.start = function () {
	  var editor = app.editor;
	  this.oldBackground = editor.scene.background;
	  editor.scene.background = null;
	  editor.sceneHelpers.visible = false;
	  editor.controls.enabled = false;
	  editor.controls.dispose();
	  editor.transformControls.enabled = false;
	  app.editor.showViewHelper = false;
	  this.globe = new Globe(editor.camera, editor.renderer, {
	    server: app.options.server,
	    useCameraPosition: this.options.useCameraPosition
	  });
	  editor.scene.add(this.globe);
	  this.oldSceneBeforeRender = editor.scene.onBeforeRender;
	  editor.scene.onBeforeRender = this.update.bind(this);
	};

	Scene.prototype.update = function () {
	  this.globe.update();
	};

	Scene.prototype.stop = function () {
	  app.on(`afterRender.${this.id}`, null);
	  this.globe.dispose();
	  delete this.globe;
	  var editor = app.editor;
	  editor.scene.onBeforeRender = this.oldSceneBeforeRender;
	  delete this.oldSceneBeforeRender;
	  editor.background = this.oldBackground;
	  editor.sceneHelpers.visible = true;
	  editor.controls = new THREE.EditorControls(editor.camera, editor.renderer.domElement);
	  editor.transformControls.enabled = true;
	  app.editor.showViewHelper = true;
	};

	/**
	 * 场景菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class SceneMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleCreateEmptyScene = this.handleCreateEmptyScene.bind(this);
	    this.handleCreateGISScene = this.handleCreateGISScene.bind(this);
	    this.handleSaveScene = this.handleSaveScene.bind(this);
	    this.handleSaveAsScene = this.handleSaveAsScene.bind(this);
	    this.handleExportScene = this.handleExportScene.bind(this);
	  }

	  render() {
	    return React.createElement(MenuItem, {
	      title: _t('Scene')
	    }, React.createElement(MenuItem, {
	      title: _t('New')
	    }, React.createElement(MenuItem, {
	      title: _t('Empty Scene'),
	      onClick: this.handleCreateEmptyScene
	    }), React.createElement(MenuItem, {
	      title: _t('GIS Scene'),
	      onClick: this.handleCreateGISScene
	    })), React.createElement(MenuItem, {
	      title: _t('Save'),
	      onClick: this.handleSaveScene
	    }), React.createElement(MenuItem, {
	      title: _t('Save As'),
	      onClick: this.handleSaveAsScene
	    }), React.createElement(MenuItemSeparator, null), React.createElement(MenuItem, {
	      title: _t('Publish Scene'),
	      onClick: this.handleExportScene
	    }));
	  } // ---------------------------- 新建空场景 ---------------------------------


	  handleCreateEmptyScene() {
	    var editor = app.editor;

	    if (editor.sceneID == null) {
	      editor.clear();
	      editor.sceneID = null;
	      editor.sceneName = null;
	      document.title = _t('No Name');
	      app.toast(_t('Create empty scene successfully.'));
	      return;
	    }

	    app.confirm({
	      title: _t('Confirm'),
	      content: _t('All unsaved data will be lost. Are you sure?'),
	      onOK: () => {
	        editor.clear();
	        editor.sceneID = null;
	        editor.sceneName = null;
	        app.options.sceneType = 'Empty';
	        document.title = _t('No Name');
	        app.editor.camera.userData.control = 'OrbitControls';
	      }
	    });
	  } // --------------------------- 新建GIS场景 -------------------------------------


	  handleCreateGISScene() {
	    if (app.editor.gis) {
	      app.editor.gis.stop();
	    }

	    app.editor.gis = new Scene(app);
	    app.editor.gis.start();
	    app.options.sceneType = 'GIS';
	    app.editor.camera.userData.control = '';
	    app.call(`sceneGraphChanged`, this);
	  } // --------------------------- 保存场景 ----------------------------------------


	  handleSaveScene() {
	    // 保存场景
	    var editor = app.editor;
	    var id = editor.sceneID;
	    var sceneName = editor.sceneName;

	    if (id) {
	      // 编辑场景
	      this.commitSave(id, sceneName);
	    } else {
	      // 新建场景
	      app.prompt({
	        title: _t('Save Scene'),
	        content: _t('Name'),
	        value: _t('New Scene'),
	        onOK: name => {
	          this.commitSave(id, name);
	        }
	      });
	    }
	  }

	  commitSave(id, sceneName) {
	    var editor = app.editor; // 记录选中物体，以便载入时还原场景选中

	    var selected = app.editor.selected;

	    if (selected) {
	      app.options.selected = selected.uuid;
	    }

	    app.mask(_t('Waiting...'));
	    var obj = new Converter().toJSON({
	      options: app.options,
	      camera: editor.camera,
	      renderer: editor.renderer,
	      scripts: editor.scripts,
	      animations: editor.animations,
	      scene: editor.scene,
	      visual: editor.visual
	    });
	    var params = {
	      Name: sceneName,
	      Data: JSON.stringify(obj)
	    };

	    if (id) {
	      params.ID = id;
	    }

	    Ajax.post(`${app.options.server}/api/Scene/Save`, params, result => {
	      var obj = JSON.parse(result);

	      if (obj.Code === 200) {
	        editor.sceneID = obj.ID;
	        editor.sceneName = sceneName;
	        document.title = sceneName;
	      }

	      app.call(`sceneSaved`, this);
	      app.unmask();
	      app.toast(_t(obj.Msg));
	    });
	  } // --------------------------- 另存为场景 -------------------------------------


	  handleSaveAsScene() {
	    var sceneName = app.editor.sceneName;

	    if (sceneName == null) {
	      sceneName = _t('New Scene');
	    }

	    app.prompt({
	      title: _t('Save Scene'),
	      content: _t('Name'),
	      value: sceneName,
	      onOK: name => {
	        app.editor.sceneName = name;
	        document.title = name;
	        this.commitSaveAs(name);
	      }
	    });
	  }

	  commitSaveAs(sceneName) {
	    var editor = app.editor;
	    app.mask(_t('Waiting...'));
	    var obj = new Converter().toJSON({
	      options: app.options,
	      camera: editor.camera,
	      renderer: editor.renderer,
	      scripts: editor.scripts,
	      animations: editor.animations,
	      scene: editor.scene,
	      visual: editor.visual
	    });
	    Ajax.post(`${app.options.server}/api/Scene/Save`, {
	      Name: sceneName,
	      Data: JSON.stringify(obj)
	    }, result => {
	      var obj = JSON.parse(result);

	      if (obj.Code === 200) {
	        editor.sceneID = obj.ID;
	        editor.sceneName = sceneName;
	        document.title = sceneName;
	      }

	      app.call(`sceneSaved`, this);
	      app.unmask();
	      app.toast(_t(obj.Msg));
	    });
	  } // -------------------------- 导出场景 --------------------------------


	  handleExportScene() {
	    var sceneID = app.editor.sceneID;

	    if (!sceneID) {
	      app.toast(_t('Please open scene first.'));
	      return;
	    }

	    app.confirm({
	      title: _t('Query'),
	      content: _t('Are you sure to export the current scene?'),
	      onOK: () => {
	        app.mask(_t('Exporting...'));
	        fetch(`${app.options.server}/api/ExportScene/Run?ID=${sceneID}`, {
	          method: 'POST'
	        }).then(response => {
	          if (response.ok) {
	            response.json().then(json => {
	              app.unmask();
	              app.toast(_t(json.Msg));
	              window.open(`${app.options.server}${json.Url}`, 'export');
	            });
	          }
	        });
	      }
	    });
	  }

	}

	/**
	 * 添加物体命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param object THREE.Object3D
	 * @constructor
	 */

	function AddObjectCommand(object) {
	  Command.call(this);
	  this.type = 'AddObjectCommand';
	  this.object = object;

	  if (object !== undefined) {
	    this.name = _t('Add Object') + object.name;
	  }
	}
	AddObjectCommand.prototype = Object.create(Command.prototype);
	Object.assign(AddObjectCommand.prototype, {
	  constructor: AddObjectCommand,
	  execute: function () {
	    this.editor.addObject(this.object);
	    this.editor.select(this.object);
	  },
	  undo: function () {
	    this.editor.removeObject(this.object);
	    this.editor.deselect();
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.object = this.object.toJSON();
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.object.object.uuid);

	    if (this.object === undefined) {
	      var loader = new THREE.ObjectLoader();
	      this.object = loader.parse(json.object);
	    }
	  }
	});

	/**
	 * 编辑菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class EditMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      enableUndo: false,
	      enableRedo: false,
	      enableClearHistory: false,
	      enableClone: false,
	      enableDelete: false
	    };
	    this.handleUndo = this.handleUndo.bind(this);
	    this.handleRedo = this.handleRedo.bind(this);
	    this.handleClearHistory = this.handleClearHistory.bind(this);
	    this.handleClone = this.handleClone.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.onHistoryChanged = this.onHistoryChanged.bind(this);
	    this.onObjectSelected = this.onObjectSelected.bind(this);
	  }

	  render() {
	    const {
	      enableUndo,
	      enableRedo,
	      enableClearHistory,
	      enableClone,
	      enableDelete
	    } = this.state;
	    return React.createElement(MenuItem, {
	      title: _t('Edit')
	    }, React.createElement(MenuItem, {
	      title: `${_t('Undo')}(Ctrl+Z)`,
	      disabled: !enableUndo,
	      onClick: this.handleUndo
	    }), React.createElement(MenuItem, {
	      title: `${_t('Redo')}(Ctrl+Y)`,
	      disabled: !enableRedo,
	      onClick: this.handleRedo
	    }), React.createElement(MenuItem, {
	      title: _t('Clear History'),
	      disabled: !enableClearHistory,
	      onClick: this.handleClearHistory
	    }), React.createElement(MenuItemSeparator, null), React.createElement(MenuItem, {
	      title: _t('Clone'),
	      disabled: !enableClone,
	      onClick: this.handleClone
	    }), React.createElement(MenuItem, {
	      title: `${_t('Delete')}(Del)`,
	      disabled: !enableDelete,
	      onClick: this.handleDelete
	    }));
	  }

	  componentDidMount() {
	    app.on(`historyChanged.EditMenu`, this.onHistoryChanged);
	    app.on(`objectSelected.EditMenu`, this.onObjectSelected);
	  } // --------------------- 撤销 --------------------------


	  handleUndo() {
	    var history = app.editor.history;

	    if (history.undos.length === 0) {
	      return;
	    }

	    app.editor.undo();
	  } // --------------------- 重做 -----------------------------


	  handleRedo() {
	    var history = app.editor.history;

	    if (history.redos.length === 0) {
	      return;
	    }

	    app.editor.redo();
	  } // -------------------- 清空历史记录 --------------------------------


	  handleClearHistory() {
	    var editor = app.editor;
	    var history = editor.history;

	    if (history.undos.length === 0 && history.redos.length === 0) {
	      return;
	    }

	    app.confirm({
	      title: _t('Confirm'),
	      content: _t('Undo/Redo history will be cleared. Are you sure?'),
	      onOK: () => {
	        editor.history.clear();
	      }
	    });
	  } // -------------------------- 复制 -----------------------------------


	  handleClone() {
	    var editor = app.editor;
	    var object = editor.selected;

	    if (object == null || object.parent == null) {
	      // 避免复制场景或相机
	      return;
	    }

	    object = object.clone();
	    editor.execute(new AddObjectCommand(object));
	  } // ----------------------- 删除 -----------------------------------


	  handleDelete() {
	    var editor = app.editor;
	    var object = editor.selected;

	    if (object == null || object.parent == null) {
	      // 避免删除场景或相机
	      return;
	    }

	    app.confirm({
	      title: _t('Confirm'),
	      content: _t('Delete') + ' ' + object.name + '?',
	      onOK: () => {
	        editor.execute(new RemoveObjectCommand(object));
	      }
	    });
	  } // ---------------------- 事件 -----------------------


	  onHistoryChanged() {
	    const history = app.editor.history;
	    this.setState({
	      enableUndo: history.undos.length > 0,
	      enableRedo: history.redos.length > 0,
	      enableClearHistory: history.undos.length > 0 || history.redos.length > 0
	    });
	  }

	  onObjectSelected() {
	    const editor = app.editor;
	    this.setState({
	      enableClone: editor.selected && editor.selected.parent != null,
	      enableDelete: editor.selected && editor.selected.parent != null
	    });
	  }

	}

	var ID$8 = -1;
	/**
	 * 所有可视化组件基类
	 * @author tengge / https://github.com/tengge1
	 */

	function BaseComponent() {
	  this.id = `VisualComponent${ID$8--}`;
	  this.type = 'VisualComponent'; // 根据此字段判断类型，进行反序列化
	}
	/**
	 * 实现该函数，可以在编辑器中拖动该控件。
	 * 原型:setTranslate(dx, dy)
	 */


	BaseComponent.prototype.setTranslate = null;
	/**
	 * 渲染组件
	 * @param {SVGElement} parent 父组件
	 */

	BaseComponent.prototype.render = function (parent) {};
	/**
	 * 组件转json
	 */


	BaseComponent.prototype.toJSON = function () {};
	/**
	 * json转组件
	 * @param {Object} json JSON字符串反序列化后的对象
	 */


	BaseComponent.prototype.fromJSON = function (json) {};
	/**
	 * 清空组件
	 */


	BaseComponent.prototype.clear = function () {};

	/**
	 * 按钮
	 * @author tengge / https://github.com/tengge1
	 */

	function Button$1() {
	  BaseComponent.call(this);
	  this.type = 'Button';
	  this.text = 'Button';
	  this.transform = null;
	}

	Button$1.prototype = Object.create(BaseComponent.prototype);
	Button$1.prototype.constructor = Button$1;

	Button$1.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	Button$1.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var paddingLeft = 8;
	  var paddingTop = 4;
	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('Button', true).style('pointer-events', 'all').style('cursor', 'pointer');
	  var rect = g.append('rect').attr('data-id', this.id).attr('x', 0).attr('y', 0).attr('stroke', '#3399ff').attr('stroke-width', 2).attr('fill', 'rgba(51,153,255,0.5)');
	  var text = g.append('text').attr('data-id', this.id).text(this.text).attr('fill', '#fff');
	  var box = text.node().getBBox();
	  var boxWidth = box.width + paddingLeft * 2;
	  var boxHeight = box.height + paddingTop * 2;
	  rect.attr('width', boxWidth).attr('height', boxHeight);
	  text.attr('x', paddingLeft).attr('y', paddingTop - box.y);

	  if (!this.transform) {
	    var left = (parent.clientWidth - boxWidth) / 2;
	    var top = (parent.clientHeight - boxHeight) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  g.on(`mouseenter.${this.id}`, this.onMouseEnter.bind(this));
	  g.on(`mouseleave.${this.id}`, this.onMouseLeave.bind(this));
	  this.dom = g;
	};

	Button$1.prototype.onMouseEnter = function () {
	  if (this.dom) {
	    this.dom.select('rect').attr('fill', 'rgba(51,153,255,0.8)');
	  }
	};

	Button$1.prototype.onMouseLeave = function () {
	  if (this.dom) {
	    this.dom.select('rect').attr('fill', 'rgba(51,153,255,0.5)');
	  }
	};

	Button$1.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    text: this.text,
	    transform
	  };
	};

	Button$1.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.text = json.text;
	  this.transform = json.transform || null;
	};

	Button$1.prototype.clear = function () {
	  this.text = 'Button';
	  this.transform = null;
	  this.dom.on(`mouseover.${this.id}`, null);
	  this.dom.on(`mouseleave.${this.id}`, null);
	  delete this.dom;
	};

	/**
	 * 标签
	 * @author tengge / https://github.com/tengge1
	 */

	function Label$1() {
	  BaseComponent.call(this);
	  this.type = 'Label';
	  this.text = 'Label';
	  this.transform = null;
	}

	Label$1.prototype = Object.create(BaseComponent.prototype);
	Label$1.prototype.constructor = Label$1;

	Label$1.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	Label$1.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var padding = 2;
	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('Label', true).style('pointer-events', 'all');
	  var text = g.append('text').attr('data-id', this.id).text(this.text).attr('fill', '#fff');
	  var box = text.node().getBBox();
	  var boxWidth = box.width + padding * 2;
	  var boxHeight = box.height + padding * 2;
	  text.attr('x', padding).attr('y', padding - box.y);

	  if (!this.transform) {
	    var left = (parent.clientWidth - boxWidth) / 2;
	    var top = (parent.clientHeight - boxHeight) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	Label$1.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    text: this.text,
	    transform
	  };
	};

	Label$1.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.text = json.text;
	  this.transform = json.transform || null;
	};

	Label$1.prototype.clear = function () {
	  this.text = 'Label';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 面板
	 * @author tengge / https://github.com/tengge1
	 */

	function Panel$1() {
	  BaseComponent.call(this);
	  this.type = 'Panel';
	  this.width = 302;
	  this.height = 358;
	  this.title = 'Panel';
	  this.transform = null;
	}

	Panel$1.prototype = Object.create(BaseComponent.prototype);
	Panel$1.prototype.constructor = Panel$1;

	Panel$1.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	Panel$1.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('Panel', true).style('pointer-events', 'all'); // 背景

	  g.append('path').attr('data-id', this.id).attr('d', 'M0,0L256,0L302,41L302,358L16,358L0,350Z').attr('fill', 'rgba(45,48,60,0.95)'); // 左边界线

	  g.append('path').attr('data-id', this.id).attr('d', 'M26,22L5,22L5,220L10,225L10,248L5,254L5,345L26,354L48,354').attr('stroke', '#2d758f').attr('stroke-width', 2).attr('fill', 'none'); // 右边界线

	  g.append('path').attr('data-id', this.id).attr('d', 'M220,22L264,22L295,56L295,354L104,354').attr('stroke', '#2d758f').attr('stroke-width', 2).attr('fill', 'none'); // 标题

	  g.append('text').attr('data-id', this.id).text(this.title).attr('x', 38).attr('y', 30).attr('font-size', 22).attr('font-weight', 'bold').attr('fill', '#498e7b');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	Panel$1.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	Panel$1.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	Panel$1.prototype.clear = function () {
	  this.title = 'Panel';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 水平线
	 * @author tengge / https://github.com/tengge1
	 */

	function HorizontalLine() {
	  BaseComponent.call(this);
	  this.type = 'HorizontalLine';
	  this.width = 240;
	  this.height = 0;
	  this.transform = null;
	}

	HorizontalLine.prototype = Object.create(BaseComponent.prototype);
	HorizontalLine.prototype.constructor = HorizontalLine;

	HorizontalLine.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	HorizontalLine.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('HorizontalLine', true).style('pointer-events', 'all'); // 可拖拽区域

	  g.append('path').attr('data-id', this.id).attr('d', 'M-4,-4L244,-4L244,4L-4,4Z').attr('stroke', '0').attr('fill', 'none');
	  g.append('line').attr('data-id', this.id).attr('x1', 0).attr('y1', 0).attr('x2', 240).attr('y2', 0).attr('stroke', 'rgba(0,0,0,0.4)').attr('stroke-width', 2);

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	HorizontalLine.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    width: this.width,
	    transform
	  };
	};

	HorizontalLine.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.width = json.width;
	  this.height = json.height;
	  this.transform = json.transform || null;
	};

	HorizontalLine.prototype.clear = function () {
	  this.width = 240;
	  this.height = 0;
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 条形图
	 * @author tengge / https://github.com/tengge1
	 */

	function BarChart() {
	  BaseComponent.call(this);
	  this.type = 'BarChart';
	  this.width = 180;
	  this.height = 212;
	  this.title = 'BarChart';
	  this.data = [{
	    text: '桌椅松动',
	    value: 100 / 105
	  }, {
	    text: '启动活门',
	    value: 100 / 105
	  }, {
	    text: '雷达系统',
	    value: 73 / 105
	  }, {
	    text: '引气系统',
	    value: 72 / 105
	  }, {
	    text: '防冰活门',
	    value: 69 / 105
	  }, {
	    text: '引擎',
	    value: 46 / 105
	  }, {
	    text: '起落架',
	    value: 42 / 105
	  }];
	  this.transform = null;
	}

	BarChart.prototype = Object.create(BaseComponent.prototype);
	BarChart.prototype.constructor = BarChart;

	BarChart.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	BarChart.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('BarChart', true).style('pointer-events', 'all'); // 面板背景

	  g.append('rect').attr('data-id', this.id).attr('x', 0).attr('y', 0).attr('width', 180).attr('height', 212).attr('fill', 'rgba(0,0,0,0.2)'); // 底部标题

	  g.append('path').attr('data-id', this.id).attr('d', 'M11,0 L72,0 L85,12 L72,24 L11,24 L0,12 Z').attr('transform', 'translate(50,200)').attr('fill', '#2d232c');
	  g.append('text').attr('data-id', this.id).text(this.title).attr('transform', 'translate(88,217)').attr('fill', '#4ccdfc').attr('font-size', 14).attr('text-anchor', 'middle'); // 面板

	  var bar = g.selectAll('.bar').data(this.data);
	  bar.exit().remove(); // 条

	  var group = bar.enter().append('g').attr('data-id', this.id).classed('bar', true).append('g');
	  group.append('text').attr('data-id', this.id).text(function (d) {
	    return d.text;
	  }).attr('x', 10).attr('y', function (d, i) {
	    return (i + 1) * 25;
	  }).attr('fill', '#4ccdfc');
	  group.append('rect').attr('data-id', this.id).attr('x', 68).attr('y', function (d, i) {
	    return (i + 1) * 25 - 10;
	  }).attr('width', 105).attr('height', 10).attr('fill', '#0c6887');
	  group.append('rect').attr('data-id', this.id).attr('x', 68).attr('y', function (d, i) {
	    return (i + 1) * 25 - 10;
	  }).attr('width', function (d) {
	    return d.value * 105;
	  }).attr('height', 10).attr('fill', '#4ccdfc');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	BarChart.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	BarChart.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	BarChart.prototype.clear = function () {
	  this.title = 'BarChart';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 时间标签
	 * @author tengge / https://github.com/tengge1
	 */

	function TimeLabel() {
	  BaseComponent.call(this);
	  this.type = 'TimeLabel';
	  this.text = '14:21';
	  this.transform = null;
	}

	TimeLabel.prototype = Object.create(BaseComponent.prototype);
	TimeLabel.prototype.constructor = TimeLabel;

	TimeLabel.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	TimeLabel.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var padding = 2;
	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('TimeLabel', true).style('pointer-events', 'all');
	  var text = g.append('text').attr('data-id', this.id).text(this.text).attr('fill', '#fff');
	  var box = text.node().getBBox();
	  var boxWidth = box.width + padding * 2;
	  var boxHeight = box.height + padding * 2;
	  text.attr('x', padding).attr('y', padding - box.y);

	  if (!this.transform) {
	    var left = (parent.clientWidth - boxWidth) / 2;
	    var top = (parent.clientHeight - boxHeight) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	TimeLabel.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    text: this.text,
	    transform
	  };
	};

	TimeLabel.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.text = json.text;
	  this.transform = json.transform || null;
	};

	TimeLabel.prototype.clear = function () {
	  this.text = '14:21';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 垂直线
	 * @author tengge / https://github.com/tengge1
	 */

	function VerticalLine() {
	  BaseComponent.call(this);
	  this.type = 'VerticalLine';
	  this.width = 0;
	  this.height = 20;
	  this.transform = null;
	}

	VerticalLine.prototype = Object.create(BaseComponent.prototype);
	VerticalLine.prototype.constructor = VerticalLine;

	VerticalLine.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	VerticalLine.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('VerticalLine', true).style('pointer-events', 'all'); // 可拖拽区域

	  g.append('path').attr('data-id', this.id).attr('d', 'M-4,-4L4,-4L4,24L-4,24Z').attr('stroke', '0').attr('fill', 'none');
	  g.append('line').attr('data-id', this.id).attr('x1', 0).attr('y1', 0).attr('x2', 0).attr('y2', 20).attr('stroke', '#4d88a7').attr('stroke-width', 2);

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	VerticalLine.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    width: this.width,
	    height: this.height,
	    transform
	  };
	};

	VerticalLine.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.width = json.width;
	  this.height = json.height;
	  this.transform = json.transform || null;
	};

	VerticalLine.prototype.clear = function () {
	  this.width = 0;
	  this.height = 20;
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 日期、周标签
	 * @author tengge / https://github.com/tengge1
	 */

	function DateWeekLabel() {
	  BaseComponent.call(this);
	  this.type = 'DateWeekLabel';
	  this.text = '14:21';
	  this.transform = null;
	}

	DateWeekLabel.prototype = Object.create(BaseComponent.prototype);
	DateWeekLabel.prototype.constructor = DateWeekLabel;

	DateWeekLabel.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	DateWeekLabel.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var padding = 2;
	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('DateWeekLabel', true).style('pointer-events', 'all'); // 星期

	  var week = g.append('text').attr('data-id', this.id).text('星期日').attr('x', padding).attr('y', padding).attr('font-size', 14).attr('fill', '#fff'); // 日期

	  var date = g.append('text').attr('data-id', this.id).text('2019-04-21').attr('x', padding).attr('y', padding).attr('font-size', 14).attr('fill', '#fff');
	  var weekBox = week.node().getBBox();
	  var dateBox = date.node().getBBox();
	  week.attr('y', padding - weekBox.y);
	  date.attr('y', weekBox.height + padding * 2 - dateBox.y);

	  if (!this.transform) {
	    var boxWidth = Math.max(weekBox.width, dateBox.width) + padding * 2;
	    var boxHeight = weekBox.height + dateBox.height + padding * 3;
	    var left = (parent.clientWidth - boxWidth) / 2;
	    var top = (parent.clientHeight - boxHeight) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	DateWeekLabel.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    text: this.text,
	    transform
	  };
	};

	DateWeekLabel.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.text = json.text;
	  this.transform = json.transform || null;
	};

	DateWeekLabel.prototype.clear = function () {
	  this.text = '14:21';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 时间圆盘
	 * @author tengge / https://github.com/tengge1
	 */

	function TimeDisk() {
	  BaseComponent.call(this);
	  this.type = 'TimeDisk';
	  this.width = 136;
	  this.height = 136;
	  this.title = 'Time';
	  this.transform = null;
	}

	TimeDisk.prototype = Object.create(BaseComponent.prototype);
	TimeDisk.prototype.constructor = TimeDisk;

	TimeDisk.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	TimeDisk.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('TimeDisk', true).style('pointer-events', 'all');
	  g.append('circle').attr('data-id', this.id).attr('cx', 0).attr('cy', 0).attr('r', 68).attr('fill', 'rgba(0,0,0,0.5)');
	  g.append('circle').attr('data-id', this.id).attr('cx', 0).attr('cy', 0).attr('r', 48).attr('stroke', '#517496').attr('stroke-width', 2).attr('fill', 'none');
	  g.append('circle').attr('data-id', this.id).attr('cx', 48).attr('cy', 0).attr('r', 14).attr('fill', '#376899');
	  g.append('circle').attr('data-id', this.id).attr('cx', 48).attr('cy', 0).attr('r', 14).attr('stroke', '#3399ff').attr('stroke-width', 2).attr('fill', 'none');
	  g.append('image').attr('data-id', this.id).attr('x', 0).attr('y', -48).attr('transform', 'translate(-12,-12)').attr('href', 'assets/svg/sunrise.svg');
	  g.append('image').attr('data-id', this.id).attr('x', 48).attr('y', 0).attr('transform', 'translate(-12,-12)').attr('href', 'assets/svg/sun.svg');
	  g.append('image').attr('data-id', this.id).attr('x', 0).attr('y', 48).attr('transform', 'translate(-12,-12)').attr('href', 'assets/svg/sunset.svg');
	  g.append('image').attr('data-id', this.id).attr('x', -48).attr('y', 0).attr('transform', 'translate(-12,-12)').attr('href', 'assets/svg/moon.svg');
	  g.append('text').attr('data-id', this.id).text(this.title).attr('x', 0).attr('y', 0).attr('dy', 10).attr('font-size', 20).attr('text-anchor', 'middle').attr('fill', '#fff');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	TimeDisk.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	TimeDisk.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	TimeDisk.prototype.clear = function () {
	  this.title = 'Time';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 键值标签
	 * @author tengge / https://github.com/tengge1
	 */

	function KeyValueLabel() {
	  BaseComponent.call(this);
	  this.type = 'KeyValueLabel';
	  this.width = 142;
	  this.height = 24;
	  this.key = '标签';
	  this.value = '值';
	  this.transform = null;
	}

	KeyValueLabel.prototype = Object.create(BaseComponent.prototype);
	KeyValueLabel.prototype.constructor = KeyValueLabel;

	KeyValueLabel.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	KeyValueLabel.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('TimeLabel', true).style('pointer-events', 'all');
	  g.append('path').attr('data-id', this.id).attr('d', 'M0,0 L135,0 L142,8 L142,24 L12,24 L0,17 Z').attr('fill', 'rgba(0,0,0,0.5)');
	  g.append('text').attr('data-id', this.id).text(this.key).attr('x', 18).attr('y', 17).attr('fill', '#fff').attr('font-size', 14);
	  g.append('text').attr('data-id', this.id).text(this.value).attr('x', 90).attr('y', 17).attr('fill', '#fff').attr('font-size', 14);

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	KeyValueLabel.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    key: this.key,
	    value: this.value,
	    transform
	  };
	};

	KeyValueLabel.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.key = json.key;
	  this.value = json.value;
	  this.transform = json.transform || null;
	};

	KeyValueLabel.prototype.clear = function () {
	  this.key = '键';
	  this.value = '值';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 表单面板
	 * @author tengge / https://github.com/tengge1
	 */

	function FormPanel() {
	  BaseComponent.call(this);
	  this.type = 'FormPanel';
	  this.width = 166;
	  this.height = 130;
	  this.data = [{
	    key: '键1',
	    value: '值1'
	  }, {
	    key: '键2',
	    value: '值2'
	  }, {
	    key: '键3',
	    value: '值3'
	  }, {
	    key: '键4',
	    value: '值4'
	  }];
	  this.transform = null;
	}

	FormPanel.prototype = Object.create(BaseComponent.prototype);
	FormPanel.prototype.constructor = FormPanel;

	FormPanel.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	FormPanel.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('FormPanel', true).style('pointer-events', 'all');
	  g.append('path').attr('data-id', this.id).attr('d', 'M5,0 L160,0 L166,6 L166,33 L158,38 L158,91 L166,96 L166,125 L158,130 L5,130 L0,125 L0,96 L5,91 L5,36 L0,33 L0,6 Z').attr('fill', 'rgba(0,0,0,0.5)');
	  var update = g.selectAll('.item').data(this.data);
	  update.exit().remove();
	  var item = update.enter().append('g').attr('data-id', this.id).classed('item', true);
	  item.append('text').attr('data-id', this.id).text(function (d) {
	    return d.key;
	  }).attr('x', 17).attr('y', function (d, i) {
	    return 26 + 26 * i;
	  }).attr('fill', '#fff').attr('font-size', 14);
	  item.append('text').attr('data-id', this.id).text(function (d) {
	    return d.value;
	  }).attr('x', 140).attr('y', function (d, i) {
	    return 26 + 26 * i;
	  }).attr('fill', '#fff').attr('font-size', 14).attr('text-anchor', 'end');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	FormPanel.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    data: this.data,
	    transform
	  };
	};

	FormPanel.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.data = json.data;
	  this.transform = json.transform || null;
	};

	FormPanel.prototype.clear = function () {
	  this.data = [];
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 键值标签
	 * @author tengge / https://github.com/tengge1
	 */

	function Gauge() {
	  BaseComponent.call(this);
	  this.type = 'Gauge';
	  this.width = 74;
	  this.height = 74;
	  this.label = '标签';
	  this.value = '值';
	  this.unit = '单位';
	  this.transform = null;
	}

	Gauge.prototype = Object.create(BaseComponent.prototype);
	Gauge.prototype.constructor = Gauge;

	Gauge.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	Gauge.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('Gauge', true).style('pointer-events', 'all'); // 背景

	  g.append('circle').attr('data-id', this.id).attr('cx', 18.5).attr('cy', 18.5).attr('r', 37).attr('fill', 'rgba(0,0,0,0.5)'); // 圆圈

	  g.append('circle').attr('data-id', this.id).attr('cx', 18.5).attr('cy', 18.5).attr('r', 32).attr('stroke', '#6da2ee').attr('stroke-width', 2).attr('fill', 'none'); // 值

	  g.append('text').attr('data-id', this.id).text(this.value).attr('x', 18.5).attr('y', 8.5).attr('font-size', 22).attr('text-anchor', 'middle').attr('fill', '#4bc8f5'); // 标签

	  g.append('text').attr('data-id', this.id).text(this.label).attr('x', 18.5).attr('y', 28.5).attr('font-size', 14).attr('text-anchor', 'middle').attr('fill', '#fff'); // 单位

	  g.append('text').attr('data-id', this.id).text(this.unit).attr('x', 18.5).attr('y', 44.5).attr('font-size', 14).attr('text-anchor', 'middle').attr('fill', '#fff');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	Gauge.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    key: this.key,
	    value: this.value,
	    transform
	  };
	};

	Gauge.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.key = json.key;
	  this.value = json.value;
	  this.transform = json.transform || null;
	};

	Gauge.prototype.clear = function () {
	  this.key = '键';
	  this.value = '值';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 柱状图
	 * @author tengge / https://github.com/tengge1
	 */

	function Histogram() {
	  BaseComponent.call(this);
	  this.type = 'Histogram';
	  this.width = 132.9;
	  this.height = 123.38;
	  this.title = 'Histogram';
	  this.data = [27, 68, 44, 117, 60, 83, 101];
	  this.transform = null;
	}

	Histogram.prototype = Object.create(BaseComponent.prototype);
	Histogram.prototype.constructor = Histogram;

	Histogram.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	Histogram.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('Histogram', true).style('pointer-events', 'all'); // 背景

	  g.append('path').attr('data-id', this.id).attr('d', 'M16.5,0 L16.5,123.38 L0,132.9 L0,8.5 Z').attr('fill', 'rgba(0,0,0,0.5)');
	  g.append('path').attr('data-id', this.id).attr('d', 'M23.5,0 L238,0 L238,124 L23.5,124 Z').attr('fill', 'rgba(0,0,0,0.5)');
	  g.append('path').attr('data-id', this.id).attr('d', 'M22,127 L238,127 L225,139 L0,139 Z').attr('fill', 'rgba(0,0,0,0.5)'); // 数据

	  g.selectAll('.column').data(this.data).enter().append('rect').attr('data-id', this.id).classed('column', true).attr('x', function (d, i) {
	    return 30 * (i + 1) - 5;
	  }).attr('y', function (d) {
	    return 133.6 - d;
	  }).attr('width', function (d) {
	    return 10;
	  }).attr('height', function (d) {
	    return d;
	  }).attr('fill', '#4ccdfc'); // 标题

	  g.append('path').attr('data-id', this.id).attr('d', 'M11,0 L72,0 L85,12 L72,24 L11,24 L0,12 Z').attr('fill', 'rgba(23,29,48,0.5)').attr('transform', 'translate(75,128)');
	  g.append('text').attr('data-id', this.id).text(this.title).attr('x', 0).attr('y', 0).attr('dy', 4).attr('font-size', 14).attr('text-anchor', 'middle').attr('fill', '#fff').attr('transform', 'translate(117,140)');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	Histogram.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    data: this.data,
	    transform
	  };
	};

	Histogram.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.data = json.data || null;
	  this.transform = json.transform || null;
	};

	Histogram.prototype.clear = function () {
	  this.title = 'Histogram';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 折线图
	 * @author tengge / https://github.com/tengge1
	 */

	function LineChart() {
	  BaseComponent.call(this);
	  this.type = 'LineChart';
	  this.width = 132.9;
	  this.height = 123.38;
	  this.title = 'LineChart';
	  var data1 = [];
	  var data2 = [];
	  var ran1 = d3.randomNormal(29, 8);
	  var ran2 = d3.randomNormal(72, 20);

	  for (var i = 0; i <= 210; i += 10) {
	    data1.push([8 + i, ran1()]);
	    data2.push([8 + i, ran2()]);
	  }

	  this.data = [data1, data2];
	  this.transform = null;
	}

	LineChart.prototype = Object.create(BaseComponent.prototype);
	LineChart.prototype.constructor = LineChart;

	LineChart.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	LineChart.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('LineChart', true).style('pointer-events', 'all'); // 背景

	  g.append('path').attr('data-id', this.id).attr('d', 'M16.5,0 L16.5,123.38 L0,132.9 L0,8.5 Z').attr('fill', 'rgba(0,0,0,0.5)');
	  g.append('path').attr('data-id', this.id).attr('d', 'M23.5,0 L238,0 L238,124 L23.5,124 Z').attr('fill', 'rgba(0,0,0,0.5)');
	  g.append('path').attr('data-id', this.id).attr('d', 'M22,127 L238,127 L225,139 L0,139 Z').attr('fill', 'rgba(0,0,0,0.5)'); // 数据

	  var line = d3.line();
	  var lineData1 = line(this.data[0]);
	  var lineData2 = line(this.data[1]);
	  g.append('path').attr('data-id', this.id).attr('d', lineData1 + 'L218,133.6L8,133.6Z').attr('stroke', '#458dab').attr('fill', 'rgba(76,205,252,0.2)');
	  g.append('path').attr('data-id', this.id).attr('d', lineData1).attr('stroke', '#458dab').attr('stroke-width', 2).attr('fill', 'none');
	  g.append('path').attr('data-id', this.id).attr('d', lineData2 + 'L218,133.6L8,133.6Z').attr('fill', 'rgba(182,152,132,0.2)').attr('stroke-width', 2);
	  g.append('path').attr('data-id', this.id).attr('d', lineData2).attr('stroke', '#b59784').attr('stroke-width', 2).attr('fill', 'none'); // 标签

	  var label = g.append('g').attr('transform', 'translate(117,135)');
	  label.append('path').attr('data-id', this.id).attr('d', 'M11,0 L72,0 L85,12 L72,24 L11,24 L0,12 Z').attr('fill', 'rgba(23,29,48,0.8)').attr('transform', 'translate(-42,-12)');
	  label.append('text').attr('data-id', this.id).text(this.title).attr('x', 0).attr('y', 0).attr('dy', 4).attr('font-size', 14).attr('text-anchor', 'middle').attr('fill', '#fff');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	LineChart.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    data: this.data,
	    transform
	  };
	};

	LineChart.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.data = json.data;
	  this.transform = json.transform || null;
	};

	LineChart.prototype.clear = function () {
	  this.title = 'LineChart';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 侧边栏
	 * @author tengge / https://github.com/tengge1
	 */

	function SideBar() {
	  BaseComponent.call(this);
	  this.type = 'SideBar';
	  this.width = 270;
	  this.height = 969;
	  this.title = 'SideBar';
	  this.transform = null;
	}

	SideBar.prototype = Object.create(BaseComponent.prototype);
	SideBar.prototype.constructor = SideBar;

	SideBar.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	SideBar.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('Panel', true).style('pointer-events', 'all'); // 背景

	  g.append('rect').attr('data-id', this.id).attr('x', 0).attr('y', 0).attr('width', 270).attr('height', 969).attr('fill', 'rgba(0,0,0,0.5)'); // 边框

	  g.append('path').attr('data-id', this.id).attr('d', 'm180,11 l0,35 l-10,10 L9,56 l0,183 l40,30 l0,193 M32,472 l0,18 l-23,20 l0,310').attr('stroke', '#3a6a84').attr('stroke-width', 2).attr('fill', 'none'); // 选项卡

	  var defs = d3.select('defs');
	  defs.append('path').attr('id', 'tabDef').attr('d', 'M0,0 L32,22 L32,60 L0,38 Z').attr('fill', '#6c6f6e');
	  defs.append('path').attr('id', 'tabSelectDef').attr('d', 'M0,0 L32,22 L32,60 L0,38 Z').attr('fill', '#356899');
	  var tab1 = g.append('g').attr('data-id', this.id).attr('transform', 'translate(14,58)');
	  tab1.append('use').attr('data-id', this.id).attr('href', '#tabSelectDef');
	  tab1.append('image').attr('data-id', this.id).attr('x', 5).attr('y', 20).attr('width', 24).attr('height', 24).attr('href', 'assets/svg/home.svg');
	  var tab2 = g.append('g').attr('data-id', this.id).attr('transform', 'translate(14,104)');
	  tab2.append('use').attr('data-id', this.id).attr('href', '#tabDef');
	  tab2.append('image').attr('data-id', this.id).attr('x', 5).attr('y', 20).attr('width', 24).attr('height', 24).attr('href', 'assets/svg/plane.svg');
	  var tab3 = g.append('g').attr('data-id', this.id).attr('transform', 'translate(14,150)');
	  tab3.append('use').attr('data-id', this.id).attr('href', '#tabDef');
	  tab3.append('image').attr('data-id', this.id).attr('x', 5).attr('y', 20).attr('width', 24).attr('height', 24).attr('href', 'assets/svg/water.svg');
	  var tab4 = g.append('g').attr('data-id', this.id).attr('transform', 'translate(14,196)');
	  tab4.append('use').attr('data-id', this.id).attr('href', '#tabDef');
	  tab4.append('image').attr('data-id', this.id).attr('x', 5).attr('y', 20).attr('width', 24).attr('height', 24).attr('href', 'assets/svg/guard.svg');
	  var header = g.append('g').attr('data-id', this.id).attr('transform', 'translate(15,276)');
	  header.append('path').attr('data-id', this.id).attr('d', 'M0,0 L12,0 L25,10 L25,185 L12,195 L0,195 Z').attr('fill', '#185185');
	  header.append('text').attr('data-id', this.id).text(this.title).attr('x', 12).attr('y', 85).attr('text-anchor', 'middle').attr('writing-mode', 'tb').attr('textlength', '90px').attr('lengthAdjust', 'spacing') // spacing, spacingAndGlyphs; see: https://blog.csdn.net/huanhuanq1209/article/details/71438629
	  .attr('fill', '#fff');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	SideBar.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	SideBar.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	SideBar.prototype.clear = function () {
	  this.title = 'SideBar';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 柱状图
	 * @author tengge / https://github.com/tengge1
	 */

	function Histogram2() {
	  BaseComponent.call(this);
	  this.type = 'Histogram2';
	  this.width = 132.9;
	  this.height = 123.38;
	  this.title = 'Histogram2';
	  this.data = [27, 68, 44, 117, 60, 83, 101];
	  this.transform = null;
	}

	Histogram2.prototype = Object.create(BaseComponent.prototype);
	Histogram2.prototype.constructor = Histogram2;

	Histogram2.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	Histogram2.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('Histogram2', true).style('pointer-events', 'all');
	  var dataset = [50, 43, 120, 87, 99, 167, 142];
	  var xAxisWidth = 300;
	  var yAxisWidth = 300;
	  var padding = {
	    top: 20,
	    right: 20,
	    bottom: 20,
	    left: 30
	  };
	  var xScale = d3.scaleBand().domain(d3.range(dataset.length)).range([0, xAxisWidth]);
	  var yScale = d3.scaleLinear().domain([0, d3.max(dataset)]).range([0, yAxisWidth]);
	  var rect = g.selectAll('rect').data(dataset).enter().append('rect').attr('data-id', this.id).attr('fill', 'steelblue').attr('x', function (d, i) {
	    return padding.left + xScale(i);
	  }).attr('y', function (d) {
	    return padding.top + yAxisWidth - yScale(d);
	  }).attr('width', xScale.bandwidth() - 2).attr('height', function (d) {
	    return yScale(d);
	  });
	  var text = g.selectAll('text').data(dataset).enter().append('text').attr('data-id', this.id).attr('fill', 'white').attr('font-size', '14px').attr('text-anchor', 'middle').attr('x', function (d, i) {
	    return padding.left + xScale(i);
	  }).attr('y', function (d) {
	    return padding.top + yAxisWidth - yScale(d);
	  }).attr('dx', xScale.bandwidth() / 2).attr('dy', '1em').text(function (d) {
	    return d;
	  });
	  var xAxis = d3.axisBottom().scale(xScale).tickFormat(function (d) {
	    return d + 1;
	  });
	  g.append('g').attr('transform', `translate(${padding.left}, ${padding.top + yAxisWidth})`).call(xAxis);
	  yScale.range([yAxisWidth, 0]);
	  var yAxis = d3.axisLeft().scale(yScale);
	  g.append('g').attr('transform', `translate(${padding.left},${padding.top})`).call(yAxis);

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	Histogram2.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    data: this.data,
	    transform
	  };
	};

	Histogram2.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.data = json.data;
	  this.transform = json.transform || null;
	};

	Histogram2.prototype.clear = function () {
	  this.title = 'Histogram2';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 散点图
	 * @author tengge / https://github.com/tengge1
	 */

	function ScatterPlot() {
	  BaseComponent.call(this);
	  this.type = 'ScatterPlot';
	  this.width = 400;
	  this.height = 400;
	  this.title = 'ScatterPlot';
	  var data1 = [];
	  var data2 = [];
	  var ran1 = d3.randomNormal(29, 8);
	  var ran2 = d3.randomNormal(72, 20);

	  for (var i = 0; i <= 210; i += 10) {
	    data1.push([8 + i, ran1()]);
	    data2.push([8 + i, ran2()]);
	  }

	  this.data = [data1, data2];
	  this.transform = null;
	}

	ScatterPlot.prototype = Object.create(BaseComponent.prototype);
	ScatterPlot.prototype.constructor = ScatterPlot;

	ScatterPlot.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	ScatterPlot.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('ScatterPlot', true).style('pointer-events', 'all');
	  var center = [[0.5, 0.5], [0.7, 0.8], [0.4, 0.9], [0.11, 0.32], [0.88, 0.25], [0.75, 0.12], [0.5, 0.1], [0.2, 0.3], [0.4, 0.1], [0.6, 0.7]];
	  var xAxisWidth = 400;
	  var yAxisWidth = 400;
	  var xScale = d3.scaleLinear().domain([0, 1.2 * d3.max(center, function (d) {
	    return d[0];
	  })]).range([0, xAxisWidth]);
	  var yScale = d3.scaleLinear().domain([0, 1.2 * d3.max(center, function (d) {
	    return d[1];
	  })]).range([0, yAxisWidth]);
	  var padding = {
	    top: 30,
	    right: 30,
	    bottom: 30,
	    left: 40
	  };
	  var height = yAxisWidth + padding.top + padding.bottom;
	  var circle = g.selectAll('circle').data(center).enter().append('circle').attr('data-id', this.id).attr('fill', 'black').attr('cx', function (d) {
	    return padding.left + xScale(d[0]);
	  }).attr('cy', function (d) {
	    return height - padding.bottom - yScale(d[1]);
	  }).attr('r', 5);
	  var xAxis = d3.axisBottom().scale(xScale);
	  g.append('g').attr('transform', `translate(${padding.left}, ${padding.top + yAxisWidth})`).call(xAxis);
	  yScale.range([yAxisWidth, 0]);
	  var yAxis = d3.axisLeft().scale(yScale);
	  g.append('g').attr('transform', `translate(${padding.left},${padding.top})`).call(yAxis);

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	ScatterPlot.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    data: this.data,
	    transform
	  };
	};

	ScatterPlot.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.data = json.data;
	  this.transform = json.transform || null;
	};

	ScatterPlot.prototype.clear = function () {
	  this.title = 'ScatterPlot';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 饼状图
	 * @author tengge / https://github.com/tengge1
	 */

	function PieChart() {
	  BaseComponent.call(this);
	  this.type = 'PieChart';
	  this.width = 500;
	  this.height = 500;
	  this.title = 'PieChart';
	  this.transform = null;
	}

	PieChart.prototype = Object.create(BaseComponent.prototype);
	PieChart.prototype.constructor = PieChart;

	PieChart.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	PieChart.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('ScatterPlot', true).style('pointer-events', 'all');
	  var dataset = [['小米', 60.8], ['三星', 58.4], ['联想', 47.3], ['苹果', 46.6], ['华为', 41.3], ['酷派', 40.1], ['其他', 111.5]];
	  var pie = d3.pie().value(function (d) {
	    return d[1];
	  });
	  var width = 500;
	  var height = 500;
	  var piedata = pie(dataset);
	  var outerRadius = width / 3;
	  var innerRadius = 0;
	  var arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);
	  var color = d3.schemeCategory10;
	  var arcs = g.selectAll('g').data(piedata).enter().append('g').attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');
	  arcs.append('path').attr('data-id', this.id).attr('fill', function (d, i) {
	    return color[i];
	  }).attr('d', function (d) {
	    return arc(d);
	  });
	  arcs.append('text').attr('data-id', this.id).attr('transform', function (d) {
	    var x = arc.centroid(d)[0] * 1.4;
	    var y = arc.centroid(d)[1] * 1.4;
	    return 'translate(' + x + ',' + y + ')';
	  }).attr('text-anchor', 'middle').text(function (d) {
	    var percent = Number(d.value) / d3.sum(dataset, function (d) {
	      return d[1];
	    }) * 100;
	    return percent.toFixed(1) + '%';
	  });
	  arcs.append('line').attr('data-id', this.id).attr('stroke', 'black').attr('x1', function (d) {
	    return arc.centroid(d)[0] * 2;
	  }).attr('y1', function (d) {
	    return arc.centroid(d)[1] * 2;
	  }).attr('x2', function (d) {
	    return arc.centroid(d)[0] * 2.2;
	  }).attr('y2', function (d) {
	    return arc.centroid(d)[1] * 2.2;
	  });
	  arcs.append('text').attr('data-id', this.id).attr('transform', function (d) {
	    var x = arc.centroid(d)[0] * 2.5;
	    var y = arc.centroid(d)[1] * 2.5;
	    return 'translate(' + x + ',' + y + ')';
	  }).attr('text-anchor', 'middle').text(function (d) {
	    return d.data[0];
	  });

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	PieChart.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	PieChart.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	PieChart.prototype.clear = function () {
	  this.title = 'PieChart';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 弦图
	 * @author tengge / https://github.com/tengge1
	 */

	function ChordGraph() {
	  BaseComponent.call(this);
	  this.type = 'ChordGraph';
	  this.width = 400;
	  this.height = 400;
	  this.title = 'ChordGraph';
	  var data1 = [];
	  var data2 = [];
	  var ran1 = d3.randomNormal(29, 8);
	  var ran2 = d3.randomNormal(72, 20);

	  for (var i = 0; i <= 210; i += 10) {
	    data1.push([8 + i, ran1()]);
	    data2.push([8 + i, ran2()]);
	  }

	  this.data = [data1, data2];
	  this.transform = null;
	}

	ChordGraph.prototype = Object.create(BaseComponent.prototype);
	ChordGraph.prototype.constructor = ChordGraph;

	ChordGraph.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	ChordGraph.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('ScatterPlot', true).style('pointer-events', 'all');
	  var continent = ['亚洲', '欧洲', '非洲', '美洲', '大洋洲'];
	  var population = [[9000, 870, 3000, 1000, 5200], [3400, 8000, 2300, 4922, 374], [2000, 2000, 7700, 4881, 1050], [3000, 8012, 5531, 500, 400], [3540, 4310, 1500, 1900, 300]];
	  var chord = d3.chord().padAngle(0.03).sortSubgroups(d3.ascending);
	  var chordData = chord(population);
	  var width = 500;
	  var height = 500; // 弦图的<g>元素

	  var gChord = g.append('g').attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')'); // 节点的<g>元素

	  var gOuter = gChord.append('g'); // 弦的<g>元素

	  var gInner = gChord.append('g'); // 颜色比例器

	  var color = d3.schemeCategory10;
	  var innerRadius = width / 2 * 0.7;
	  var outerRadius = innerRadius * 1.1; // 弦生成器

	  var arcOuter = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);
	  gOuter.selectAll('.outerPath').data(chordData.groups).enter().append('path').attr('data-id', this.id).attr('class', 'outerPath').style('fill', function (d, i) {
	    return color[i];
	  }).attr('d', arcOuter);
	  gOuter.selectAll('.outerText').data(chordData.groups).enter().append('text').attr('data-id', this.id).each(function (d, i) {
	    d.angle = (d.startAngle + d.endAngle) / 2;
	    d.name = continent[i];
	  }).attr('class', 'outerText').attr('dy', '.35em').attr('transform', function (d) {
	    var result = 'rotate(' + d.angle * 180 / Math.PI + ')';
	    result += ' translate(0,' + -1.0 * (outerRadius + 10) + ')';

	    if (d.angle > Math.PI * 3 / 4 && d.angle < Math.PI * 5 / 4) {
	      result += ' rotate(180)';
	    }

	    return result;
	  }).text(function (d) {
	    return d.name;
	  });
	  var ribbon = d3.ribbon().radius(innerRadius);
	  gInner.selectAll('.innerPath').data(chordData).enter().append('path').attr('data-id', this.id).attr('class', 'innerPath').attr('d', ribbon).style('fill', function (d) {
	    return color[d.source.index];
	  });
	  gOuter.selectAll('.outerPath').on('mouseover', fade(0.0)).on('mouseout', fade(1.0));

	  function fade(opacity) {
	    return function (g, i) {
	      gInner.selectAll('.innerPath').filter(function (d) {
	        return d.source.index != i && d.target.index != i;
	      }).transition().style('opacity', opacity);
	    };
	  }

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	ChordGraph.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    data: this.data,
	    transform
	  };
	};

	ChordGraph.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.data = json.data;
	  this.transform = json.transform || null;
	};

	ChordGraph.prototype.clear = function () {
	  this.title = 'ChordGraph';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 饼状图
	 * @author tengge / https://github.com/tengge1
	 */

	function ForceDirectedGraph() {
	  BaseComponent.call(this);
	  this.type = 'ForceDirectedGraph';
	  this.width = 500;
	  this.height = 500;
	  this.title = 'ForceDirectedGraph';
	  this.transform = null;
	}

	ForceDirectedGraph.prototype = Object.create(BaseComponent.prototype);
	ForceDirectedGraph.prototype.constructor = ForceDirectedGraph;

	ForceDirectedGraph.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	ForceDirectedGraph.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('ScatterPlot', true).style('pointer-events', 'all');
	  var dataset = {
	    nodes: [{
	      name: "Adam"
	    }, {
	      name: "Bob"
	    }, {
	      name: "Carrie"
	    }, {
	      name: "Donovan"
	    }, {
	      name: "Edward"
	    }, {
	      name: "Felicity"
	    }, {
	      name: "George"
	    }, {
	      name: "Hannah"
	    }, {
	      name: "Iris"
	    }, {
	      name: "Jerry"
	    }],
	    links: [{
	      source: 0,
	      target: 1
	    }, {
	      source: 0,
	      target: 2
	    }, {
	      source: 0,
	      target: 3
	    }, {
	      source: 0,
	      target: 4
	    }, {
	      source: 1,
	      target: 5
	    }, {
	      source: 2,
	      target: 5
	    }, {
	      source: 2,
	      target: 5
	    }, {
	      source: 3,
	      target: 4
	    }, {
	      source: 5,
	      target: 8
	    }, {
	      source: 5,
	      target: 9
	    }, {
	      source: 6,
	      target: 7
	    }, {
	      source: 7,
	      target: 8
	    }, {
	      source: 8,
	      target: 9
	    }]
	  };
	  var width = 500;
	  var height = 500;
	  var colors = d3.scaleOrdinal(d3.schemeCategory10);
	  var simulation = d3.forceSimulation(dataset.nodes).force('charge', d3.forceManyBody()).force('link', d3.forceLink(dataset.links)).force('center', d3.forceCenter(width / 2, height / 2));
	  var link = g.append('g').attr('class', 'links').selectAll('line').data(dataset.links).enter().append('line').attr('stroke', '#ccc').attr('stroke-width', 1);
	  var node = g.append('g').attr('class', 'nodes').selectAll('circle').data(dataset.nodes).enter().append('circle').attr('r', 10).attr('fill', function (d, i) {
	    return colors(i);
	  }).call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));
	  node.append('title').text(function (d) {
	    return d.name;
	  });
	  simulation.nodes(dataset.nodes).on('tick', ticked);
	  simulation.force('link').links(dataset.links);

	  function ticked() {
	    link.attr('x1', function (d) {
	      return d.source.x;
	    }).attr('y1', function (d) {
	      return d.source.y;
	    }).attr('x2', function (d) {
	      return d.target.x;
	    }).attr('y2', function (d) {
	      return d.target.y;
	    });
	    node.attr('cx', function (d) {
	      return d.x;
	    }).attr('cy', function (d) {
	      return d.y;
	    });
	  }

	  function dragstarted(d) {
	    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
	    d.fx = d.x;
	    d.fy = d.y;
	  }

	  function dragged(d) {
	    d.fx = d3.event.x;
	    d.fy = d3.event.y;
	  }

	  function dragended(d) {
	    if (!d3.event.active) simulation.alphaTarget(0);
	    d.fx = null;
	    d.fy = null;
	  }

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	ForceDirectedGraph.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	ForceDirectedGraph.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	ForceDirectedGraph.prototype.clear = function () {
	  this.title = 'ForceDirectedGraph';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 树状图
	 * @author tengge / https://github.com/tengge1
	 */

	function TreeDiagram() {
	  BaseComponent.call(this);
	  this.type = 'TreeDiagram';
	  this.width = 500;
	  this.height = 500;
	  this.title = 'TreeDiagram';
	  this.transform = null;
	}

	TreeDiagram.prototype = Object.create(BaseComponent.prototype);
	TreeDiagram.prototype.constructor = TreeDiagram;

	TreeDiagram.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	TreeDiagram.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('ScatterPlot', true).style('pointer-events', 'all');
	  var root = {
	    name: '中国',
	    children: [{
	      name: '浙江',
	      children: [{
	        name: '杭州'
	      }, {
	        name: '宁波'
	      }, {
	        name: '温州'
	      }, {
	        name: '绍兴'
	      }]
	    }, {
	      name: '广西',
	      children: [{
	        name: '桂林',
	        children: [{
	          name: '秀峰区'
	        }, {
	          name: '叠彩区'
	        }, {
	          name: '象山区'
	        }, {
	          name: '七星区'
	        }]
	      }, {
	        name: '南宁'
	      }, {
	        name: '柳州'
	      }, {
	        name: '防城港'
	      }]
	    }]
	  };
	  var width = 500;
	  var height = 500;
	  var tree = d3.tree().size([width, height - 200]).separation(function (a, b) {
	    return a.parent === b.parent ? 1 : 2;
	  });
	  var hierachyData = d3.hierarchy(root).sum(function (d) {
	    return d.value;
	  });
	  var g1 = g.append('g').attr('transform', 'translate(40, 40)');
	  tree(hierachyData);
	  var nodes = hierachyData.descendants();
	  var links = hierachyData.links();
	  g1.selectAll('.link').data(links).enter().append('path').attr('data-id', this.id).attr('class', 'link').attr('fill', 'none').attr('stroke', '#000').attr('d', function (d) {
	    return `M${d.source.y},${d.source.x} L${d.target.y},${d.target.x}`;
	  });
	  g1.selectAll('.node').data(nodes).enter().append('g').attr('class', 'node').attr('transform', function (d) {
	    // 这样写是为了 让数据横向显示
	    return `translate(${d.y}, ${d.x})`;
	  });
	  g1.selectAll('.node').append('circle').attr('data-id', this.id).attr('r', 5).attr('fill', 'green'); // 绘制文字

	  g1.selectAll('.node').append('text').attr('data-id', this.id).attr('dy', 3).attr('x', function (d) {
	    return d.children ? -8 : 8;
	  }).attr('text-anchor', function (d) {
	    return d.children ? 'end' : 'start';
	  }).text(function (d) {
	    return d.data.name;
	  }).style('font-size', '18px');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	TreeDiagram.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	TreeDiagram.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	TreeDiagram.prototype.clear = function () {
	  this.title = 'TreeDiagram';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 集群图
	 * @author tengge / https://github.com/tengge1
	 */

	function ClusterDiagram() {
	  BaseComponent.call(this);
	  this.type = 'ClusterDiagram';
	  this.width = 500;
	  this.height = 500;
	  this.title = 'ClusterDiagram';
	  this.transform = null;
	}

	ClusterDiagram.prototype = Object.create(BaseComponent.prototype);
	ClusterDiagram.prototype.constructor = ClusterDiagram;

	ClusterDiagram.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	ClusterDiagram.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('ScatterPlot', true).style('pointer-events', 'all');
	  var root = {
	    name: '中国',
	    children: [{
	      name: '浙江',
	      children: [{
	        name: '杭州'
	      }, {
	        name: '宁波'
	      }, {
	        name: '温州'
	      }, {
	        name: '绍兴'
	      }]
	    }, {
	      name: '广西',
	      children: [{
	        name: '桂林',
	        children: [{
	          name: '秀峰区'
	        }, {
	          name: '叠彩区'
	        }, {
	          name: '象山区'
	        }, {
	          name: '七星区'
	        }]
	      }, {
	        name: '南宁'
	      }, {
	        name: '柳州'
	      }, {
	        name: '防城港'
	      }]
	    }]
	  };
	  var width = 500;
	  var height = 500;
	  var tree = d3.cluster().size([width, height - 200]).separation(function (a, b) {
	    return a.parent === b.parent ? 1 : 2;
	  });
	  var hierachyData = d3.hierarchy(root).sum(function (d) {
	    return d.value;
	  });
	  var g1 = g.append('g').attr('transform', 'translate(40, 40)');
	  tree(hierachyData);
	  var nodes = hierachyData.descendants();
	  var links = hierachyData.links();
	  g1.selectAll('.link').data(links).enter().append('path').attr('data-id', this.id).attr('class', 'link').attr('fill', 'none').attr('stroke', '#000').attr('d', function (d) {
	    return `M${d.source.y},${d.source.x} L${d.target.y},${d.target.x}`;
	  });
	  g1.selectAll('.node').data(nodes).enter().append('g').attr('class', 'node').attr('transform', function (d) {
	    // 这样写是为了 让数据横向显示
	    return `translate(${d.y}, ${d.x})`;
	  });
	  g1.selectAll('.node').append('circle').attr('data-id', this.id).attr('r', 5).attr('fill', 'green'); // 绘制文字

	  g1.selectAll('.node').append('text').attr('data-id', this.id).attr('dy', 3).attr('x', function (d) {
	    return d.children ? -8 : 8;
	  }).attr('text-anchor', function (d) {
	    return d.children ? 'end' : 'start';
	  }).text(function (d) {
	    return d.data.name;
	  }).style('font-size', '18px');

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	ClusterDiagram.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	ClusterDiagram.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.transform = json.transform || null;
	};

	ClusterDiagram.prototype.clear = function () {
	  this.title = 'ClusterDiagram';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 包图
	 * @author tengge / https://github.com/tengge1
	 */

	function PackDiagram() {
	  BaseComponent.call(this);
	  this.type = 'PackDiagram';
	  this.width = 500;
	  this.height = 500;
	  this.title = 'PackDiagram';
	  this.transform = null;
	}

	PackDiagram.prototype = Object.create(BaseComponent.prototype);
	PackDiagram.prototype.constructor = PackDiagram;

	PackDiagram.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	PackDiagram.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('PackDiagram', true).style('pointer-events', 'all');
	  var city = {
	    name: '中国',
	    children: [{
	      name: '浙江',
	      children: [{
	        name: '杭州'
	      }, {
	        name: '宁波'
	      }, {
	        name: '温州'
	      }, {
	        name: '绍兴'
	      }]
	    }, {
	      name: '广西',
	      children: [{
	        name: '桂林',
	        children: [{
	          name: '秀峰区'
	        }, {
	          name: '叠彩区'
	        }, {
	          name: '象山区'
	        }, {
	          name: '七星区'
	        }]
	      }, {
	        name: '南宁'
	      }, {
	        name: '柳州'
	      }, {
	        name: '防城港'
	      }]
	    }]
	  };
	  var width = 500;
	  var height = 500;
	  var pack = d3.pack().size([width, height]).radius(function (d) {
	    return 30;
	  }).padding(5);
	  var hierachy = d3.hierarchy(city);
	  var packData = pack(hierachy);
	  var colors = d3.schemeCategory10;
	  g.selectAll('circle').data(packData.descendants()).enter().append('circle').attr('data-id', this.id).attr('cx', function (d) {
	    return d.x;
	  }).attr('cy', function (d) {
	    return d.y;
	  }).attr('r', function (d) {
	    return d.r;
	  }).attr('class', function (d) {
	    return d.children ? 'node' : 'leafnode';
	  }).attr('fill', function (d, i) {
	    return colors[i];
	  });

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	PackDiagram.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	PackDiagram.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.data = json.data;
	  this.transform = json.transform || null;
	};

	PackDiagram.prototype.clear = function () {
	  this.title = 'PackDiagram';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 分区图
	 * @author tengge / https://github.com/tengge1
	 */

	function PartitionDiagram() {
	  BaseComponent.call(this);
	  this.type = 'PartitionDiagram';
	  this.width = 800;
	  this.height = 500;
	  this.title = 'PartitionDiagram';
	  this.transform = null;
	}

	PartitionDiagram.prototype = Object.create(BaseComponent.prototype);
	PartitionDiagram.prototype.constructor = PartitionDiagram;

	PartitionDiagram.prototype.setTranslate = function (dx, dy) {
	  var xy = this.transform.split(',');
	  this.transform = `${parseFloat(xy[0]) + dx},${parseFloat(xy[1]) + dy}`;
	  this.dom.attr('transform', `translate(${this.transform})`);
	};

	PartitionDiagram.prototype.render = function (parent) {
	  if (d3.select(`#${this.id}`).size() > 0) {
	    return;
	  }

	  var g = d3.select(parent).append('g').attr('id', this.id).classed('Visual', true).classed('PartitionDiagram', true).style('pointer-events', 'all');
	  var city = {
	    name: '中国',
	    value: 1,
	    children: [{
	      name: '浙江',
	      value: 1,
	      children: [{
	        name: '杭州',
	        value: 1
	      }, {
	        name: '宁波',
	        value: 1
	      }, {
	        name: '温州',
	        value: 1
	      }, {
	        name: '绍兴',
	        value: 1
	      }]
	    }, {
	      name: '广西',
	      value: 1,
	      children: [{
	        name: '桂林',
	        value: 1,
	        children: [{
	          name: '秀峰区',
	          value: 1
	        }, {
	          name: '叠彩区',
	          value: 1
	        }, {
	          name: '象山区',
	          value: 1
	        }, {
	          name: '七星区',
	          value: 1
	        }]
	      }, {
	        name: '南宁',
	        value: 1
	      }, {
	        name: '柳州',
	        value: 1
	      }, {
	        name: '防城港',
	        value: 1
	      }]
	    }]
	  };
	  var hierarchy = d3.hierarchy(city);
	  var partition = d3.partition();
	  var partitionData = partition(hierarchy).descendants();
	  var colors = d3.schemeCategory10;
	  g.selectAll('rect').data(partitionData).enter().append('rect').attr('data-id', this.id).attr('x', function (d) {
	    return d.x0 * 100;
	  }).attr('y', function (d) {
	    return d.y0 * 100;
	  }).attr('width', function (d) {
	    return d.x1 * 100 - d.x0 * 100;
	  }).attr('height', function (d) {
	    return d.y1 * 100 - d.y0 * 100;
	  }).attr('fill', function (d, i) {
	    return colors[i % 10];
	  });

	  if (!this.transform) {
	    var left = (parent.clientWidth - this.width) / 2;
	    var top = (parent.clientHeight - this.height) / 2;
	    this.transform = `${left},${top}`;
	  }

	  g.attr('transform', `translate(${this.transform})`);
	  this.dom = g;
	};

	PartitionDiagram.prototype.toJSON = function () {
	  var transform;

	  if (this.transform) {
	    transform = this.transform.replace('translate(', '').replace(')', '');
	  }

	  return {
	    id: this.id,
	    type: this.type,
	    title: this.title,
	    transform
	  };
	};

	PartitionDiagram.prototype.fromJSON = function (json) {
	  this.id = json.id;
	  this.type = json.type;
	  this.title = json.title;
	  this.data = json.data;
	  this.transform = json.transform || null;
	};

	PartitionDiagram.prototype.clear = function () {
	  this.title = 'PartitionDiagram';
	  this.transform = null;
	  delete this.dom;
	};

	/**
	 * 2D菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class TwoDMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleAddButton = this.handleAddButton.bind(this);
	    this.handleAddLabel = this.handleAddLabel.bind(this);
	    this.handleAddPanel = this.handleAddPanel.bind(this);
	    this.handleAddHorizontalLine = this.handleAddHorizontalLine.bind(this);
	    this.handleAddBarChart = this.handleAddBarChart.bind(this);
	    this.handleAddTimeLabel = this.handleAddTimeLabel.bind(this);
	    this.handleAddVerticalLine = this.handleAddVerticalLine.bind(this);
	    this.handleAddDateWeek = this.handleAddDateWeek.bind(this);
	    this.handleAddTimeDisk = this.handleAddTimeDisk.bind(this);
	    this.handleAddKeyValueLabel = this.handleAddKeyValueLabel.bind(this);
	    this.handleAddFormPanel = this.handleAddFormPanel.bind(this);
	    this.handleAddGauge = this.handleAddGauge.bind(this);
	    this.handleAddHistogram = this.handleAddHistogram.bind(this);
	    this.handleAddLineChart = this.handleAddLineChart.bind(this);
	    this.handleAddSideBar = this.handleAddSideBar.bind(this);
	    this.handleAddHistogram2 = this.handleAddHistogram2.bind(this);
	    this.handleAddScatterPlot = this.handleAddScatterPlot.bind(this);
	    this.handleAddPieChart = this.handleAddPieChart.bind(this);
	    this.handleAddChordGraph = this.handleAddChordGraph.bind(this);
	    this.handleAddForceDirectedGraph = this.handleAddForceDirectedGraph.bind(this);
	    this.handleAddTreeDiagram = this.handleAddTreeDiagram.bind(this);
	    this.handleAddClusterDiagram = this.handleAddClusterDiagram.bind(this);
	    this.handleAddPackDiagram = this.handleAddPackDiagram.bind(this);
	    this.handleAddPartitionDiagram = this.handleAddPartitionDiagram.bind(this);
	  }

	  render() {
	    return React.createElement(MenuItem, {
	      title: _t('2D'),
	      show: app.debug === true
	    }, React.createElement(MenuItem, {
	      title: _t('Button'),
	      onClick: this.handleAddButton
	    }), React.createElement(MenuItem, {
	      title: _t('Label'),
	      onClick: this.handleAddLabel
	    }), React.createElement(MenuItem, {
	      title: _t('Panel'),
	      onClick: this.handleAddPanel
	    }), React.createElement(MenuItem, {
	      title: _t('Horizontal Line'),
	      onClick: this.handleAddHorizontalLine
	    }), React.createElement(MenuItem, {
	      title: _t('Bar Chart'),
	      onClick: this.handleAddBarChart
	    }), React.createElement(MenuItem, {
	      title: _t('Time'),
	      onClick: this.handleAddTimeLabel
	    }), React.createElement(MenuItem, {
	      title: _t('Vertical Line'),
	      onClick: this.handleAddVerticalLine
	    }), React.createElement(MenuItem, {
	      title: _t('Date'),
	      onClick: this.handleAddDateWeek
	    }), React.createElement(MenuItem, {
	      title: _t('Time Disk'),
	      onClick: this.handleAddTimeDisk
	    }), React.createElement(MenuItem, {
	      title: _t('Key Value Label'),
	      onClick: this.handleAddKeyValueLabel
	    }), React.createElement(MenuItem, {
	      title: _t('Form Panel'),
	      onClick: this.handleAddFormPanel
	    }), React.createElement(MenuItem, {
	      title: _t('Gauge'),
	      onClick: this.handleAddGauge
	    }), React.createElement(MenuItem, {
	      title: _t('Histogram'),
	      onClick: this.handleAddHistogram
	    }), React.createElement(MenuItem, {
	      title: _t('Line Chart'),
	      onClick: this.handleAddLineChart
	    }), React.createElement(MenuItem, {
	      title: _t('Sidebar'),
	      onClick: this.handleAddSideBar
	    }), React.createElement(MenuItem, {
	      title: `${_t('Histogram')}2`,
	      onClick: this.handleAddHistogram2
	    }), React.createElement(MenuItem, {
	      title: _t('Scatter Plot'),
	      onClick: this.handleAddScatterPlot
	    }), React.createElement(MenuItem, {
	      title: _t('Pie Chart'),
	      onClick: this.handleAddPieChart
	    }), React.createElement(MenuItem, {
	      title: _t('Chord Graph'),
	      onClick: this.handleAddChordGraph
	    }), React.createElement(MenuItem, {
	      title: _t('Force Directed Graph'),
	      onClick: this.handleAddForceDirectedGraph
	    }), React.createElement(MenuItem, {
	      title: _t('Tree Diagram'),
	      onClick: this.handleAddTreeDiagram
	    }), React.createElement(MenuItem, {
	      title: _t('Cluster Diagram'),
	      onClick: this.handleAddClusterDiagram
	    }), React.createElement(MenuItem, {
	      title: _t('Pack Diagram'),
	      onClick: this.handleAddPackDiagram
	    }), React.createElement(MenuItem, {
	      title: _t('Partition Diagram'),
	      onClick: this.handleAddPartitionDiagram
	    }));
	  } // ------------------------------ 按钮 --------------------------------


	  handleAddButton() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new Button$1());
	    visual.render(svg);
	  } // ---------------------------- 标签 -----------------------------------


	  handleAddLabel() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new Label$1());
	    visual.render(svg);
	  } // ---------------------------- 面板 ------------------------------------


	  handleAddPanel() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new Panel$1());
	    visual.render(svg);
	  } // --------------------------- 水平线 -------------------------------------


	  handleAddHorizontalLine() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new HorizontalLine());
	    visual.render(svg);
	  } // ---------------------------- 条形图 -------------------------------------


	  handleAddBarChart() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new BarChart());
	    visual.render(svg);
	  } // --------------------------- 时间标签 --------------------------------------


	  handleAddTimeLabel() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new TimeLabel());
	    visual.render(svg);
	  } // --------------------------- 垂直线 ------------------------------------------


	  handleAddVerticalLine() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new VerticalLine());
	    visual.render(svg);
	  } // -------------------------- 日期时间 -------------------------------------------


	  handleAddDateWeek() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new DateWeekLabel());
	    visual.render(svg);
	  } // ------------------------- 时间圆盘 -----------------------------------------------


	  handleAddTimeDisk() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new TimeDisk());
	    visual.render(svg);
	  } // -------------------------- 键值标签 -------------------------------------------------


	  handleAddKeyValueLabel() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new KeyValueLabel());
	    visual.render(svg);
	  } // --------------------------- 表单 ------------------------------------------------------


	  handleAddFormPanel() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new FormPanel());
	    visual.render(svg);
	  } // ---------------------------- 仪表 --------------------------------------------


	  handleAddGauge() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new Gauge());
	    visual.render(svg);
	  } // --------------------------- 柱状图 ----------------------------------------------


	  handleAddHistogram() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new Histogram());
	    visual.render(svg);
	  } // ------------------------------- 折线图 ----------------------------------------------


	  handleAddLineChart() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new LineChart());
	    visual.render(svg);
	  } // -------------------------------- 侧边栏 ---------------------------------------------


	  handleAddSideBar() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new SideBar());
	    visual.render(svg);
	  } // ------------------------------- 柱状图2 ------------------------------------------------


	  handleAddHistogram2() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new Histogram2());
	    visual.render(svg);
	  }

	  // -------------------------------- 散点图 ---------------------------------------------------
	  handleAddScatterPlot() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new ScatterPlot());
	    visual.render(svg);
	  } // --------------------------------- 饼状图 --------------------------------------------------


	  handleAddPieChart() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new PieChart());
	    visual.render(svg);
	  } // --------------------------------- 弦图 --------------------------------------------------


	  handleAddChordGraph() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new ChordGraph());
	    visual.render(svg);
	  }

	  // ----------------------------------- 力导向图 ---------------------------------------------
	  handleAddForceDirectedGraph() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new ForceDirectedGraph());
	    visual.render(svg);
	  } // ----------------------------------- 树状图 -----------------------------------------------


	  handleAddTreeDiagram() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new TreeDiagram());
	    visual.render(svg);
	  } // ---------------------------------- 集群图 -----------------------------------------------------


	  handleAddClusterDiagram() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new ClusterDiagram());
	    visual.render(svg);
	  } // ------------------------------- 包图 -----------------------------------------


	  handleAddPackDiagram() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new PackDiagram());
	    visual.render(svg);
	  } // --------------------------------- 分区图 --------------------------------------------


	  handleAddPartitionDiagram() {
	    var visual = app.editor.visual;
	    var svg = app.editor.svg;
	    visual.add(new PartitionDiagram());
	    visual.render(svg);
	  }

	}

	/**
	 * 组
	 */
	function Group() {
	  THREE.Group.call(this);
	  this.name = _t('Group');
	}

	Group.prototype = Object.create(THREE.Group.prototype);
	Group.prototype.constructor = Group;

	/**
	 * 平面
	 * @param {*} geometry 几何体
	 * @param {*} material 材质
	 */
	function Plane(geometry = new THREE.PlaneBufferGeometry(50, 50), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Plane');
	  this.rotation.x = -Math.PI / 2;
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: false,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 0,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Plane.prototype = Object.create(THREE.Mesh.prototype);
	Plane.prototype.constructor = Plane;

	/**
	 * 正方体
	 * @param {*} geometry 几何体
	 * @param {*} material 材质
	 */
	function Box(geometry = new THREE.BoxBufferGeometry(1, 1, 1), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Box');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: false,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 1,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Box.prototype = Object.create(THREE.Mesh.prototype);
	Box.prototype.constructor = Box;

	/**
	 * 圆
	 * @param {*} geometry 几何体
	 * @param {*} material 材质
	 */
	function Circle(geometry = new THREE.CircleBufferGeometry(1, 32), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Circle');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: false,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 1.0,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Circle.prototype = Object.create(THREE.Mesh.prototype);
	Circle.prototype.constructor = Circle;

	/**
	 * 圆柱体
	 * @param {*} geometry 几何体
	 * @param {*} material 材质
	 */
	function Cylinder(geometry = new THREE.CylinderBufferGeometry(1, 1, 2, 32, 1, false), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Cylinder');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: false,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 1,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Cylinder.prototype = Object.create(THREE.Mesh.prototype);
	Cylinder.prototype.constructor = Cylinder;

	/**
	 * 球体
	 * @param {*} geometry 几何体
	 * @param {*} material 材质
	 */
	function Sphere(geometry = new THREE.SphereBufferGeometry(1, 32, 16, 0, Math.PI * 2, 0, Math.PI), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Sphere');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: false,
	    type: 'rigidBody',
	    shape: 'btSphereShape',
	    mass: 0,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Sphere.prototype = Object.create(THREE.Mesh.prototype);
	Sphere.prototype.constructor = Sphere;

	/**
	 * 二十面体
	 * @param {*} geometry 几何体
	 * @param {*} material 材质
	 */
	function Icosahedron(geometry = new THREE.IcosahedronBufferGeometry(1, 2), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Icosahedron');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: false,
	    type: 'rigidBody',
	    shape: 'btSphereShape',
	    mass: 1,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Icosahedron.prototype = Object.create(THREE.Mesh.prototype);
	Icosahedron.prototype.constructor = Icosahedron;

	/**
	 * 轮胎
	 * @param {*} geometry 几何体
	 * @param {*} material 材质
	 */
	function Torus(geometry = new THREE.TorusBufferGeometry(2, 1, 32, 32, Math.PI * 2), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Torus');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: false,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 1,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Torus.prototype = Object.create(THREE.Mesh.prototype);
	Torus.prototype.constructor = Torus;

	/**
	 * 纽结
	 * @param {*} geometry 几何体
	 * @param {*} material 材质
	 */
	function TorusKnot(geometry = new THREE.TorusKnotBufferGeometry(2, 0.8, 64, 12, 2, 3), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Torus Knot');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: false,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 1,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	TorusKnot.prototype = Object.create(THREE.Mesh.prototype);
	TorusKnot.prototype.constructor = TorusKnot;

	/**
	 * 茶壶
	 * @param {*} geometry 几何体
	 * @param {*} material 材质
	 */
	function Teapot(geometry = new THREE.TeapotBufferGeometry(3, 10, true, true, true, true, true), material = new THREE.MeshStandardMaterial()) {
	  THREE.Mesh.call(this, geometry, material); // 修改TeapotBufferGeometry类型错误问题，原来是BufferGeometry

	  geometry.type = 'TeapotBufferGeometry'; // 修复TeapotBufferGeometry缺少parameters参数问题

	  geometry.parameters = {
	    size: 3,
	    segments: 10,
	    bottom: true,
	    lid: true,
	    body: true,
	    fitLid: true,
	    blinn: true
	  };
	  this.name = _t('Teapot');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: false,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 1,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Teapot.prototype = Object.create(THREE.Mesh.prototype);
	Teapot.prototype.constructor = Teapot;

	var points = [new THREE.Vector2(0, 0), new THREE.Vector2(4, 0), new THREE.Vector2(3.5, 0.5), new THREE.Vector2(1, 0.75), new THREE.Vector2(0.8, 1), new THREE.Vector2(0.8, 4), new THREE.Vector2(1, 4.2), new THREE.Vector2(1.4, 4.8), new THREE.Vector2(2, 5), new THREE.Vector2(2.5, 5.4), new THREE.Vector2(3, 12)];
	/**
	 * 酒杯
	 * @param {*} geometry 几何体
	 * @param {*} material 材质
	 */

	function Lathe(geometry = new THREE.LatheBufferGeometry(points, 20, 0, 2 * Math.PI), material = new THREE.MeshStandardMaterial({
	  side: THREE.DoubleSide
	})) {
	  THREE.Mesh.call(this, geometry, material);
	  this.name = _t('Lathe');
	  this.castShadow = true;
	  this.receiveShadow = true;
	  this.userData.physics = this.userData.physics || {
	    enabled: false,
	    type: 'rigidBody',
	    shape: 'btBoxShape',
	    mass: 1,
	    inertia: {
	      x: 0,
	      y: 0,
	      z: 0
	    }
	  };
	}

	Lathe.prototype = Object.create(THREE.Mesh.prototype);
	Lathe.prototype.constructor = Lathe;

	/**
	 * 精灵
	 * @param {*} material 材质
	 */
	function Sprite(material = new THREE.SpriteMaterial()) {
	  THREE.Sprite.call(this, material);
	  this.name = _t('Sprite');
	}

	Sprite.prototype = Object.create(THREE.Sprite.prototype);
	Sprite.prototype.constructor = Sprite;

	var link = document.createElement('a');
	link.style.display = 'none';
	document.body.appendChild(link); // Firefox workaround, see #6594

	/**
	 * 将数字凑成2的指数次幂
	 * @author mrdoob / http://mrdoob.com/
	 * @author tengge / https://github.com/tengge1
	 * @param {*} num 数字
	 */

	function makePowOfTwo(num) {
	  var result = 1;

	  while (result < num) {
	    result = result * 2;
	  }

	  return result;
	}

	function save(blob, filename) {
	  link.href = URL.createObjectURL(blob);
	  link.download = filename || 'data.json';
	  link.click(); // URL.revokeObjectURL( url ); breaks Firefox...
	}
	/**
	 * 下载字符串文件
	 * @param {*} text 
	 * @param {*} filename 
	 */


	function saveString(text, filename) {
	  save(new Blob([text], {
	    type: 'text/plain'
	  }), filename);
	}

	const StringUtils = {
	  makePowOfTwo: makePowOfTwo,
	  save: save,
	  saveString: saveString
	};

	/**
	 * 文本
	 * @param {*} text 文字
	 */

	function Text(text = L_TEXT) {
	  var canvas = document.createElement('canvas');
	  var fontSize = 64;
	  var ctx = canvas.getContext('2d');
	  ctx.font = `${fontSize}px 'Microsoft YaHei'`;
	  var textMetrics = ctx.measureText(text);
	  canvas.width = textMetrics.width;
	  canvas.height = fontSize;
	  ctx.textBaseline = 'hanging';
	  ctx.font = `${fontSize}px 'Microsoft YaHei'`; // 重新设置画布大小，前面设置的ctx属性全部失效

	  ctx.fillStyle = 'rgba(0,0,0,0)';
	  ctx.fillRect(0, 0, canvas.width, canvas.height);
	  ctx.fillStyle = 'rgba(255,255,255,1)';
	  ctx.fillText(text, (canvas.width - textMetrics.width) / 2, 0);
	  var map = new THREE.CanvasTexture(canvas);
	  map.minFilter = THREE.LinearFilter;
	  var geometry = new THREE.PlaneBufferGeometry(canvas.width / 10, canvas.height / 10);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xffffff,
	    map: map,
	    transparent: true
	  });
	  THREE.Mesh.call(this, geometry, material);
	  this.name = text;
	}

	Text.prototype = Object.create(THREE.Mesh.prototype);
	Text.prototype.constructor = Text;

	Text.prototype.updateText = function (text) {
	  this.name = text;
	  var canvas = this.material.map.image;
	  var fontSize = 64;
	  var ctx = canvas.getContext('2d');
	  ctx.font = `${fontSize}px 'Microsoft YaHei'`;
	  var textMetrics = ctx.measureText(text);
	  canvas.width = textMetrics.width;
	  canvas.height = fontSize;
	  ctx.textBaseline = 'hanging';
	  ctx.font = `${fontSize}px 'Microsoft YaHei'`; // 重新设置画布大小，前面设置的ctx属性全部失效

	  ctx.fillStyle = 'rgba(0,0,0,0)';
	  ctx.fillRect(0, 0, canvas.width, canvas.height);
	  ctx.fillStyle = 'rgba(255,255,255,1)';
	  ctx.fillText(text, (canvas.width - textMetrics.width) / 2, 0);
	  this.material.map.needsUpdate = true;
	};

	var ID$9 = -1;
	/**
	 * 帮助器基类
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function BaseHelper(app) {
	  this.id = `${this.constructor.name}${ID$9--}`;
	}
	/**
	 * 帮助器开始运行
	 * @description 因为start是在`appStarted`事件中运行的，所以无法监听到`appStart`和`appStarted`事件
	 */


	BaseHelper.prototype.start = function () {};
	/**
	 * 帮助器结束运行
	 */


	BaseHelper.prototype.stop = function () {};

	/**
	 * 曲线帮助器基类
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function SplineHelper(app) {
	  BaseHelper.call(this, app);
	  this.box = [];
	}

	SplineHelper.prototype = Object.create(BaseHelper.prototype);
	SplineHelper.prototype.constructor = SplineHelper;

	SplineHelper.prototype.start = function () {
	  app.on(`objectSelected.${this.id}`, this.onObjectSelected.bind(this));
	  app.on(`objectChanged.${this.id}`, this.onObjectChanged.bind(this));
	};

	SplineHelper.prototype.stop = function () {
	  app.on(`objectSelected.${this.id}`, null);
	  app.on(`objectChanged.${this.id}`, null);
	};

	SplineHelper.prototype.onObjectSelected = function (object) {
	  if (object === null) {
	    this.onCancelSelectLine();
	  } else if (object.userData && (object.userData.type === 'LineCurve' || object.userData.type === 'CatmullRomCurve' || object.userData.type === 'QuadraticBezierCurve' || object.userData.type === 'CubicBezierCurve')) {
	    this.onSelectLine(object);
	  }
	};

	SplineHelper.prototype.onObjectChanged = function (obj) {
	  if (this.box.length === 0) {
	    return;
	  }

	  var scene = app.editor.sceneHelpers;
	  var line = this.box[0].userData.object;

	  if (obj === line) {
	    // 修改了线
	    line.userData.points.forEach((n, i) => {
	      if (this.box[i]) {
	        this.box[i].position.copy(line.position).add(n);
	      } else {
	        var mesh = new THREE.Mesh(this.box[0].geometry, this.box[0].material);
	        mesh.position.copy(line.position).add(n);
	        Object.assign(mesh.userData, {
	          type: 'helper',
	          object: line
	        });
	        scene.add(mesh);
	        this.box.push(mesh);
	      }
	    });

	    if (this.box.length > line.userData.points.length) {
	      this.box.splice(line.userData.points.length, this.box.length - line.userData.points.length).forEach(n => {
	        delete n.object;
	        scene.remove(n);
	      });
	    }
	  } else if (obj.userData && obj.userData.type === 'helper') {
	    // 修改了帮助器
	    var object = obj.userData.object;
	    var index = this.box.indexOf(obj);

	    if (index > -1) {
	      object.userData.points[index].copy(object.position).multiplyScalar(-1).add(obj.position);
	      object.update();
	    }
	  }
	};

	SplineHelper.prototype.onSelectLine = function (object) {
	  var scene = app.editor.sceneHelpers;
	  this.onCancelSelectLine();
	  var geometry = new THREE.BoxBufferGeometry(0.4, 0.4, 0.4);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xff0000
	  });
	  object.userData.points.forEach(n => {
	    var mesh = new THREE.Mesh(geometry, material);
	    mesh.position.copy(object.position).add(n);
	    Object.assign(mesh.userData, {
	      type: 'helper',
	      object: object
	    });
	    scene.add(mesh);
	    this.box.push(mesh);
	  });
	};

	SplineHelper.prototype.onCancelSelectLine = function () {
	  var scene = app.editor.sceneHelpers;
	  this.box.forEach(n => {
	    scene.remove(n);
	    delete n.userData.object;
	  });
	  this.box.length = 0;
	};

	/**
	 * 几何体菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class GeometryMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleAddGroup = this.handleAddGroup.bind(this);
	    this.handleAddPlane = this.handleAddPlane.bind(this);
	    this.handleAddBox = this.handleAddBox.bind(this);
	    this.handleAddCircle = this.handleAddCircle.bind(this);
	    this.handleAddCylinder = this.handleAddCylinder.bind(this);
	    this.handleAddSphere = this.handleAddSphere.bind(this);
	    this.handleAddIcosahedron = this.handleAddIcosahedron.bind(this);
	    this.handleAddTorus = this.handleAddTorus.bind(this);
	    this.handleAddTorusKnot = this.handleAddTorusKnot.bind(this);
	    this.handleAddTeaport = this.handleAddTeaport.bind(this);
	    this.handleAddLathe = this.handleAddLathe.bind(this);
	    this.handleAddSprite = this.handleAddSprite.bind(this);
	    this.handleAddText = this.handleAddText.bind(this);
	    this.handleAddLineCurve = this.handleAddLineCurve.bind(this);
	    this.handleAddCatmullRomCurve = this.handleAddCatmullRomCurve.bind(this);
	    this.handleAddQuadraticBezierCurve = this.handleAddQuadraticBezierCurve.bind(this);
	    this.handleAddCubicBezierCurve = this.handleAddCubicBezierCurve.bind(this);
	    this.handleAddEllipseCurve = this.handleAddEllipseCurve.bind(this);
	  }

	  render() {
	    return React.createElement(MenuItem, {
	      title: _t('Geometry')
	    }, React.createElement(MenuItem, {
	      title: _t('Group'),
	      onClick: this.handleAddGroup
	    }), React.createElement(MenuItemSeparator, null), React.createElement(MenuItem, {
	      title: _t('Plane'),
	      onClick: this.handleAddPlane
	    }), React.createElement(MenuItem, {
	      title: _t('Box'),
	      onClick: this.handleAddBox
	    }), React.createElement(MenuItem, {
	      title: _t('Circle'),
	      onClick: this.handleAddCircle
	    }), React.createElement(MenuItem, {
	      title: _t('Cylinder'),
	      onClick: this.handleAddCylinder
	    }), React.createElement(MenuItem, {
	      title: _t('Sphere'),
	      onClick: this.handleAddSphere
	    }), React.createElement(MenuItem, {
	      title: _t('Icosahedron'),
	      onClick: this.handleAddIcosahedron
	    }), React.createElement(MenuItem, {
	      title: _t('Torus'),
	      onClick: this.handleAddTorus
	    }), React.createElement(MenuItem, {
	      title: _t('Torus Knot'),
	      onClick: this.handleAddTorusKnot
	    }), React.createElement(MenuItem, {
	      title: _t('Teapot'),
	      onClick: this.handleAddTeaport
	    }), React.createElement(MenuItem, {
	      title: _t('Lathe'),
	      onClick: this.handleAddLathe
	    }), React.createElement(MenuItem, {
	      title: _t('Sprite'),
	      onClick: this.handleAddSprite
	    }), React.createElement(MenuItem, {
	      title: _t('Text'),
	      onClick: this.handleAddText
	    }), React.createElement(MenuItemSeparator, null), React.createElement(MenuItem, {
	      title: _t('Line Curve'),
	      onClick: this.handleAddLineCurve
	    }), React.createElement(MenuItem, {
	      title: _t('CatmullRom Curve'),
	      onClick: this.handleAddCatmullRomCurve
	    }), React.createElement(MenuItem, {
	      title: _t('QuadraticBezier Curve'),
	      onClick: this.handleAddQuadraticBezierCurve
	    }), React.createElement(MenuItem, {
	      title: _t('CubicBezier Curve'),
	      onClick: this.handleAddCubicBezierCurve
	    }), React.createElement(MenuItem, {
	      title: _t('Ellipse Curve'),
	      onClick: this.handleAddEllipseCurve
	    }));
	  } // ------------------------- 组 ---------------------------------


	  handleAddGroup() {
	    app.editor.execute(new AddObjectCommand(new Group()));
	  } // ------------------------- 平板 -------------------------------


	  handleAddPlane() {
	    app.editor.execute(new AddObjectCommand(new Plane()));
	  } // ------------------------ 正方体 -----------------------------


	  handleAddBox() {
	    app.editor.execute(new AddObjectCommand(new Box()));
	  } // ------------------------ 圆 ----------------------------------


	  handleAddCircle() {
	    app.editor.execute(new AddObjectCommand(new Circle()));
	  } // ------------------------圆柱体 -------------------------------


	  handleAddCylinder() {
	    app.editor.execute(new AddObjectCommand(new Cylinder()));
	  } // ------------------------ 球体 -------------------------------


	  handleAddSphere() {
	    app.editor.execute(new AddObjectCommand(new Sphere()));
	  } // ----------------------- 二十面体 -----------------------------


	  handleAddIcosahedron() {
	    app.editor.execute(new AddObjectCommand(new Icosahedron()));
	  } // ----------------------- 轮胎 ---------------------------------


	  handleAddTorus() {
	    app.editor.execute(new AddObjectCommand(new Torus()));
	  } // ----------------------- 纽结 ---------------------------------


	  handleAddTorusKnot() {
	    app.editor.execute(new AddObjectCommand(new TorusKnot()));
	  } // ---------------------- 茶壶 ----------------------------------


	  handleAddTeaport() {
	    app.editor.execute(new AddObjectCommand(new Teapot()));
	  } // ---------------------- 酒杯 ----------------------------------


	  handleAddLathe() {
	    app.editor.execute(new AddObjectCommand(new Lathe()));
	  } // ---------------------- 精灵 -----------------------------------


	  handleAddSprite() {
	    app.editor.execute(new AddObjectCommand(new Sprite()));
	  } // ---------------------- 文本 ----------------------------------


	  handleAddText() {
	    app.prompt({
	      title: _t('Please input'),
	      value: _t('Sone Words'),
	      onOK: value => {
	        app.editor.execute(new AddObjectCommand(new Text(value)));
	      }
	    });
	  } // ---------------------- 线段 ----------------------------------


	  handleAddLineCurve() {
	    var line = new LineCurve();
	    app.editor.execute(new AddObjectCommand(line));
	  } // ---------------------- CatmullRom曲线 ----------------------------------


	  handleAddCatmullRomCurve() {
	    var line = new CatmullRomCurve();
	    app.editor.execute(new AddObjectCommand(line));
	  } // ----------------------- 二次贝塞尔曲线 ---------------------------------


	  handleAddQuadraticBezierCurve() {
	    var line = new QuadraticBezierCurve();
	    app.editor.execute(new AddObjectCommand(line));
	  } // ----------------------- 三次贝塞尔曲线 ---------------------------------


	  handleAddCubicBezierCurve() {
	    var line = new CubicBezierCurve();
	    app.editor.execute(new AddObjectCommand(line));
	  } // --------------------- 椭圆曲线 ------------------------------------------


	  handleAddEllipseCurve() {
	    var line = new EllipseCurve();
	    app.editor.execute(new AddObjectCommand(line));
	  }

	}

	/**
	 * 点光源
	 */
	function PointLight(color, intensity, distance, decay) {
	  THREE.PointLight.call(this, color, intensity, distance, decay); // var geometry = new THREE.SphereBufferGeometry(0.2, 16, 8);
	  // var material = new THREE.MeshBasicMaterial({
	  //     color: color
	  // });
	  // var mesh = new THREE.Mesh(geometry, material);
	  // // 帮助器
	  // mesh.name = _t('Help');
	  // mesh.userData.type = 'helper';
	  // this.add(mesh);
	  // // 光晕
	  // var textureLoader = new THREE.TextureLoader();
	  // var textureFlare0 = textureLoader.load('assets/textures/lensflare/lensflare0.png');
	  // var textureFlare3 = textureLoader.load('assets/textures/lensflare/lensflare3.png');
	  // // 光晕
	  // var lensflare = new THREE.Lensflare();
	  // lensflare.addElement(new THREE.LensflareElement(textureFlare0, 40, 0.01, new THREE.Color(color)));
	  // lensflare.addElement(new THREE.LensflareElement(textureFlare3, 60, 0.2));
	  // lensflare.addElement(new THREE.LensflareElement(textureFlare3, 35, 0.4));
	  // lensflare.addElement(new THREE.LensflareElement(textureFlare3, 60, 0.6));
	  // lensflare.addElement(new THREE.LensflareElement(textureFlare3, 45, 0.8));
	  // lensflare.name = _t('Halo');
	  // lensflare.userData.type = 'lensflare';
	  // this.add(lensflare);
	}

	PointLight.prototype = Object.create(THREE.PointLight.prototype);
	PointLight.prototype.constructor = PointLight;

	/**
	 * 半球光
	 * @param {*} skyColor 
	 * @param {*} groundColor 
	 * @param {*} intensity 
	 */

	function HemisphereLight(skyColor, groundColor, intensity) {
	  THREE.HemisphereLight.call(this, skyColor, groundColor, intensity); // var uniforms = {
	  //     topColor: { value: new THREE.Color(skyColor) },
	  //     bottomColor: { value: new THREE.Color(groundColor) },
	  //     offset: { value: 33 },
	  //     exponent: { value: 0.6 }
	  // };
	  // var skyGeo = new THREE.SphereBufferGeometry(4000, 32, 15);
	  // var skyMat = new THREE.ShaderMaterial({
	  //     vertexShader: vertexShader,
	  //     fragmentShader: fragmentShader,
	  //     uniforms: uniforms,
	  //     side: THREE.BackSide
	  // });
	  // var sky = new THREE.Mesh(skyGeo, skyMat);
	  // sky.name = _t('Sky');
	  // sky.userData.type = 'sky';
	  // this.add(sky);
	}

	HemisphereLight.prototype = Object.create(THREE.HemisphereLight.prototype);
	HemisphereLight.prototype.constructor = HemisphereLight;

	/**
	 * 点光源
	 */
	function RectAreaLight(color, intensity, width, height) {
	  THREE.RectAreaLight.call(this, color, intensity, width, height); // // 正面
	  // var rectLightMesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(), new THREE.MeshBasicMaterial());
	  // rectLightMesh.scale.x = width;
	  // rectLightMesh.scale.y = height;
	  // rectLightMesh.name = _t('FrontSide');
	  // rectLightMesh.userData.type = 'frontSide';
	  // this.add(rectLightMesh);
	  // var rectLightMeshBack = new THREE.Mesh(new THREE.PlaneBufferGeometry(), new THREE.MeshBasicMaterial({ color: 0x080808 }));
	  // rectLightMeshBack.scale.x = width;
	  // rectLightMeshBack.scale.y = height;
	  // rectLightMeshBack.rotation.y = Math.PI;
	  // rectLightMesh.name = _t('BackSide');
	  // rectLightMesh.userData.type = 'backSide';
	  // this.add(rectLightMeshBack);
	}

	RectAreaLight.prototype = Object.create(THREE.RectAreaLight.prototype);
	RectAreaLight.prototype.constructor = RectAreaLight;

	/**
	 * 光源菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class LightMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleAddAmbientLight = this.handleAddAmbientLight.bind(this);
	    this.handleAddDirectionalLight = this.handleAddDirectionalLight.bind(this);
	    this.handleAddPointLight = this.handleAddPointLight.bind(this);
	    this.handleAddSpotLight = this.handleAddSpotLight.bind(this);
	    this.handleAddHemisphereLight = this.handleAddHemisphereLight.bind(this);
	    this.handleAddRectAreaLight = this.handleAddRectAreaLight.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    return React.createElement(MenuItem, {
	      title: _t('Light')
	    }, React.createElement(MenuItem, {
	      title: _t('Ambient Light'),
	      onClick: this.handleAddAmbientLight
	    }), React.createElement(MenuItem, {
	      title: _t('Directional Light'),
	      onClick: this.handleAddDirectionalLight
	    }), React.createElement(MenuItem, {
	      title: _t('Point Light'),
	      onClick: this.handleAddPointLight
	    }), React.createElement(MenuItem, {
	      title: _t('Spot Light'),
	      onClick: this.handleAddSpotLight
	    }), React.createElement(MenuItem, {
	      title: _t('Hemisphere Light'),
	      onClick: this.handleAddHemisphereLight
	    }), React.createElement(MenuItem, {
	      title: _t('Rect Area Light'),
	      onClick: this.handleAddRectAreaLight
	    }));
	  } // ------------------------- 环境光 ------------------------------


	  handleAddAmbientLight() {
	    var editor = app.editor;
	    var color = 0xaaaaaa;
	    var light = new THREE.AmbientLight(color);
	    light.name = _t('Ambient Light');
	    editor.execute(new AddObjectCommand(light));
	  } // ------------------------- 平行光 ------------------------------


	  handleAddDirectionalLight() {
	    var editor = app.editor;
	    var color = 0xffffff;
	    var intensity = 1;
	    var light = new THREE.DirectionalLight(color, intensity);
	    light.name = _t('Directional Light');
	    light.castShadow = true;
	    light.shadow.mapSize.x = 2048;
	    light.shadow.mapSize.y = 2048;
	    light.shadow.camera.left = -100;
	    light.shadow.camera.right = 100;
	    light.shadow.camera.top = 100;
	    light.shadow.camera.bottom = -100;
	    light.position.set(5, 10, 7.5);
	    editor.execute(new AddObjectCommand(light));
	  } // ------------------------- 点光源 ------------------------------


	  handleAddPointLight() {
	    var editor = app.editor;
	    var color = 0xffffff;
	    var intensity = 1;
	    var distance = 0;
	    var light = new PointLight(color, intensity, distance);
	    light.name = _t('Point Light');
	    light.position.y = 5;
	    light.castShadow = true;
	    editor.execute(new AddObjectCommand(light));
	  } // ------------------------- 聚光灯 ------------------------------


	  handleAddSpotLight() {
	    var editor = app.editor;
	    var color = 0xffffff;
	    var intensity = 1;
	    var distance = 0;
	    var angle = Math.PI * 0.1;
	    var penumbra = 0;
	    var light = new THREE.SpotLight(color, intensity, distance, angle, penumbra);
	    light.name = _t('Spot Light');
	    light.castShadow = true;
	    light.position.set(5, 10, 7.5);
	    editor.execute(new AddObjectCommand(light));
	  } // ------------------------- 半球光 ------------------------------


	  handleAddHemisphereLight() {
	    var editor = app.editor;
	    var skyColor = 0x00aaff;
	    var groundColor = 0xffaa00;
	    var intensity = 1;
	    var light = new HemisphereLight(skyColor, groundColor, intensity);
	    light.name = _t('Hemisphere Light');
	    light.position.set(0, 10, 0);
	    editor.execute(new AddObjectCommand(light));
	  } // ------------------------- 矩形光 ------------------------------


	  handleAddRectAreaLight() {
	    var editor = app.editor;
	    var color = 0xffffff;
	    var intensity = 1;
	    var width = 20;
	    var height = 10;
	    var light = new RectAreaLight(color, intensity, width, height);
	    light.name = _t('Rect Area Light');
	    light.position.set(0, 6, 0);
	    editor.execute(new AddObjectCommand(light));
	  }

	}

	/**
	 * 资源菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class AssetsMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleExportGeometry = this.handleExportGeometry.bind(this);
	    this.handleExportObject = this.handleExportObject.bind(this);
	    this.handleExportCollada = this.handleExportCollada.bind(this);
	    this.handleExportDRACO = this.handleExportDRACO.bind(this);
	    this.handleExportGLTF = this.handleExportGLTF.bind(this);
	    this.handleExportOBJ = this.handleExportOBJ.bind(this);
	    this.handleExportPLY = this.handleExportPLY.bind(this);
	    this.handleExportSTLB = this.handleExportSTLB.bind(this);
	    this.handleExportSTL = this.handleExportSTL.bind(this);
	  }

	  render() {
	    return React.createElement(MenuItem, {
	      title: _t('Assets')
	    }, React.createElement(MenuItem, {
	      title: _t('Export Geometry'),
	      onClick: this.handleExportGeometry
	    }), React.createElement(MenuItem, {
	      title: _t('Export Object'),
	      onClick: this.handleExportObject
	    }), React.createElement(MenuItemSeparator, null), React.createElement(MenuItem, {
	      title: _t('Export Collada'),
	      onClick: this.handleExportCollada
	    }), React.createElement(MenuItem, {
	      title: _t('Export DRACO'),
	      onClick: this.handleExportDRACO
	    }), React.createElement(MenuItem, {
	      title: _t('Export GLTF'),
	      onClick: this.handleExportGLTF
	    }), React.createElement(MenuItem, {
	      title: _t('Export OBJ'),
	      onClick: this.handleExportOBJ
	    }), React.createElement(MenuItem, {
	      title: _t('Export PLY'),
	      onClick: this.handleExportPLY
	    }), React.createElement(MenuItem, {
	      title: _t('Export STL Binary'),
	      onClick: this.handleExportSTLB
	    }), React.createElement(MenuItem, {
	      title: _t('Export STL'),
	      onClick: this.handleExportSTL
	    }));
	  } // ------------------------------- 导出几何体 ----------------------------------------


	  handleExportGeometry() {
	    var editor = app.editor;
	    var object = editor.selected;

	    if (object === null) {
	      app.toast(_t('Please select object!'));
	      return;
	    }

	    var geometry = object.geometry;

	    if (geometry === undefined) {
	      app.toast(_t('The object you selected is not geometry.'));
	      return;
	    }

	    var output = geometry.toJSON();

	    try {
	      output = JSON.stringify(output, parseNumber, '\t');
	      output = output.replace(/[\n\t]+([\d\.e\-\[\]]+)/g, '$1');
	    } catch (e) {
	      output = JSON.stringify(output);
	    }

	    StringUtils.saveString(output, 'geometry.json');
	  } // ------------------------------- 导出物体 ------------------------------------------


	  handleExportObject() {
	    var editor = app.editor;
	    var object = editor.selected;

	    if (object === null) {
	      app.toast(_t('Please select object!'));
	      return;
	    }

	    var output = object.toJSON();

	    try {
	      output = JSON.stringify(output, parseNumber, '\t');
	      output = output.replace(/[\n\t]+([\d\.e\-\[\]]+)/g, '$1');
	    } catch (e) {
	      output = JSON.stringify(output);
	    }

	    StringUtils.saveString(output, 'model.json');
	  } // ------------------------------ 导出Collada文件 ----------------------------------------


	  handleExportCollada() {
	    app.require('ColladaExporter').then(() => {
	      var exporter = new THREE.ColladaExporter();
	      exporter.parse(app.editor.scene, function (result) {
	        // TODO: 导出纹理
	        StringUtils.saveString(result.data, 'model.dae');
	      });
	    });
	  } // ------------------------------ 导出DRACO文件 ----------------------------------------


	  handleExportDRACO() {
	    if (!(app.editor.selected instanceof THREE.Mesh)) {
	      app.toast(_t('Please select a mesh.'));
	      return;
	    }

	    app.require('DRACOExporter').then(() => {
	      var exporter = new THREE.DRACOExporter();
	      var data = exporter.parse(app.editor.selected.geometry);
	      StringUtils.saveString(data, 'model.drc');
	    });
	  } // ------------------------------ 导出gltf文件 ----------------------------------------


	  handleExportGLTF() {
	    app.require('GLTFExporter').then(() => {
	      var exporter = new THREE.GLTFExporter();
	      exporter.parse(app.editor.scene, function (result) {
	        StringUtils.saveString(JSON.stringify(result), 'model.gltf');
	      });
	    });
	  } // ------------------------------ 导出obj文件 -----------------------------------------


	  handleExportOBJ() {
	    var editor = app.editor;
	    var object = editor.selected;

	    if (object === null) {
	      app.toast(_t('Please select object!'));
	      return;
	    }

	    app.require('OBJExporter').then(() => {
	      var exporter = new THREE.OBJExporter();
	      StringUtils.saveString(exporter.parse(object), 'model.obj');
	    });
	  } // ------------------------------- 导出ply文件 ----------------------------------------


	  handleExportPLY() {
	    var editor = app.editor;
	    var object = editor.selected;

	    if (object === null) {
	      app.toast(_t('Please select object!'));
	      return;
	    }

	    app.require('PLYExporter').then(() => {
	      var exporter = new THREE.PLYExporter();
	      StringUtils.saveString(exporter.parse(object, {
	        excludeAttributes: ['normal', 'uv', 'color', 'index']
	      }), 'model.ply');
	    });
	  } // ------------------------------- 导出stl二进制文件 -----------------------------------


	  handleExportSTLB() {
	    var editor = app.editor;

	    app.require('STLBinaryExporter').then(() => {
	      var exporter = new THREE.STLBinaryExporter();
	      StringUtils.saveString(exporter.parse(editor.scene), 'model.stl');
	    });
	  } // ------------------------------- 导出stl文件 -----------------------------------------


	  handleExportSTL() {
	    var editor = app.editor;

	    app.require('STLExporter').then(() => {
	      var exporter = new THREE.STLExporter();
	      StringUtils.saveString(exporter.parse(editor.scene), 'model.stl');
	    });
	  }

	}

	var HeightVertexShader = "varying vec2 vUv;\r\nuniform vec2 scale;\r\nuniform vec2 offset;\r\n\r\nvoid main( void ) {\r\n    vUv = uv * scale + offset;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}";

	var HeightFragmentShader = "//\r\n// Description : Array and textureless GLSL 3D simplex noise function.\r\n//      Author : Ian McEwan, Ashima Arts.\r\n//  Maintainer : ijm\r\n//     Lastmod : 20110409 (stegu)\r\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\r\n//               Distributed under the MIT License. See LICENSE file.\r\n//\r\nuniform float time;\r\nvarying vec2 vUv;\r\n\r\nvec4 permute( vec4 x ) {\r\n\treturn mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );\r\n}\r\n\r\nvec4 taylorInvSqrt( vec4 r ) {\r\n\treturn 1.79284291400159 - 0.85373472095314 * r;\r\n}\r\n\r\nfloat snoise( vec3 v ) {\r\n\tconst vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\r\n\tconst vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );\r\n\t// First corner\r\n\tvec3 i  = floor( v + dot( v, C.yyy ) );\r\n\tvec3 x0 = v - i + dot( i, C.xxx );\r\n\t// Other corners\r\n\tvec3 g = step( x0.yzx, x0.xyz );\r\n\tvec3 l = 1.0 - g;\r\n\tvec3 i1 = min( g.xyz, l.zxy );\r\n\tvec3 i2 = max( g.xyz, l.zxy );\r\n\tvec3 x1 = x0 - i1 + 1.0 * C.xxx;\r\n\tvec3 x2 = x0 - i2 + 2.0 * C.xxx;\r\n\tvec3 x3 = x0 - 1. + 3.0 * C.xxx;\r\n\t// Permutations\r\n\ti = mod( i, 289.0 );\r\n\tvec4 p = permute( permute( permute(\r\n\t\t\t i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )\r\n\t\t   + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )\r\n\t\t   + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\r\n\t// Gradients\r\n\t// ( N*N points uniformly over a square, mapped onto an octahedron.)\r\n\tfloat n_ = 1.0 / 7.0; // N=7\r\n\tvec3 ns = n_ * D.wyz - D.xzx;\r\n\tvec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)\r\n\tvec4 x_ = floor( j * ns.z );\r\n\tvec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)\r\n\tvec4 x = x_ *ns.x + ns.yyyy;\r\n\tvec4 y = y_ *ns.x + ns.yyyy;\r\n\tvec4 h = 1.0 - abs( x ) - abs( y );\r\n\tvec4 b0 = vec4( x.xy, y.xy );\r\n\tvec4 b1 = vec4( x.zw, y.zw );\r\n\tvec4 s0 = floor( b0 ) * 2.0 + 1.0;\r\n\tvec4 s1 = floor( b1 ) * 2.0 + 1.0;\r\n\tvec4 sh = -step( h, vec4( 0.0 ) );\r\n\tvec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\r\n\tvec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\r\n\tvec3 p0 = vec3( a0.xy, h.x );\r\n\tvec3 p1 = vec3( a0.zw, h.y );\r\n\tvec3 p2 = vec3( a1.xy, h.z );\r\n\tvec3 p3 = vec3( a1.zw, h.w );\r\n\t// Normalise gradients\r\n\tvec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );\r\n\tp0 *= norm.x;\r\n\tp1 *= norm.y;\r\n\tp2 *= norm.z;\r\n\tp3 *= norm.w;\r\n\t// Mix final noise value\r\n\tvec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\r\n\tm = m * m;\r\n\treturn 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),\r\n\t\t\t\t\t\t\t\t  dot( p2, x2 ), dot( p3, x3 ) ) );\r\n}\r\n\r\nfloat surface3( vec3 coord ) {\r\n\tfloat n = 0.0;\r\n\tn += 1.0 * abs( snoise( coord ) );\r\n\tn += 0.5 * abs( snoise( coord * 2.0 ) );\r\n\tn += 0.25 * abs( snoise( coord * 4.0 ) );\r\n\tn += 0.125 * abs( snoise( coord * 8.0 ) );\r\n\treturn n;\r\n}\r\n\r\nvoid main( void ) {\r\n\tvec3 coord = vec3( vUv, -time );\r\n\tfloat n = surface3( coord );\r\n\tgl_FragColor = vec4( vec3( n, n, n ), 1.0 );\r\n}";

	/**
	 * 着色器地形
	 * @param {*} renderer 渲染器
	 */

	function ShaderTerrain(renderer) {
	  var width = renderer.domElement.width; // 画布宽度

	  var height = renderer.domElement.height; // 画布高度
	  // 地形参数

	  var rx = 256,
	      ry = 256,
	      // 分辨率
	  animDelta = 0,
	      // 动画间隔
	  animDeltaDir = -1,
	      // 光源强度
	  lightDir = 1; // 光源方向
	  // 场景

	  var scene = new THREE.Scene(); // 相机

	  var camera = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, -10000, 10000);
	  camera.position.z = 100;
	  scene.add(camera); // 高程贴图

	  var heightMap = new THREE.WebGLRenderTarget(rx, ry, {
	    minFilter: THREE.LinearFilter,
	    magFilter: THREE.LinearFilter,
	    format: THREE.RGBFormat
	  });
	  heightMap.texture.generateMipmaps = false; // 法线贴图

	  var normalMap = new THREE.WebGLRenderTarget(rx, ry, {
	    minFilter: THREE.LinearFilter,
	    magFilter: THREE.LinearFilter,
	    format: THREE.RGBFormat
	  });
	  normalMap.texture.generateMipmaps = false; // 高光贴图

	  var specularMap = new THREE.WebGLRenderTarget(2048, 2048, {
	    minFilter: THREE.LinearFilter,
	    magFilter: THREE.LinearFilter,
	    format: THREE.RGBFormat
	  });
	  specularMap.texture.generateMipmaps = false; // 下载纹理

	  var loadingManager = new THREE.LoadingManager(() => {
	    this.visible = true;
	  });
	  var textureLoader = new THREE.TextureLoader(loadingManager);
	  var diffuseTexture1 = textureLoader.load("assets/textures/terrain/grasslight-big.jpg"); // 漫反射纹理1

	  var diffuseTexture2 = textureLoader.load("assets/textures/terrain/backgrounddetailed6.jpg"); // 漫反射纹理2

	  var detailTexture = textureLoader.load("assets/textures/terrain/grasslight-big-nm.jpg"); // 细节纹理

	  diffuseTexture1.wrapS = diffuseTexture1.wrapT = THREE.RepeatWrapping;
	  diffuseTexture2.wrapS = diffuseTexture2.wrapT = THREE.RepeatWrapping;
	  detailTexture.wrapS = detailTexture.wrapT = THREE.RepeatWrapping; // 创建高程材质

	  var heightUniforms = {
	    time: {
	      value: 1.0
	    },
	    scale: {
	      value: new THREE.Vector2(1.5, 1.5)
	    },
	    offset: {
	      value: new THREE.Vector2(0, 0)
	    }
	  };
	  var hightMaterial = this.createShaderMaterial(HeightVertexShader, HeightFragmentShader, heightUniforms, false); // 创建法线材质

	  var normalUniforms = THREE.UniformsUtils.clone(THREE.NormalMapShader.uniforms);
	  normalUniforms.height.value = 0.05;
	  normalUniforms.resolution.value.set(rx, ry);
	  normalUniforms.heightMap.value = heightMap.texture;
	  var normalMaterial = this.createShaderMaterial(THREE.NormalMapShader.vertexShader, THREE.NormalMapShader.fragmentShader, normalUniforms, false); // 创建地形材质

	  var terrainShader = THREE.TerrainShader;
	  var terrainUniforms = THREE.UniformsUtils.clone(terrainShader.uniforms);
	  terrainUniforms['tDisplacement'].value = heightMap.texture; // 位移贴图

	  terrainUniforms['uDisplacementScale'].value = 375; // 位移贴图缩放

	  terrainUniforms['tNormal'].value = normalMap.texture; // 法线贴图

	  terrainUniforms['uNormalScale'].value = 3.5; // 法线贴图缩放

	  terrainUniforms['specular'].value.setHex(0xffffff); // 高光颜色

	  terrainUniforms['diffuse'].value.setHex(0xffffff); // 漫反射颜色

	  terrainUniforms['shininess'].value = 30; // 光泽

	  terrainUniforms['tSpecular'].value = specularMap.texture; // 高光贴图

	  terrainUniforms['enableSpecular'].value = true; // 是否启用高光贴图

	  terrainUniforms['tDiffuse1'].value = diffuseTexture1; // 漫反射纹理1

	  terrainUniforms['enableDiffuse1'].value = true; // 是否启用漫反射纹理1

	  terrainUniforms['tDiffuse2'].value = diffuseTexture2; // 漫反射纹理2

	  terrainUniforms['enableDiffuse2'].value = true; // 是否启用漫反射纹理2

	  terrainUniforms['tDetail'].value = detailTexture; // 细节纹理

	  terrainUniforms['uRepeatOverlay'].value.set(6, 6); // 重复叠加次数

	  var terrainMaterial = this.createShaderMaterial(terrainShader.vertexShader, terrainShader.fragmentShader, terrainUniforms, true); // 贴图生成渲染目标

	  var quadTarget = new THREE.Mesh(new THREE.PlaneBufferGeometry(width, height), new THREE.MeshBasicMaterial({
	    color: 0x000000
	  }));
	  quadTarget.position.z = -500;
	  scene.add(quadTarget); // 创建网格

	  var geometry = new THREE.PlaneBufferGeometry(6000, 6000, 256, 256);
	  THREE.BufferGeometryUtils.computeTangents(geometry);
	  THREE.Mesh.call(this, geometry, terrainMaterial);
	  this.name = _t('Terrain');
	  this.position.set(0, -30, 0);
	  this.rotation.x = -Math.PI / 2;
	  this.scale.set(0.1, 0.1, 0.1); // 动画函数

	  function update(deltaTime) {
	    if (!this.visible) {
	      return;
	    }

	    var fLow = 0.1,
	        fHigh = 0.8;
	    var lightVal = THREE.Math.clamp(lightVal + 0.5 * deltaTime * lightDir, fLow, fHigh);
	    var valNorm = (lightVal - fLow) / (fHigh - fLow);
	    terrainUniforms['uNormalScale'].value = THREE.Math.mapLinear(valNorm, 0, 1, 0.6, 3.5);
	    animDelta = THREE.Math.clamp(animDelta + 0.00075 * animDeltaDir, 0, 0.05);
	    heightUniforms['time'].value += deltaTime * animDelta;
	    heightUniforms['offset'].value.x += deltaTime * 0.05; // 生成高程贴图

	    quadTarget.material = hightMaterial;
	    renderer.render(scene, camera, heightMap, true); // 生成法线贴图

	    quadTarget.material = normalMaterial;
	    renderer.render(scene, camera, normalMap, true);
	  }
	  this.update = update.bind(this);
	}

	ShaderTerrain.prototype = Object.create(THREE.Mesh.prototype);
	ShaderTerrain.prototype.constructor = ShaderTerrain;
	/**
	 * 创建着色器材质
	 * @param {*} vertexShader 顶点着色器
	 * @param {*} fragmentShader 片源着色器
	 * @param {*} uniforms 变量
	 * @param {*} lights 是否使用光源
	 */

	ShaderTerrain.prototype.createShaderMaterial = function (vertexShader, fragmentShader, uniforms, lights) {
	  return new THREE.ShaderMaterial({
	    vertexShader: vertexShader,
	    fragmentShader: fragmentShader,
	    uniforms: uniforms,
	    lights: lights,
	    fog: true
	  });
	};

	/**
	 * 组件菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class ComponentMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleAddBackgroundMusic = this.handleAddBackgroundMusic.bind(this);
	    this.handleParticleEmitter = this.handleParticleEmitter.bind(this);
	    this.handleAddSky = this.handleAddSky.bind(this);
	    this.handleAddFire = this.handleAddFire.bind(this);
	    this.handleAddWater = this.handleAddWater.bind(this);
	    this.handleAddSmoke = this.handleAddSmoke.bind(this);
	    this.handleAddCloth = this.handleAddCloth.bind(this);
	    this.handleAddPerlinTerrain = this.handleAddPerlinTerrain.bind(this);
	    this.handleAddShaderTerrain = this.handleAddShaderTerrain.bind(this);
	  }

	  render() {
	    return React.createElement(MenuItem, {
	      title: _t('Component')
	    }, React.createElement(MenuItem, {
	      title: _t('Background Music'),
	      onClick: this.handleAddBackgroundMusic
	    }), React.createElement(MenuItem, {
	      title: _t('ParticleEmitter'),
	      onClick: this.handleParticleEmitter
	    }), React.createElement(MenuItem, {
	      title: _t('Sky'),
	      onClick: this.handleAddSky
	    }), React.createElement(MenuItem, {
	      title: _t('Fire'),
	      onClick: this.handleAddFire
	    }), React.createElement(MenuItem, {
	      title: _t('Water'),
	      onClick: this.handleAddWater
	    }), React.createElement(MenuItem, {
	      title: _t('Smoke'),
	      onClick: this.handleAddSmoke
	    }), React.createElement(MenuItem, {
	      title: _t('Cloth'),
	      onClick: this.handleAddCloth
	    }), React.createElement(MenuItem, {
	      title: _t('Perlin Terrain'),
	      onClick: this.handleAddPerlinTerrain
	    }));
	  } // ---------------------------- 添加背景音乐 ----------------------------------


	  handleAddBackgroundMusic() {
	    var editor = app.editor;
	    var listener = editor.audioListener;
	    var audio = new THREE.Audio(listener);
	    audio.name = _t('Background Music');
	    audio.autoplay = false;
	    audio.setLoop(true);
	    audio.setVolume(1.0);
	    audio.userData.autoplay = true;
	    app.editor.execute(new AddObjectCommand(audio));
	  } // ---------------------------- 添加粒子发射器 --------------------------------------------


	  handleParticleEmitter() {
	    var emitter = new ParticleEmitter();
	    app.editor.execute(new AddObjectCommand(emitter));
	    emitter.userData.group.tick(0);
	  } // ---------------------------- 天空 ----------------------------------------


	  handleAddSky() {
	    var obj = new Sky();
	    obj.name = _t('Sky');
	    obj.userData.type = 'Sky';
	    app.editor.execute(new AddObjectCommand(obj));
	  } // ---------------------------- 添加火焰 -------------------------------------


	  handleAddFire() {
	    var editor = app.editor;
	    var fire = new Fire(editor.camera);
	    editor.execute(new AddObjectCommand(fire));
	    fire.userData.fire.update(0);
	  } // -------------------------- 添加水 ---------------------------------------


	  handleAddWater() {
	    var editor = app.editor;
	    var water = new Water(editor.renderer);
	    editor.execute(new AddObjectCommand(water));
	    water.update();
	  } // ------------------------------ 添加烟 ------------------------------------


	  handleAddSmoke() {
	    var editor = app.editor;
	    var camera = editor.camera;
	    var renderer = editor.renderer;
	    var smoke = new Smoke(camera, renderer);
	    smoke.position.y = 3;
	    editor.execute(new AddObjectCommand(smoke));
	    smoke.update(0);
	  } // ----------------------------- 添加布 ------------------------------------


	  handleAddCloth() {
	    var editor = app.editor;
	    var cloth = new Cloth();
	    cloth.name = _t('Cloth');
	    editor.execute(new AddObjectCommand(cloth));
	  } // ----------------------------- 添加柏林地形 -------------------------------


	  handleAddPerlinTerrain() {
	    let terrain = new PerlinTerrain();
	    terrain.name = _t('Perlin Terrain');
	    app.editor.execute(new AddObjectCommand(terrain));
	  } // ----------------------------- 添加着色器地形 --------------------------------


	  handleAddShaderTerrain() {
	    app.require('NormalMapShader').then(() => {
	      let terrain = new ShaderTerrain(app.editor.renderer);
	      terrain.name = _t('Shader Terrain');
	      app.editor.execute(new AddObjectCommand(terrain));
	      terrain.update(0);
	    });
	  }

	}

	/**
	 * 播放菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class PlayMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      isPlaying: false
	    };
	    this.handleTogglePlay = this.handleTogglePlay.bind(this);
	    this.handlePlayFullscreen = this.handlePlayFullscreen.bind(this);
	    this.handlePlayNewWindow = this.handlePlayNewWindow.bind(this);
	  }

	  render() {
	    const {
	      isPlaying
	    } = this.state;
	    return React.createElement(MenuItem, {
	      title: _t('Play')
	    }, React.createElement(MenuItem, {
	      title: isPlaying ? _t('Stop') : _t('Play'),
	      onClick: this.handleTogglePlay
	    }), React.createElement(MenuItem, {
	      title: _t('Play Fullscreen'),
	      onClick: this.handlePlayFullscreen
	    }), React.createElement(MenuItem, {
	      title: _t('Play New Window'),
	      onClick: this.handlePlayNewWindow
	    }));
	  }

	  handleTogglePlay() {
	    if (this.state.isPlaying) {
	      this.handleStopPlay();
	    } else {
	      this.handleStartPlay();
	    }
	  }

	  handleStartPlay() {
	    // 启动播放
	    if (this.state.isPlaying) {
	      return;
	    }

	    this.setState({
	      isPlaying: true
	    }); // 将场景数据转换为字符串

	    var jsons = new Converter().toJSON({
	      options: app.options,
	      scene: app.editor.scene,
	      camera: app.editor.camera,
	      renderer: app.editor.renderer,
	      scripts: app.editor.scripts,
	      animations: app.editor.animations,
	      visual: app.editor.visual
	    });
	    app.player.start(JSON.stringify(jsons));
	  }

	  handleStopPlay() {
	    // 停止播放
	    if (!this.state.isPlaying) {
	      return;
	    }

	    this.setState({
	      isPlaying: false
	    });
	    app.player.stop();
	    this.setState;
	  }

	  handlePlayFullscreen() {
	    // 全屏播放
	    if (!this.state.isPlaying) {
	      this.handleStartPlay();
	    }

	    app.playerRef.requestFullscreen();
	  }

	  handlePlayNewWindow() {
	    // 新窗口播放
	    let sceneID = app.editor.sceneID;

	    if (!sceneID) {
	      app.toast(_t('Please save scene first.'));
	      return;
	    }

	    window.open(`view.html?sceneID=${sceneID}`, 'ShadowPlayer');
	  }

	}

	/**
	 * 纹理生成器窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class TextureGeneratorWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.containerRef = React.createRef();
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    return React.createElement(Window, {
	      className: 'TextureGeneratorWindow',
	      title: _t('Texture Generator'),
	      style: {
	        width: '800px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, React.createElement(Content, null, React.createElement("div", {
	      ref: this.containerRef
	    })), React.createElement(Buttons, null, React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Close'))));
	  }

	  componentDidMount() {
	    const container = this.containerRef.current;
	    let examples = [];
	    var vignette = null;
	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.XOR().tint(1, 0.5, 0.7)).add(new TG.SinX().frequency(0.004).tint(0.25, 0, 0)).sub(new TG.SinY().frequency(0.004).tint(0.25, 0, 0)).add(new TG.SinX().frequency(0.0065).tint(0.1, 0.5, 0.2)).add(new TG.SinY().frequency(0.0065).tint(0, 0.4, 0.5)).add(new TG.Noise().tint(0.1, 0.1, 0.2)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.SinX().offset(-16).frequency(0.03).tint(0.1, 0.25, 0.5)).add(new TG.SinY().offset(-16).frequency(0.03).tint(0.1, 0.25, 0.5)).add(new TG.Number().tint(0.75, 0.5, 0.5)).add(new TG.SinX().frequency(0.03).tint(0.2, 0.2, 0.2)).add(new TG.SinY().frequency(0.03).tint(0.2, 0.2, 0.2)).add(new TG.Noise().tint(0.1, 0, 0)).add(new TG.Noise().tint(0, 0.1, 0)).add(new TG.Noise().tint(0, 0, 0.1)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.SinX().frequency(0.1)).mul(new TG.SinX().frequency(0.05)).mul(new TG.SinX().frequency(0.025)).mul(new TG.SinY().frequency(0.1)).mul(new TG.SinY().frequency(0.05)).mul(new TG.SinY().frequency(0.025)).add(new TG.SinX().frequency(0.004).tint(-0.25, 0.1, 0.6)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.XOR()).mul(new TG.OR().tint(0.5, 0.8, 0.5)).mul(new TG.SinX().frequency(0.0312)).div(new TG.SinY().frequency(0.0312)).add(new TG.SinX().frequency(0.004).tint(0.5, 0, 0)).add(new TG.Noise().tint(0.1, 0.1, 0.2)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.SinX().frequency(0.01)).mul(new TG.SinY().frequency(0.0075)).add(new TG.SinX().frequency(0.0225)).mul(new TG.SinY().frequency(0.015)).add(new TG.Noise().tint(0.1, 0.1, 0.3)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.SinX().frequency(0.05)).mul(new TG.SinX().frequency(0.08)).add(new TG.SinY().frequency(0.05)).mul(new TG.SinY().frequency(0.08)).div(new TG.Number().tint(1, 2, 1)).add(new TG.SinX().frequency(0.003).tint(0.5, 0, 0)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.SinX().frequency(0.066)).add(new TG.SinY().frequency(0.066)).mul(new TG.SinX().offset(32).frequency(0.044).tint(2, 2, 2)).mul(new TG.SinY().offset(16).frequency(0.044).tint(2, 2, 2)).sub(new TG.Number().tint(0.5, 2, 4)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.SinX().frequency(0.004)).mul(new TG.SinY().frequency(0.004)).mul(new TG.SinY().offset(32).frequency(0.02)).div(new TG.SinX().frequency(0.02).tint(8, 5, 4)).add(new TG.Noise().tint(0.1, 0, 0)).add(new TG.Noise().tint(0, 0.1, 0)).add(new TG.Noise().tint(0, 0, 0.1)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.CheckerBoard()).add(new TG.CheckerBoard().size(2, 2).tint(0.5, 0, 0)).add(new TG.CheckerBoard().size(8, 8).tint(1, 0.5, 0.5)).sub(new TG.CheckerBoard().offset(16, 16).tint(0.5, 0.5, 0)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.Rect().position(size / 4.8, size / 12).size(size / 1.7, size / 2).tint(1, 0.25, 0.25)).add(new TG.Rect().position(size / 12, size / 4).size(size / 1.21, size / 2).tint(0.25, 1, 0.25)).add(new TG.Rect().position(size / 4.8, size / 2.5).size(size / 1.7, size / 2).tint(0.25, 0.25, 1)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.CheckerBoard().size(32, 32).tint(0.5, 0, 0)).set(new TG.SineDistort()).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.CheckerBoard().size(32, 32).tint(0.5, 0, 0)).set(new TG.Twirl().radius(size / 2).position(size / 2, size / 2).strength(75)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.Circle().position(size / 2, size / 2).radius(size / 4)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.Circle().position(size / 2, size / 2).radius(size / 4).delta(size / 4).tint(1, 0.25, 0.25)).set(new TG.Pixelate().size(size / 32, size / 32)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.CheckerBoard().tint(1, 1, 0)).set(new TG.Transform().offset(10, 20).angle(23).scale(2, 0.5)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.CheckerBoard()).and(new TG.Circle().position(size / 2, size / 2).radius(size / 3)).xor(new TG.Circle().position(size / 2, size / 2).radius(size / 4)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.CheckerBoard().size(size / 16, size / 16)).set(new TG.Twirl().radius(size / 2).strength(75).position(size / 2, size / 2)).min(new TG.Circle().position(size / 2, size / 2).radius(size / 2).delta(size / 2)).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.LinearGradient().interpolation(0).point(0, [1, 1, 0, 0]).point(0.25, [0.2, 0, 0.5, 1]).point(0.5, [0.5, 0.2, 0.5, 1]).point(1, [1, 0, 1, 1])).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.LinearGradient().interpolation(1).point(0, [1, 1, 0, 0]).point(0.25, [0.2, 0, 0.5, 1]).point(0.5, [0.5, 0.2, 0.5, 1]).point(1, [1, 0, 1, 1])).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.LinearGradient().interpolation(2).point(0, [1, 1, 0, 0]).point(0.25, [0.2, 0, 0.5, 1]).point(0.5, [0.5, 0.2, 0.5, 1]).point(1, [1, 0, 1, 1])).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.RadialGradient().center(size / 2, size / 2).radius(size / 8).repeat(true).interpolation(0).point(0, [1, 1, 0, 0]).point(0.25, [0.2, 0, 0.5, 1]).point(0.5, [0.5, 0.2, 0.5, 1]).point(1, [1, 0, 1, 1])).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.RadialGradient().center(0, 0).radius(size * 2).interpolation(1).point(0, [1, 1, 0, 0]).point(0.25, [0.2, 0, 0.5, 1]).point(0.5, [0.5, 0.2, 0.5, 1]).point(1, [1, 0, 1, 1])).toCanvas();
	      return texture;
	    }); //

	    examples.push(function (size) {
	      var texture = new TG.Texture(size, size).add(new TG.RadialGradient().center(size / 2, 0).radius(size).interpolation(2).point(0, [1, 1, 0, 0]).point(0.25, [0.2, 0, 0.5, 1]).point(0.5, [0.5, 0.2, 0.5, 1]).point(1, [1, 0, 1, 1])).toCanvas();
	      return texture;
	    }); //---- Put-Texture ----

	    examples.push(function (size) {
	      vignette = new TG.Texture(size, size) // predefine a vignette-effect so it can be used later
	      .set(new TG.Circle().radius(size).position(size / 2, size / 2).delta(size * 0.7));
	      var numSamples = 6; // more samples = heavier effect

	      var base = new TG.Texture(size, size) // generating an image to be blurred
	      .set(new TG.FractalNoise().amplitude(0.46).persistence(0.78).interpolation(0)).set(new TG.Normalize());
	      var blur = new TG.Texture(size, size); // the texture the samples are put onto

	      for (var i = 0; i <= numSamples; i++) {
	        var sample = new TG.Texture(size, size).set(new TG.PutTexture(base)) // copy the base texture, so that it doesn't get modified
	        .set(new TG.Transform().scale(1 + 0.01 * i, 1 + 0.01 * i).angle(0.5 * i)); // modify the texture a bit more with each sample

	        blur.add(new TG.PutTexture(sample)); // adding the transformed sample to the result
	      }

	      blur.set(new TG.Normalize()) // since the samples are not weighted, put everything in the visible range
	      .mul(new TG.PutTexture(vignette)); // adding the predefined vignette-effect

	      base.toCanvas(); // since we copied the base texture instead of modifying it directly, we can still use it how it was before

	      var texture = blur.toCanvas();
	      return texture;
	    }); //----

	    examples.push(function (size) {
	      var subDim = Math.floor(size / 4); // generate a smaller image so it can be mirrored later

	      var pixel = new TG.Texture(subDim, subDim).set(new TG.FractalNoise().baseFrequency(subDim / 15).octaves(1).amplitude(1)) // generating a noise pattern with 15 pixels per length
	      .set(new TG.GradientMap().interpolation(0) // divide the generated values into defined colors
	      .point(0, [250, 230, 210]) //[ 251, 255, 228 ] (alternative colors)
	      .point(0.2, [255, 92, 103]) //[ 130, 198, 184 ]
	      .point(0.4, [200, 15, 17]) //[ 42, 166, 137 ]
	      .point(0.6, [140, 49, 59]) //[ 58, 131, 114 ]
	      .point(0.8, [35, 10, 12]) //[ 4, 46, 27 ]
	      .point(1, [0, 0, 0])).div(new TG.Number().tint(255, 255, 255)); // converting the 0-255 defined colors to the 0-1 space

	      var mirrored = new TG.Texture(size, size).add(new TG.PutTexture(pixel).repeat(2)) // repeat the texture to get a cool mirrored pattern effect
	      .mul(new TG.PutTexture(vignette).tint(1.2, 1.2, 1.2)); // adding the vignette from the example above

	      var texture = mirrored.toCanvas();
	      return texture;
	    });

	    function generateTexture(a) {
	      if (a >= examples.length) return;
	      container.appendChild(examples[a](256));
	      setTimeout(function () {
	        generateTexture(a + 1);
	      });
	    }
	    setTimeout(function () {
	      generateTexture(0);
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	/**
	 * 工具菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class ToolMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleTextureGenerator = this.handleTextureGenerator.bind(this);
	    this.handleArrangeMap = this.handleArrangeMap.bind(this);
	    this.handleArrangeMesh = this.handleArrangeMesh.bind(this);
	    this.handleArrangeThumbnail = this.handleArrangeThumbnail.bind(this);
	    this.handleCleanUpScenes = this.handleCleanUpScenes.bind(this);
	    this.commitCleanUpScenes = this.commitCleanUpScenes.bind(this);
	    this.handleExportEditor = this.handleExportEditor.bind(this);
	    this.handleExportExamples = this.handleExportExamples.bind(this);
	  }

	  render() {
	    return React.createElement(MenuItem, {
	      title: _t('Tool')
	    }, React.createElement(MenuItem, {
	      title: _t('Texture Generator'),
	      onClick: this.handleTextureGenerator
	    }), React.createElement(MenuItemSeparator, null), React.createElement(MenuItem, {
	      title: _t('Arrange Map'),
	      show: app.debug === true,
	      onClick: this.handleArrangeMap
	    }), React.createElement(MenuItem, {
	      title: _t('Arrange Mesh'),
	      show: app.debug === true,
	      onClick: this.handleArrangeMesh
	    }), React.createElement(MenuItem, {
	      title: _t('Arrange Thumbnail'),
	      show: app.debug === true,
	      onClick: this.handleArrangeThumbnail
	    }), React.createElement(MenuItem, {
	      title: _t('Clean Up Scenes'),
	      onClick: this.handleCleanUpScenes
	    }), React.createElement(MenuItemSeparator, null), React.createElement(MenuItem, {
	      title: _t('Export Editor'),
	      onClick: this.handleExportEditor
	    }), React.createElement(MenuItem, {
	      title: _t('Export Examples'),
	      onClick: this.handleExportExamples
	    }));
	  }

	  handleTextureGenerator() {
	    app.require('TexGen').then(() => {
	      const win = app.createElement(TextureGeneratorWindow);
	      app.addElement(win);
	    });
	  }

	  handleArrangeMap() {
	    app.confirm({
	      title: _t('Query'),
	      content: _t('Organizing the texture will remove the number and underscore after the name, regenerate the data table and texture catalog, remove the empty folder and unreferenced texture file, the system will automatically back up the data table and texture catalog, is it organized?'),
	      onOK: () => {
	        fetch(`${app.options.server}/api/ArrangeMap/Run`, {
	          method: 'POST'
	        }).then(response => {
	          if (response.ok) {
	            response.json().then(json => {
	              app.toast(_t(json.Msg));
	            });
	          }
	        });
	      }
	    });
	  }

	  handleArrangeMesh() {
	    app.confirm({
	      title: _t('Query'),
	      content: _t('Organizing the model will remove the number and underscore after the name, regenerate the data table, model catalog, remove empty folders and unreferenced model files, the system will automatically back up the data table, model catalog, whether to sort?'),
	      onOK: () => {
	        fetch(`${app.options.server}/api/ArrangeMesh/Run`, {
	          method: 'POST'
	        }).then(response => {
	          if (response.ok) {
	            response.json().then(json => {
	              app.toast(_t(json.Msg));
	            });
	          }
	        });
	      }
	    });
	  }

	  handleArrangeThumbnail() {
	    app.confirm({
	      title: _t('Query'),
	      content: _t('Organizing the thumbnails will regenerate the thumbnail directory, modify the scene, model, texture, material, audio, animation, particles, preset body, and the thumbnail path of the characters. Please manually back up the database first.'),
	      onOK: () => {
	        fetch(`${app.options.server}/api/ArrangeThumbnail/Run`, {
	          method: 'POST'
	        }).then(response => {
	          if (response.ok) {
	            response.json().then(json => {
	              app.toast(_t(json.Msg));
	            });
	          }
	        });
	      }
	    });
	  }

	  handleCleanUpScenes() {
	    app.confirm({
	      title: _t('Clean Up Scenes'),
	      content: _t('Are you sure to clean up all the deleted scenes and scene histories?'),
	      onOK: this.commitCleanUpScenes
	    });
	  }

	  commitCleanUpScenes() {
	    fetch(`/api/CleanUpScenes/Run`, {
	      method: 'POST'
	    }).then(response => {
	      response.json().then(json => {
	        app.toast(_t(json.Msg));
	      });
	    });
	  }

	  handleExportEditor() {
	    app.confirm({
	      title: _t('Query'),
	      content: _t('Are you sure to export the editor?'),
	      onOK: () => {
	        fetch(`${app.options.server}/api/ExportEditor/Run`, {
	          method: 'POST'
	        }).then(response => {
	          if (response.ok) {
	            response.json().then(json => {
	              app.toast(_t(json.Msg));
	              window.open(`${app.options.server}${json.Url}`, 'export');
	            });
	          }
	        });
	      }
	    });
	  }

	  handleExportExamples() {
	    app.confirm({
	      title: _t('Query'),
	      content: _t('Are you sure to export all the examples?'),
	      onOK: () => {
	        app.mask();
	        fetch(`${app.options.server}/api/ExportExamples/Run`, {
	          method: 'POST'
	        }).then(response => {
	          app.unmask();

	          if (response.ok) {
	            response.json().then(json => {
	              app.toast(_t(json.Msg));
	              window.open(`${app.options.server}${json.Url}`, 'export');
	            });
	          }
	        });
	      }
	    });
	  }

	}

	/**
	 * 渲染器窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class RendererPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.shadowMapType = {
	      [-1]: _t('Disabled'),
	      [THREE.BasicShadowMap]: _t('Basic Shadow'),
	      // 0
	      [THREE.PCFShadowMap]: _t('PCF Shadow'),
	      // 1
	      [THREE.PCFSoftShadowMap]: _t('PCF Soft Shadow') // 2

	    };
	    this.state = {
	      shadowMapType: -1,
	      gammaInput: false,
	      gammaOutput: false,
	      gammaFactor: 0
	    };
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      shadowMapType,
	      gammaInput,
	      gammaOutput,
	      gammaFactor
	    } = this.state;
	    return React.createElement(Form, {
	      className: 'RendererPanel'
	    }, React.createElement(FormControl, null, React.createElement(Label, null, _t('Shadow')), React.createElement(Select, {
	      options: this.shadowMapType,
	      name: 'shadowMapType',
	      value: shadowMapType,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Gamma Input')), React.createElement(CheckBox, {
	      name: 'gammaInput',
	      checked: gammaInput,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Gamma Output')), React.createElement(CheckBox, {
	      name: 'gammaOutput',
	      checked: gammaOutput,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Gamma Factor')), React.createElement(Input, {
	      type: 'number',
	      name: 'gammaFactor',
	      value: gammaFactor,
	      onChange: this.handleChange
	    })));
	  }

	  componentDidMount() {
	    app.on(`rendererChanged.RendererPanel`, this.handleUpdate);
	  }

	  handleUpdate() {
	    const renderer = app.editor.renderer;
	    this.setState({
	      shadowMapType: renderer.shadowMap.enabled ? renderer.shadowMap.type : -1,
	      gammaInput: renderer.gammaInput,
	      gammaOutput: renderer.gammaOutput,
	      gammaFactor: renderer.gammaFactor
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    let renderer = app.editor.renderer;
	    const {
	      shadowMapType,
	      gammaInput,
	      gammaOutput,
	      gammaFactor
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });

	    if (shadowMapType === '-1') {
	      renderer.shadowMap.enabled = false;
	    } else {
	      renderer.shadowMap.enabled = true;
	      renderer.shadowMap.type = parseInt(shadowMapType);
	    }

	    renderer.gammaInput = gammaInput;
	    renderer.gammaOutput = gammaOutput;
	    renderer.gammaFactor = gammaFactor;
	    renderer.dispose();
	    Object.assign(app.options, {
	      shadowMapType,
	      gammaInput,
	      gammaOutput,
	      gammaFactor
	    });
	    app.call(`rendererChanged`, this);
	  }

	}

	/**
	 * 帮助选项窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class HelperPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      showGrid: false,
	      showCamera: false,
	      showPointLight: false,
	      showDirectionalLight: false,
	      showSpotLight: false,
	      showHemisphereLight: false,
	      showRectAreaLight: false,
	      showSkeleton: false
	    };
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      showGrid,
	      showCamera,
	      showPointLight,
	      showDirectionalLight,
	      showSpotLight,
	      showHemisphereLight,
	      showRectAreaLight,
	      showSkeleton
	    } = this.state;
	    return React.createElement(Form, {
	      className: 'HelperPanel'
	    }, React.createElement(FormControl, null, React.createElement(Label, null, _t('Grid')), React.createElement(CheckBox, {
	      name: 'showGrid',
	      checked: showGrid,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Camera')), React.createElement(CheckBox, {
	      name: 'showCamera',
	      checked: showCamera,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Point Light')), React.createElement(CheckBox, {
	      name: 'showPointLight',
	      checked: showPointLight,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Directional Light')), React.createElement(CheckBox, {
	      name: 'showDirectionalLight',
	      checked: showDirectionalLight,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Spot Light')), React.createElement(CheckBox, {
	      name: 'showSpotLight',
	      checked: showSpotLight,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Hemisphere Light')), React.createElement(CheckBox, {
	      name: 'showHemisphereLight',
	      checked: showHemisphereLight,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Rect Area Light')), React.createElement(CheckBox, {
	      name: 'showRectAreaLight',
	      checked: showRectAreaLight,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Skeleton')), React.createElement(CheckBox, {
	      name: 'showSkeleton',
	      checked: showSkeleton,
	      onChange: this.handleChange
	    })));
	  }

	  handleUpdate() {
	    this.setState({
	      showGrid: app.storage.get('showGrid') === true,
	      showCamera: app.storage.get('showCamera') === true,
	      showPointLight: app.storage.get('showPointLight') === true,
	      showDirectionalLight: app.storage.get('showDirectionalLight') === true,
	      showSpotLight: app.storage.get('showSpotLight') === true,
	      showHemisphereLight: app.storage.get('showHemisphereLight') === true,
	      showRectAreaLight: app.storage.get('showRectAreaLight') === true,
	      showSkeleton: app.storage.get('showSkeleton') === true
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      showGrid,
	      showCamera,
	      showPointLight,
	      showDirectionalLight,
	      showSpotLight,
	      showHemisphereLight,
	      showRectAreaLight,
	      showSkeleton
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });

	    if (showGrid !== app.storage.get('showGrid')) {
	      app.storage.set('showGrid', showGrid);
	      app.call(`storageChanged`, this, 'showGrid', showGrid);
	    }

	    if (showCamera !== app.storage.get('showCamera')) {
	      app.storage.set('showCamera', showCamera);
	      app.call(`storageChanged`, this, 'showCamera', showCamera);
	    }

	    if (showPointLight !== app.storage.get('showPointLight')) {
	      app.storage.set('showPointLight', showPointLight);
	      app.call(`storageChanged`, this, 'showPointLight', showPointLight);
	    }

	    if (showDirectionalLight !== app.storage.get('showDirectionalLight')) {
	      app.storage.set('showDirectionalLight', showDirectionalLight);
	      app.call(`storageChanged`, this, 'showDirectionalLight', showDirectionalLight);
	    }

	    if (showSpotLight !== app.storage.get('showSpotLight')) {
	      app.storage.set('showSpotLight', showSpotLight);
	      app.call(`storageChanged`, this, 'showSpotLight', showSpotLight);
	    }

	    if (showHemisphereLight !== app.storage.get('showHemisphereLight')) {
	      app.storage.set('showHemisphereLight', showHemisphereLight);
	      app.call(`storageChanged`, this, 'showHemisphereLight', showHemisphereLight);
	    }

	    if (showRectAreaLight !== app.storage.get('showRectAreaLight')) {
	      app.storage.set('showRectAreaLight', showRectAreaLight);
	      app.call(`storageChanged`, this, 'showRectAreaLight', showRectAreaLight);
	    }

	    if (showSkeleton !== app.storage.get('showSkeleton')) {
	      app.storage.set('showSkeleton', showSkeleton);
	      app.call(`storageChanged`, this, 'showSkeleton', showSkeleton);
	    }

	    this.handleUpdate();
	  }

	}

	/**
	 * 滤镜选项窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class FilterPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      hueRotate: 0,
	      saturate: 0,
	      brightness: 0,
	      blur: 0,
	      contrast: 0,
	      grayscale: 0,
	      invert: 0,
	      sepia: 0
	    };
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      hueRotate,
	      saturate,
	      brightness,
	      blur,
	      contrast,
	      grayscale,
	      invert,
	      sepia
	    } = this.state;
	    return React.createElement(Form, {
	      className: 'FilterPanel'
	    }, React.createElement(FormControl, null, React.createElement(Label, null, _t('HueRotate')), React.createElement(Input, {
	      type: 'number',
	      name: 'hueRotate',
	      value: hueRotate,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Saturate')), React.createElement(Input, {
	      type: 'number',
	      name: 'saturate',
	      value: saturate,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Brightness')), React.createElement(Input, {
	      type: 'number',
	      name: 'brightness',
	      value: brightness,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Blur')), React.createElement(Input, {
	      type: 'number',
	      name: 'blur',
	      value: blur,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Contrast')), React.createElement(Input, {
	      type: 'number',
	      name: 'contrast',
	      value: contrast,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Grayscale')), React.createElement(Input, {
	      type: 'number',
	      name: 'grayscale',
	      value: grayscale,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Invert')), React.createElement(Input, {
	      type: 'number',
	      name: 'invert',
	      value: invert,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Sepia')), React.createElement(Input, {
	      type: 'number',
	      name: 'sepia',
	      value: sepia,
	      onChange: this.handleChange
	    })));
	  }

	  handleUpdate() {
	    const renderer = app.editor.renderer;
	    const {
	      hueRotate,
	      saturate,
	      brightness,
	      blur,
	      contrast,
	      grayscale,
	      invert,
	      sepia
	    } = CssUtils.parseFilter(renderer.domElement.style.filter);
	    this.setState({
	      hueRotate,
	      saturate,
	      brightness,
	      blur,
	      contrast,
	      grayscale,
	      invert,
	      sepia
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      hueRotate,
	      saturate,
	      brightness,
	      blur,
	      contrast,
	      grayscale,
	      invert,
	      sepia
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    const filters = {
	      hueRotate,
	      saturate,
	      brightness,
	      blur,
	      contrast,
	      grayscale,
	      invert,
	      sepia
	    };
	    Object.assign(app.options, filters);
	    const renderer = app.editor.renderer;
	    renderer.domElement.style.filter = CssUtils.serializeFilter(filters);
	    this.handleUpdate();
	  }

	}

	/**
	 * 选项窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class OptionsWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.rendererRef = React.createRef();
	    this.helperRef = React.createRef();
	    this.filterRef = React.createRef();
	    this.state = {
	      activeTabIndex: props.activeTabIndex
	    };
	    this.handleClose = this.handleClose.bind(this);
	    this.handleActiveTabChange = this.handleActiveTabChange.bind(this);
	  }

	  render() {
	    const {
	      activeTabIndex
	    } = this.state;
	    return React.createElement(Window, {
	      className: 'OptionsWindow',
	      title: _t('Settings'),
	      style: {
	        width: '300px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, React.createElement(Content, null, React.createElement(TabLayout, {
	      className: 'tab',
	      activeTabIndex: activeTabIndex,
	      onActiveTabChange: this.handleActiveTabChange
	    }, React.createElement(RendererPanel, {
	      title: _t('Renderer'),
	      ref: this.rendererRef
	    }), React.createElement(HelperPanel, {
	      title: _t('Helpers'),
	      ref: this.helperRef
	    }), React.createElement(FilterPanel, {
	      title: _t('Filter'),
	      ref: this.filterRef
	    }))), React.createElement(Buttons, null, React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Close'))));
	  }

	  componentDidMount() {
	    const {
	      activeTabIndex
	    } = this.state;
	    this.handleActiveTabChange(activeTabIndex);
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	  handleActiveTabChange(index) {
	    const rendererTab = this.rendererRef.current;
	    const helperTab = this.helperRef.current;
	    const filterTab = this.filterRef.current;

	    switch (index) {
	      case 0:
	        rendererTab.handleUpdate();
	        break;

	      case 1:
	        helperTab.handleUpdate();
	        break;

	      case 2:
	        filterTab.handleUpdate();
	        break;
	    }

	    this.setState({
	      activeTabIndex: index
	    });
	  }

	}

	OptionsWindow.propTypes = {
	  activeTabIndex: propTypes.number,
	  onActiveTabChange: propTypes.func
	};
	OptionsWindow.defaultProps = {
	  activeTabIndex: 0,
	  onActiveTabChange: null
	};

	/**
	 * 选项菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class OptionsMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {};
	    this.handleRendererOptions = this.handleRendererOptions.bind(this);
	    this.handleHelperOptions = this.handleHelperOptions.bind(this);
	    this.handleFilterOptions = this.handleFilterOptions.bind(this);
	    this.handleChangeEnglish = this.handleChangeEnglish.bind(this);
	    this.handleChangeChinese = this.handleChangeChinese.bind(this);
	    this.handleEnableDebugMode = this.handleEnableDebugMode.bind(this);
	    this.handleDisableDebugMode = this.handleDisableDebugMode.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    return React.createElement(MenuItem, {
	      title: _t('Options')
	    }, React.createElement(MenuItem, {
	      title: _t('Renderer'),
	      onClick: this.handleRendererOptions
	    }), React.createElement(MenuItem, {
	      title: _t('Helpers'),
	      onClick: this.handleHelperOptions
	    }), React.createElement(MenuItem, {
	      title: _t('Filter'),
	      onClick: this.handleFilterOptions
	    }), React.createElement(MenuItemSeparator, null), React.createElement(MenuItem, {
	      title: _t('Language')
	    }, React.createElement(MenuItem, {
	      title: 'English',
	      onClick: this.handleChangeEnglish
	    }), React.createElement(MenuItem, {
	      title: '简体中文',
	      onClick: this.handleChangeChinese
	    }), React.createElement(MenuItem, {
	      title: '繁體中文',
	      onClick: this.handleChangeTraditionalChinese
	    }), React.createElement(MenuItem, {
	      title: '日本語',
	      onClick: this.handleChangeJapanese
	    }), React.createElement(MenuItem, {
	      title: '한국어',
	      onClick: this.handleChangeKorean
	    }), React.createElement(MenuItem, {
	      title: 'русский',
	      onClick: this.handleChangeRussian
	    }), React.createElement(MenuItem, {
	      title: 'Le français',
	      onClick: this.handleChangeFrench
	    })), React.createElement(MenuItem, {
	      title: _t('Debug Mode')
	    }, React.createElement(MenuItem, {
	      title: _t('Enable'),
	      onClick: this.handleEnableDebugMode
	    }), React.createElement(MenuItem, {
	      title: _t('Disable'),
	      onClick: this.handleDisableDebugMode
	    })));
	  } // ---------------------------------- 渲染器选项 -------------------------------------


	  handleRendererOptions() {
	    let win = app.createElement(OptionsWindow, {
	      activeTabIndex: 0
	    });
	    app.addElement(win);
	  } // ------------------------------- 帮助器选项 -----------------------------------------


	  handleHelperOptions() {
	    let win = app.createElement(OptionsWindow, {
	      activeTabIndex: 1
	    });
	    app.addElement(win);
	  } // ------------------------------ 滤镜选项 ---------------------------------------------


	  handleFilterOptions() {
	    let win = app.createElement(OptionsWindow, {
	      activeTabIndex: 2
	    });
	    app.addElement(win);
	  } // ---------------------------- 语言选项 -------------------------------------------------


	  handleChangeEnglish() {
	    // 英语
	    window.localStorage.setItem('lang', 'en-US');
	    window.location.reload();
	  }

	  handleChangeChinese() {
	    // 简体中文
	    window.localStorage.setItem('lang', 'zh-CN');
	    window.location.reload();
	  }

	  handleChangeTraditionalChinese() {
	    // 繁体中文
	    window.localStorage.setItem('lang', 'zh-TW');
	    window.location.reload();
	  }

	  handleChangeJapanese() {
	    // 日语
	    window.localStorage.setItem('lang', 'ja-JP');
	    window.location.reload();
	  }

	  handleChangeKorean() {
	    window.localStorage.setItem('lang', 'ko-KR');
	    window.location.reload();
	  }

	  handleChangeRussian() {
	    window.localStorage.setItem('lang', 'ru-RU');
	    window.location.reload();
	  }

	  handleChangeFrench() {
	    window.localStorage.setItem('lang', 'fr-FR');
	    window.location.reload();
	  } // ---------------------------------- 调试模式 -------------------------------


	  handleEnableDebugMode() {
	    app.storage.set('debug', true);
	    window.location.reload();
	  }

	  handleDisableDebugMode() {
	    app.storage.set('debug', false);
	    window.location.reload();
	  }

	}

	/**
	 * 渲染器属性窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class RendererrAttributesWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      alpha: false,
	      antialias: true,
	      depth: true,
	      desynchronized: false,
	      failIfMajorPerformanceCaveat: false,
	      powerPreference: 'default',
	      premultipliedAlpha: true,
	      preserveDrawingBuffer: false,
	      stencil: true
	    };
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const state = this.state;
	    return React.createElement(Window, {
	      className: 'RendererrAttributesWindow',
	      title: _t('Renderer Attributes'),
	      style: {
	        width: '400px',
	        height: '320px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, React.createElement(Content, null, React.createElement(Form, null, Object.keys(state).map(key => {
	      const value = state[key];
	      return React.createElement(FormControl, {
	        key: key
	      }, React.createElement(Label, null, _t(key)), React.createElement(Input, {
	        name: key,
	        value: value.toString(),
	        disabled: true
	      }));
	    }))), React.createElement(Buttons, null, React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Close'))));
	  }

	  componentDidMount() {
	    const state = app.editor.renderer.getContextAttributes();
	    this.setState(state);
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	/**
	 * 帮助菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class HelpMenu extends React.Component {
	  constructor(props) {
	    super(props);
	    this.handleRendererAttributes = this.handleRendererAttributes.bind(this);
	    this.handleSource = this.handleSource.bind(this);
	    this.handleExamples = this.handleExamples.bind(this);
	    this.handleDocuments = this.handleDocuments.bind(this);
	    this.handleAbout = this.handleAbout.bind(this);
	  }

	  render() {
	    return React.createElement(MenuItem, {
	      title: _t('Help')
	    }, React.createElement(MenuItem, {
	      title: _t('Renderer Attributes'),
	      onClick: this.handleRendererAttributes
	    }), React.createElement(MenuItemSeparator, null), React.createElement(MenuItem, {
	      title: _t('Source'),
	      onClick: this.handleSource
	    }), React.createElement(MenuItem, {
	      title: _t('Examples'),
	      onClick: this.handleExamples
	    }), React.createElement(MenuItem, {
	      title: _t('Documents'),
	      onClick: this.handleDocuments
	    }), React.createElement(MenuItem, {
	      title: _t('About'),
	      onClick: this.handleAbout
	    }));
	  }

	  handleRendererAttributes() {
	    const win = app.createElement(RendererrAttributesWindow);
	    app.addElement(win);
	  }

	  handleSource() {
	    window.open('https://github.com/tengge1/ShadowEditor', '_blank');
	  }

	  handleExamples() {
	    window.open('https://github.com/tengge1/ShadowEditor-examples', '_blank');
	  }

	  handleDocuments() {
	    window.open('https://tengge1.github.io/ShadowEditor/', '_blank');
	  }

	  handleAbout() {
	    app.alert({
	      title: _t('About'),
	      className: 'About',
	      content: React.createElement(React.Fragment, null, _t('Name'), ": ShadowEditor", React.createElement("br", null), _t('Author'), ": tengge1", React.createElement("br", null), _t('Lisense'), ": MIT", React.createElement("br", null), _t('Source'), "1: ", React.createElement("a", {
	        href: "https://github.com/tengge1/ShadowEditor",
	        target: "_blank"
	      }, "https://github.com/tengge1/ShadowEditor"), React.createElement("br", null), _t('Source'), "2: ", React.createElement("a", {
	        href: "https://gitee.com/tengge1/ShadowEditor",
	        target: "_blank"
	      }, "https://gitee.com/tengge1/ShadowEditor"), React.createElement("br", null))
	    });
	  }

	}

	/**
	 * 状态菜单
	 * @author tengge / https://github.com/tengge1
	 */

	class StatusMenu extends React.Component {
	  constructor(props) {
	    super(props);
	  }

	  render() {
	    return React.createElement(MenuItem, {
	      title: `r${THREE.REVISION}`
	    });
	  }

	}

	/**
	 * 编辑器菜单栏
	 * @author tengge / https://github.com/tengge1
	 */

	class EditorMenuBar extends React.Component {
	  render() {
	    const {
	      className
	    } = this.props;
	    return React.createElement(MenuBar, {
	      className: bind('EditorMenuBar', className)
	    }, React.createElement(SceneMenu, null), React.createElement(EditMenu, null), React.createElement(TwoDMenu, null), React.createElement(GeometryMenu, null), React.createElement(LightMenu, null), React.createElement(AssetsMenu, null), React.createElement(ComponentMenu, null), React.createElement(PlayMenu, null), React.createElement(ToolMenu, null), React.createElement(OptionsMenu, null), React.createElement(HelpMenu, null), React.createElement(MenuItemSeparator, {
	      direction: 'horizontal'
	    }), React.createElement(MenuBarFiller, null), React.createElement(StatusMenu, null));
	  }

	}

	/**
	 * canvas转DataURL
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {*} canvas 画布
	 * @param {*} type 图片类型 image/png或image/jpeg
	 * @param {*} quality jpeg图片质量
	 */
	function canvasToDataURL(canvas, type = 'image/png', quality = 0.8) {
	  if (type.toLowerCase() === 'image/png') {
	    return canvas.toDataURL(type);
	  } else {
	    return canvas.toDataURL(type, quality);
	  }
	}
	/**
	 * Blob转DataURL
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {*} blob Blob对象
	 */


	function blobToDataURL(blob) {
	  var reader = new FileReader();
	  return new Promise(resolve => {
	    reader.onload = e => {
	      resolve(e.target.result);
	    };

	    reader.readAsDataURL(blob);
	  });
	}
	/**
	 * 文件转DataURL
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {*} file 文件
	 */


	function fileToDataURL(file) {
	  return blobToDataURL(file);
	}
	/**
	 * DataURL转Blob
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {*} dataURL 
	 */


	function dataURLToBlob(dataURL) {
	  var array = dataURL.split(',');
	  var mimeType = array[0].match(/:(.*?);/)[1];
	  var binaryString = atob(array[1]);
	  var length = binaryString.length;
	  var uint8Array = new Uint8Array(length);

	  while (length--) {
	    uint8Array[length] = binaryString.charCodeAt(length);
	  }

	  return new Blob([uint8Array], {
	    type: mimeType
	  });
	}
	/**
	 * DataURL转File
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {*} dataURL 
	 * @param {*} filename 文件名
	 */


	function dataURLtoFile(dataURL, filename) {
	  var array = dataURL.split(',');
	  var mimeType = array[0].match(/:(.*?);/)[1];
	  var binaryString = atob(array[1]);
	  var length = binaryString.length;
	  var uint8Array = new Uint8Array(length);

	  while (length--) {
	    uint8Array[length] = binaryString.charCodeAt(length);
	  }

	  if (mimeType === 'image/jpeg') {
	    filename = filename + '.jpg';
	  } else if (mimeType === 'image/png') {
	    filename = filename + '.png';
	  } else {
	    console.warn(`Converter: not supported mime-type: ${mimeType}.`);
	  }

	  return new File([uint8Array], filename, {
	    type: mimeType
	  });
	}
	/**
	 * DataURL转图片
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {*} dataURL 
	 */


	function dataURLToImage(dataURL) {
	  var image = new Image();
	  return new Promise(resolve => {
	    image.onload = () => {
	      image.onload = null;
	      image.onerror = null;
	      resolve(image);
	    };

	    image.onerror = () => {
	      image.onload = null;
	      image.onerror = null;
	      resolve(null);
	    };

	    image.src = dataURL;
	  });
	}
	/**
	 * Blob转图片
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {*} blob 
	 */


	function BlobToImage(blob) {
	  return new Promise(resolve => {
	    blobToDataURL(blob).then(dataURL => {
	      dataURLToImage(dataURL).then(image => {
	        resolve(image);
	      });
	    });
	  });
	}
	/**
	 * 文件转图片
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {*} file 文件
	 */


	function FileToImage(file) {
	  return BlobToImage(file);
	}
	/**
	 * 图片转画布
	 * @author cuixiping / https://blog.csdn.net/cuixiping/article/details/45932793
	 * @param {*} image 图片
	 */


	function ImageToCanvas(image) {
	  var canvas = document.createElement('canvas');
	  canvas.width = image.width;
	  canvas.height = image.height;
	  var context = canvas.getContext('2d');
	  context.drawImage(image, 0, 0);
	  return canvas;
	}
	/**
	 * 画布转图片
	 * @param {*} canvas 画布
	 * @param {*} type 类型
	 * @param {*} quality jpeg图片质量
	 */


	function CanvasToImage(canvas, type = 'image/png', quality = 0.8) {
	  var image = new Image();

	  if (type === 'image/jpeg') {
	    image.src = canvas.toDataURL('image/jpeg', quality);
	  } else {
	    image.src = canvas.toDataURL('image/png');
	  }

	  return image;
	}
	/**
	 * 类型转换工具
	 * @author tengge / https://github.com/tengge1
	 */


	const Converter$1 = {
	  canvasToDataURL: canvasToDataURL,
	  blobToDataURL: blobToDataURL,
	  fileToDataURL: fileToDataURL,
	  dataURLToBlob: dataURLToBlob,
	  dataURLtoFile: dataURLtoFile,
	  dataURLToImage: dataURLToImage,
	  BlobToImage: BlobToImage,
	  FileToImage: FileToImage,
	  imageToCanvas: ImageToCanvas,
	  canvasToImage: CanvasToImage
	};

	/**
	 * 时间工具
	 * @author tengge / https://github.com/tengge1
	 */
	const TimeUtils = {
	  getDateTime: function (format = 'yyyyMMddHHmmss') {
	    let date = new Date();
	    let year = date.getFullYear();
	    let month = `00${date.getMonth() + 1}`;
	    let day = `00${date.getDate()}`;
	    let hour = `00${date.getHours()}`;
	    let minute = `00${date.getMinutes()}`;
	    let second = `00${date.getSeconds()}`;
	    month = month.substr(month.length - 2, 2);
	    day = day.substr(day.length - 2, 2);
	    hour = hour.substr(hour.length - 2, 2);
	    minute = minute.substr(minute.length - 2, 2);
	    second = second.substr(second.length - 2, 2);
	    return format.replace('yyyy', year).replace('MM', month).replace('dd', day).replace('HH', hour).replace('mm', minute).replace('ss', second);
	  }
	};

	/**
	 * 视频录制器
	 * @author tengge / https://github.com/tengge1
	 */

	class VideoRecorder {
	  constructor() {
	    this.chunks = [];
	    this.recorder = null;
	    this.onDataAvailable = this.onDataAvailable.bind(this);
	  }

	  start() {
	    if (!navigator.mediaDevices) {
	      app.toast(`Record is not supported!`);
	      return new Promise(resolve => {
	        resolve(false);
	      });
	    }

	    return new Promise(resolve => {
	      navigator.mediaDevices.getDisplayMedia().then(stream => {
	        this.recorder = new MediaRecorder(stream);
	        this.recorder.ondataavailable = this.onDataAvailable;
	        this.recorder.start();
	        resolve(true);
	      }).catch(err => {
	        app.toast(err);
	        resolve(false);
	      });
	    });
	  }

	  stop() {
	    return new Promise(resolve => {
	      this.recorder.onstop = e => {
	        this.recorder.ondataavailable = null;
	        this.recorder.onstop = null;
	        const file = new File(this.chunks, TimeUtils.getDateTime() + '.webm');
	        let form = new FormData();
	        form.append('file', file);
	        fetch(`/api/Video/Add`, {
	          method: 'POST',
	          body: form
	        }).then(response => {
	          response.json().then(json => {
	            app.toast(_t(json.Msg));

	            if (json.Code === 200) {
	              this.chunks.length = 0;
	            }

	            resolve(true);
	          });
	        });
	      };

	      this.recorder.stop();
	    }).catch(() => {
	      resolve(false);
	    });
	  }

	  onDataAvailable(e) {
	    this.chunks.push(e.data);
	  }

	}

	/**
	 * 状态栏
	 * @author tengge / https://github.com/tengge1
	 */

	class EditorStatusBar extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      objects: 0,
	      vertices: 0,
	      triangles: 0,
	      showStats: app.storage.get('showStats') === undefined ? true : app.storage.get('showStats'),
	      showGrid: app.storage.get('showGrid') === undefined ? true : app.storage.get('showGrid'),
	      showViewHelper: app.storage.get('showViewHelper') === undefined ? true : app.storage.get('showViewHelper'),
	      isThrowBall: false,
	      isRecording: false
	    };
	    this.handleShowStats = this.handleShowStats.bind(this);
	    this.handleShowGrid = this.handleShowGrid.bind(this);
	    this.handleShowViewHelper = this.handleShowViewHelper.bind(this);
	    this.handleEnableThrowBall = this.handleEnableThrowBall.bind(this);
	    this.handleScreenshot = this.handleScreenshot.bind(this);
	    this.commitScreenshot = this.commitScreenshot.bind(this);
	    this.handleRecord = this.handleRecord.bind(this);
	  }

	  render() {
	    const {
	      objects,
	      vertices,
	      triangles,
	      showStats,
	      showGrid,
	      showViewHelper,
	      isThrowBall,
	      isRecording
	    } = this.state;
	    return React.createElement(Toolbar, {
	      className: 'EditorStatusBar'
	    }, React.createElement(Label, null, _t('Object')), React.createElement(Label, null, objects), React.createElement(Label, null, _t('Vertex')), React.createElement(Label, null, vertices), React.createElement(Label, null, _t('Triangle')), React.createElement(Label, null, triangles), React.createElement(ToolbarSeparator, null), React.createElement(Label, null, _t('Show Stats')), React.createElement(CheckBox, {
	      checked: showStats,
	      onChange: this.handleShowStats
	    }), React.createElement(Label, null, _t('Grid')), React.createElement(CheckBox, {
	      checked: showGrid,
	      onChange: this.handleShowGrid
	    }), React.createElement(Label, null, _t('View Helper')), React.createElement(CheckBox, {
	      checked: showViewHelper,
	      onChange: this.handleShowViewHelper
	    }), React.createElement(Label, null, _t('ThrowBall')), React.createElement(CheckBox, {
	      checked: isThrowBall,
	      onChange: this.handleEnableThrowBall
	    }), React.createElement(ToolbarSeparator, null), React.createElement(Button, {
	      onClick: this.handleScreenshot
	    }, _t('Screenshot')), React.createElement(Button, {
	      onClick: this.handleRecord
	    }, isRecording ? _t('Stop') : _t('Record')));
	  }

	  componentDidMount() {
	    app.on('objectAdded.' + this.id, this.onUpdateInfo.bind(this));
	    app.on('objectRemoved.' + this.id, this.onUpdateInfo.bind(this));
	    app.on('geometryChanged.' + this.id, this.onUpdateInfo.bind(this));
	  }

	  onUpdateInfo() {
	    var editor = app.editor;
	    var scene = editor.scene;
	    var objects = 0,
	        vertices = 0,
	        triangles = 0;

	    for (var i = 0, l = scene.children.length; i < l; i++) {
	      var object = scene.children[i];
	      object.traverseVisible(function (object) {
	        objects++;

	        if (object instanceof THREE.Mesh) {
	          var geometry = object.geometry;

	          if (geometry instanceof THREE.Geometry) {
	            vertices += geometry.vertices.length;
	            triangles += geometry.faces.length;
	          } else if (geometry instanceof THREE.BufferGeometry) {
	            if (geometry.index !== null) {
	              vertices += geometry.index.count * 3;
	              triangles += geometry.index.count;
	            } else if (geometry.attributes.position) {
	              vertices += geometry.attributes.position.count;
	              triangles += geometry.attributes.position.count / 3;
	            }
	          }
	        }
	      });
	    }

	    this.setState({
	      objects: objects.format(),
	      vertices: vertices.format(),
	      triangles: triangles.format()
	    });
	  }

	  handleShowStats() {
	    const showStats = !app.storage.get('showStats');
	    app.storage.set('showStats', showStats);
	    Object.assign(app.stats.dom.style, {
	      display: showStats ? 'block' : 'none'
	    });
	    this.setState({
	      showStats
	    });
	  }

	  handleShowGrid(showGrid) {
	    if (showGrid !== app.storage.get('showGrid')) {
	      app.storage.set('showGrid', showGrid);
	      app.call(`storageChanged`, this, 'showGrid', showGrid);
	      this.setState({
	        showGrid
	      });
	    }
	  }

	  handleShowViewHelper() {
	    const showViewHelper = !app.storage.get('showViewHelper');
	    app.storage.set('showViewHelper', showViewHelper);
	    app.call(`storageChanged`, this, 'showViewHelper', showViewHelper);
	    this.setState({
	      showViewHelper
	    });
	  }

	  handleEnableThrowBall(checked) {
	    app.call('enableThrowBall', this, checked);
	  }

	  handleScreenshot() {
	    app.on(`afterRender.Screenshot`, this.commitScreenshot);
	  }

	  commitScreenshot() {
	    app.on(`afterRender.Screenshot`, null);
	    const canvas = app.editor.renderer.domElement;
	    const dataUrl = Converter$1.canvasToDataURL(canvas);
	    const file = Converter$1.dataURLtoFile(dataUrl, TimeUtils.getDateTime());
	    let form = new FormData();
	    form.append('file', file);
	    fetch(`/api/Screenshot/Add`, {
	      method: 'POST',
	      body: form
	    }).then(response => {
	      response.json().then(json => {
	        app.toast(_t(json.Msg));
	      });
	    });
	  }

	  handleRecord() {
	    if (this.state.isRecording) {
	      this.stopRecord();
	    } else {
	      this.startRecord();
	    }
	  }

	  startRecord() {
	    if (this.recorder === undefined) {
	      this.recorder = new VideoRecorder();
	    }

	    this.recorder.start().then(success => {
	      if (success) {
	        this.setState({
	          isRecording: true
	        });
	      }
	    });
	  }

	  stopRecord() {
	    if (!this.recorder) {
	      return;
	    }

	    this.recorder.stop().then(() => {
	      this.setState({
	        isRecording: false
	      });
	    });
	  }

	}

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 * Port from https://github.com/mapbox/earcut (v2.1.2)
	 */

	var ID$a = -1;
	/**
	 * 工具基类
	 * @author tengge / https://github.com/tengge1
	 */

	function BaseTool(app) {
	  this.id = `${this.constructor.name}${ID$a--}`;
	  this.dispatch = d3.dispatch('end');
	  this.call = this.dispatch.call.bind(this.dispatch);
	  this.on = this.dispatch.on.bind(this.dispatch);
	}

	BaseTool.prototype.start = function () {};

	BaseTool.prototype.stop = function () {};

	/**
	 * 挖坑工具
	 * @param {*} app 
	 */

	function DigTool(app) {
	  BaseTool.call(this, app);
	  this.points = [];
	}

	DigTool.prototype = Object.create(BaseTool.prototype);
	DigTool.prototype.constructor = DigTool;

	DigTool.prototype.start = function () {
	  app.on(`raycast.${this.id}`, this.onRaycast.bind(this));
	  app.on(`dblclick.${this.id}`, this.onDblClick.bind(this));
	  app.on(`beforeRender.${this.id}`, this.onBeforeRender.bind(this));
	  app.on(`afterRender.${this.id}`, this.onAfterRender.bind(this));
	};

	DigTool.prototype.stop = function () {
	  app.on(`raycast.${this.id}`, null);
	  app.on(`dblclick.${this.id}`, null);
	  app.on(`beforeRender.${this.id}`, null);
	  app.on(`afterRender.${this.id}`, null);
	};

	DigTool.prototype.onRaycast = function (obj) {
	  this.points.push(obj.point);
	};

	DigTool.prototype.onDblClick = function () {
	  this.call('end');

	  if (this.scene === undefined) {
	    this.scene = new THREE.Scene();
	  }

	  var xys = this.points.map(n => {
	    return {
	      x: n.x,
	      y: n.z
	    };
	  }); // if (!THREE.ShapeUtils.isClockWise(xys)) {
	  //     this.points.reverse();
	  // }

	  var geometry = new THREE.BufferGeometry();
	  var vertices = [];
	  this.points.forEach((n, i) => {
	    vertices.push(n.x, n.y, n.z);
	  });
	  geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
	  var material = new THREE.MeshBasicMaterial();
	  material.polygonOffset = true;
	  material.polygonOffsetFactor = -1;
	  var mesh = new THREE.Mesh(geometry, material);
	  this.scene.add(mesh);
	  this.points.length = 0;
	};

	DigTool.prototype.onBeforeRender = function () {
	  if (!this.scene || this.scene.children.length === 0) {
	    return;
	  }

	  var renderer = app.editor.renderer;
	  var context = renderer.getContext();
	  var state = renderer.state;
	  state.buffers.color.setMask(false);
	  state.buffers.depth.setMask(false);
	  state.buffers.stencil.setMask(0xff);
	  state.buffers.stencil.setTest(true);
	  state.buffers.stencil.setFunc(context.ALWAYS, 1, 0xff);
	  state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.REPLACE);
	  renderer.render(this.scene, app.editor.camera);
	  state.buffers.color.setMask(0xff);
	  state.buffers.depth.setMask(0xff);
	  state.buffers.stencil.setMask(0x0);
	  state.buffers.stencil.setFunc(context.NOTEQUAL, 1, 0xff);
	};

	DigTool.prototype.onAfterRender = function () {
	  if (!this.scene || this.scene.children.length === 0) {
	    return;
	  }

	  var renderer = app.editor.renderer;
	  var context = renderer.getContext();
	  var state = renderer.state;
	  state.buffers.stencil.setMask(0xff);
	  state.buffers.stencil.setTest(false);
	  renderer.clearStencil();
	};

	/**
	 * 编辑器工具栏
	 * @author tengge / https://github.com/tengge1
	 */

	class EditorToolbar extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      mode: 'translate',
	      isAddingPoint: false,
	      isAddingLine: false,
	      isAddingPolygon: false,
	      isSpraying: false,
	      isDigging: false,
	      view: 'perspective',
	      isGridMode: false
	    };
	    this.handleEnterSelectMode = this.handleEnterSelectMode.bind(this);
	    this.handleEnterTranslateMode = this.handleEnterTranslateMode.bind(this);
	    this.handleEnterRotateMode = this.handleEnterRotateMode.bind(this);
	    this.handleEnterScaleMode = this.handleEnterScaleMode.bind(this);
	    this.handleAddPoint = this.handleAddPoint.bind(this);
	    this.handleAddLine = this.handleAddLine.bind(this);
	    this.handleAddPolygon = this.handleAddPolygon.bind(this);
	    this.handleSpray = this.handleSpray.bind(this);
	    this.handleDig = this.handleDig.bind(this);
	    this.handlePerspective = this.handlePerspective.bind(this);
	    this.handleFrontView = this.handleFrontView.bind(this);
	    this.handleSideView = this.handleSideView.bind(this);
	    this.handleTopView = this.handleTopView.bind(this);
	    this.handleGridMode = this.handleGridMode.bind(this);
	  }

	  render() {
	    const {
	      mode,
	      isAddingPoint,
	      isAddingLine,
	      isAddingPolygon,
	      isSpraying,
	      isDigging,
	      view,
	      isGridMode
	    } = this.state;
	    return React.createElement(Toolbar, {
	      className: 'EditorToolbar',
	      direction: 'vertical'
	    }, React.createElement(IconButton, {
	      icon: 'select',
	      title: _t('Select'),
	      selected: mode === 'select',
	      onClick: this.handleEnterSelectMode
	    }), React.createElement(IconButton, {
	      icon: 'translate',
	      title: _t('Translate'),
	      selected: mode === 'translate',
	      onClick: this.handleEnterTranslateMode
	    }), React.createElement(IconButton, {
	      icon: 'rotate',
	      title: _t('Rotate'),
	      selected: mode === 'rotate',
	      onClick: this.handleEnterRotateMode
	    }), React.createElement(IconButton, {
	      icon: 'scale',
	      title: _t('Scale'),
	      selected: mode === 'scale',
	      onClick: this.handleEnterScaleMode
	    }), React.createElement(ToolbarSeparator, null), React.createElement(IconButton, {
	      icon: 'point',
	      title: _t('Draw Point'),
	      selected: isAddingPoint,
	      onClick: this.handleAddPoint
	    }), React.createElement(IconButton, {
	      icon: 'line',
	      title: _t('Draw Line'),
	      selected: isAddingLine,
	      onClick: this.handleAddLine
	    }), React.createElement(IconButton, {
	      icon: 'polygon',
	      title: _t('Draw Pologon'),
	      selected: isAddingPolygon,
	      onClick: this.handleAddPolygon
	    }), React.createElement(IconButton, {
	      icon: 'spray',
	      title: _t('Spray'),
	      selected: isSpraying,
	      onClick: this.handleSpray
	    }), React.createElement(IconButton, {
	      icon: 'texture',
	      title: _t('Dig'),
	      selected: isDigging,
	      onClick: this.handleDig
	    }), React.createElement(ToolbarSeparator, null), React.createElement(ImageButton, {
	      src: 'assets/image/perspective-view.png',
	      title: _t('Perspective View'),
	      selected: view === 'perspective',
	      onClick: this.handlePerspective
	    }), React.createElement(ImageButton, {
	      src: 'assets/image/front-view.png',
	      title: _t('Front View'),
	      selected: view === 'front',
	      onClick: this.handleFrontView
	    }), React.createElement(ImageButton, {
	      src: 'assets/image/side-view.png',
	      title: _t('Side View'),
	      selected: view === 'side',
	      onClick: this.handleSideView
	    }), React.createElement(ImageButton, {
	      src: 'assets/image/top-view.png',
	      title: _t('Top View'),
	      selected: view === 'top',
	      onClick: this.handleTopView
	    }), React.createElement(IconButton, {
	      icon: 'grid',
	      title: _t('Grid Mode'),
	      selected: isGridMode,
	      onClick: this.handleGridMode
	    }));
	  } // --------------------------------- 选择模式 -------------------------------------


	  handleEnterSelectMode() {
	    this.setState({
	      mode: 'select'
	    });
	    app.call('changeMode', this, 'select');
	  } // -------------------------------- 平移模式 --------------------------------------


	  handleEnterTranslateMode() {
	    this.setState({
	      mode: 'translate'
	    });
	    app.call('changeMode', this, 'translate');
	  } // -------------------------------- 旋转模式 ---------------------------------------


	  handleEnterRotateMode() {
	    this.setState({
	      mode: 'rotate'
	    });
	    app.call('changeMode', this, 'rotate');
	  } // -------------------------------- 缩放模式 ---------------------------------------


	  handleEnterScaleMode() {
	    this.setState({
	      mode: 'scale'
	    });
	    app.call('changeMode', this, 'scale');
	  } // --------------------------------- 画点 ------------------------------------------


	  handleAddPoint() {
	    const isAddingPoint = !this.state.isAddingPoint;
	    this.setState({
	      isAddingPoint
	    });

	    if (isAddingPoint) {
	      app.on(`intersect.EditorToolbarAddPoint`, this.onAddPointIntersect.bind(this));
	    } else {
	      app.on(`intersect.EditorToolbarAddPoint`, null);
	    }
	  }

	  onAddPointIntersect(obj, event) {
	    if (event.button !== 0) {
	      return;
	    }

	    this.handleAddPoint();
	    var geometry = new THREE.CircleBufferGeometry(0.4, 32, 0, Math.PI * 2);
	    var material = new THREE.PointsMaterial({
	      color: 0xffffff * Math.random(),
	      polygonOffset: true,
	      polygonOffsetFactor: -40
	    });
	    var mesh = new THREE.Mesh(geometry, material);
	    mesh.position.copy(obj.point);
	    var normal = obj.face.normal.clone();
	    normal.transformDirection(obj.object.matrixWorld);
	    mesh.lookAt(new THREE.Vector3().addVectors(obj.point, normal));
	    mesh.name = _t('Point');
	    app.editor.execute(new AddObjectCommand(mesh));
	  } // ---------------------------------- 画线 -----------------------------------------


	  handleAddLine() {
	    if (this.hasLoadLineScript === undefined) {
	      this.hasLoadLineScript = true;

	      app.require('line').then(() => {
	        this.onAddLine();
	      });
	    } else {
	      this.onAddLine();
	    }
	  }

	  onAddLine() {
	    const isAddingLine = !this.state.isAddingLine;
	    this.setState({
	      isAddingLine
	    });

	    if (isAddingLine) {
	      app.on(`intersect.EditorToolbarAddLine`, this.onAddLineIntersect.bind(this));
	      app.on(`dblclick.EditorToolbarAddLine`, this.onAddLineDblClick.bind(this));
	      this.linePositions = [];
	      this.lineColors = [];
	      var geometry = new THREE.LineGeometry();
	      var material = new THREE.LineMaterial({
	        color: 0xffffff,
	        linewidth: 8,
	        // in pixels
	        vertexColors: THREE.VertexColors,
	        dashed: false,
	        polygonOffset: true,
	        polygonOffsetFactor: -40
	      });
	      var renderer = app.editor.renderer;
	      material.resolution.set(renderer.domElement.clientWidth, renderer.domElement.clientHeight);
	      this.line = new THREE.Line2(geometry, material);
	      this.line.name = _t('Line');
	      app.editor.execute(new AddObjectCommand(this.line));
	    } else {
	      app.on(`intersect.EditorToolbarAddLine`, null);
	      app.on(`dblclick.EditorToolbarAddLine`, null);
	      this.linePositions = null;
	      this.lineColors = null;
	      this.line = null;
	    }
	  }

	  onAddLineIntersect(obj, event) {
	    if (event.button !== 0) {
	      return;
	    }

	    this.linePositions.push(obj.point.x, obj.point.y, obj.point.z);
	    var color = new THREE.Color(0xffffff * Math.random());
	    this.lineColors.push(color.r, color.g, color.b);

	    if (this.linePositions.length < 6) {
	      return;
	    }

	    var geometry = this.line.geometry;
	    geometry.setPositions(this.linePositions);
	    geometry.setColors(this.lineColors);
	    geometry.maxInstancedCount = this.linePositions.length / 3 - 1;
	    this.line.computeLineDistances();
	  }

	  onAddLineDblClick(obj) {
	    this.onAddLine();
	  } // ---------------------------------- 画面 ------------------------------------------


	  handleAddPolygon() {
	    const isAddingPolygon = !this.state.isAddingPolygon;
	    this.setState({
	      isAddingPolygon
	    });

	    if (isAddingPolygon) {
	      app.on(`intersect.EditorToolbarAddPolygon`, this.onAddPolygonIntersect.bind(this));
	      app.on(`dblclick.EditorToolbarAddPolygon`, this.onAddPolygonDblClick.bind(this));
	      var geometry = new THREE.BufferGeometry();
	      geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(300), 3));
	      geometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(300), 3));
	      geometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(200), 2));
	      geometry.attributes.position.count = 0;
	      geometry.attributes.normal.count = 0;
	      geometry.attributes.uv.count = 0;
	      var material = new THREE.MeshBasicMaterial({
	        color: 0xffffff * Math.random(),
	        polygonOffset: true,
	        polygonOffsetFactor: -40,
	        side: THREE.DoubleSide
	      });
	      this.polygon = new THREE.Mesh(geometry, material);
	      this.polygon.name = _t('Polygon');
	      this.polygon.drawMode = THREE.TriangleStripDrawMode;
	      app.editor.execute(new AddObjectCommand(this.polygon));
	      this.polygonPoints = [];
	    } else {
	      app.on(`intersect.EditorToolbarAddPolygon`, null);
	      app.on(`dblclick.EditorToolbarAddPolygon`, null);
	      this.polygon = null;
	      this.polygonPoints = null;
	    }
	  }

	  onAddPolygonIntersect(obj) {
	    if (event.button !== 0) {
	      return;
	    }

	    this.polygonPoints.push(obj.point);
	    var position = this.polygon.geometry.attributes.position;
	    var normal = this.polygon.geometry.attributes.normal;
	    var uv = this.polygon.geometry.attributes.uv;
	    var index = position.count;
	    position.setXYZ(index, obj.point.x, obj.point.y, obj.point.z);
	    normal.setXYZ(index, obj.face.normal.x, obj.face.normal.y, obj.face.normal.z);
	    uv.setXY(index, obj.uv.x, obj.uv.y);
	    position.count++;
	    normal.count++;
	    uv.count++;
	    position.needsUpdate = true;
	    normal.needsUpdate = true;
	    uv.needsUpdate = true;
	  }

	  onAddPolygonDblClick(obj) {
	    this.handleAddPolygon();
	  } // -------------------------------- 贴花工具 ---------------------------------------


	  handleSpray() {
	    const isSpraying = !this.state.isSpraying;
	    this.setState({
	      isSpraying
	    });

	    if (isSpraying) {
	      app.on(`intersect.EditorToolbarSpray`, this.onSprayIntersect.bind(this));
	    } else {
	      app.on(`intersect.EditorToolbarSpray`, null);
	    }
	  }

	  onSprayIntersect(obj, event) {
	    if (event.button !== 0) {
	      return;
	    }

	    this.handleSpray();
	    var mesh = obj.object;
	    var position = obj.point;

	    if (mesh instanceof THREE.Points) {
	      return;
	    }

	    var normal = obj.face.normal.clone();
	    normal.transformDirection(obj.object.matrixWorld);
	    var mat = new THREE.Matrix4();
	    mat.lookAt(position, new THREE.Vector3().addVectors(position, normal), mesh.up);
	    var orientation = new THREE.Euler();
	    orientation.setFromRotationMatrix(mat);
	    var size = new THREE.Vector3(1, 1, 1).multiplyScalar(10 + Math.random() * 10);

	    if (this.decalMaterial === undefined) {
	      var textureLoader = new THREE.TextureLoader();
	      var decalDiffuse = textureLoader.load('assets/textures/decal/decal-diffuse.png');
	      var decalNormal = textureLoader.load('assets/textures/decal/decal-normal.jpg');
	      this.decalMaterial = new THREE.MeshPhongMaterial({
	        specular: 0x444444,
	        map: decalDiffuse,
	        normalMap: decalNormal,
	        normalScale: new THREE.Vector2(1, 1),
	        shininess: 30,
	        transparent: true,
	        depthTest: true,
	        depthWrite: false,
	        polygonOffset: true,
	        polygonOffsetFactor: -4,
	        wireframe: false
	      });
	    }

	    var material = this.decalMaterial.clone();
	    material.color.setHex(Math.random() * 0xffffff);
	    var decal = new THREE.Mesh(new THREE.DecalGeometry(mesh, position, orientation, size), material);
	    decal.name = _t('Decal');
	    app.editor.execute(new AddObjectCommand(decal));
	  } // ------------------------------- 挖坑工具 -------------------------------------


	  handleDig() {
	    this.setState({
	      isDigging: true
	    });

	    if (this.digTool === undefined) {
	      this.digTool = new DigTool(app);
	      this.digTool.on(`end.EditorToolbar`, () => {
	        this.setState({
	          isDigging: false
	        });
	      });
	    }

	    this.digTool.start();
	  } // ------------------------------ 视角工具 ------------------------------------------


	  handlePerspective() {
	    app.call(`changeView`, this, 'perspective');
	    this.setState({
	      view: 'perspective'
	    });
	  }

	  handleFrontView() {
	    app.call(`changeView`, this, 'front');
	    this.setState({
	      view: 'front'
	    });
	  }

	  handleSideView() {
	    app.call(`changeView`, this, 'side');
	    this.setState({
	      view: 'side'
	    });
	  }

	  handleTopView() {
	    app.call(`changeView`, this, 'top');
	    this.setState({
	      view: 'top'
	    });
	  } // ----------------------------- 网格模式 ------------------------------------------


	  handleGridMode() {
	    const isGridMode = !this.state.isGridMode;

	    if (isGridMode) {
	      app.editor.scene.overrideMaterial = new THREE.MeshBasicMaterial({
	        wireframe: true
	      });
	    } else {
	      app.editor.scene.overrideMaterial = null;
	    }

	    this.setState({
	      isGridMode
	    });
	  }

	}

	/**
	 * 脚本编辑器
	 * @author mrdoob / http://mrdoob.com/
	 * @author tengge / https://github.com/tengge1
	 * @param {*} container 容器
	 */
	function ScriptEditor(container = document.body) {
	  this.delay = null; // 代码校验延迟函数

	  this.delayTime = 1000; // 代码校验间隔时间（毫秒）

	  this.mode = 'javascript'; // 模式：json, vertexShader, fragmentShader, javascript

	  this.source = ''; // 代码

	  this.errorLines = []; // 代码错误行数

	  this.widgets = []; // Code Mirror

	  var codemirror = CodeMirror(container, {
	    value: '',
	    lineNumbers: true,
	    matchBrackets: true,
	    indentWithTabs: true,
	    tabSize: 4,
	    indentUnit: 4,
	    hintOptions: {
	      completeSingle: false
	    }
	  });
	  codemirror.setOption('theme', 'monokai');
	  codemirror.on('change', this.onCodeMirrorChange.bind(this)); // 防止回退键删除物体

	  var wrapper = codemirror.getWrapperElement();
	  wrapper.addEventListener('keydown', event => {
	    event.stopPropagation();
	  }); // tern js 自动完成

	  var server = new CodeMirror.TernServer({
	    caseInsensitive: true,
	    plugins: {
	      threejs: null
	    }
	  }); // 快捷键

	  codemirror.setOption('extraKeys', {
	    'Ctrl-Space': cm => {
	      server.complete(cm);
	    },
	    'Ctrl-I': cm => {
	      server.showType(cm);
	    },
	    'Ctrl-O': cm => {
	      server.showDocs(cm);
	    },
	    'Alt-.': cm => {
	      server.jumpToDef(cm);
	    },
	    'Alt-,': cm => {
	      server.jumpBack(cm);
	    },
	    'Ctrl-Q': cm => {
	      server.rename(cm);
	    },
	    'Ctrl-.': cm => {
	      server.selectName(cm);
	    }
	  });
	  codemirror.on('cursorActivity', cm => {
	    if (this.mode !== 'javascript') {
	      return;
	    }

	    server.updateArgHints(cm);
	  });
	  codemirror.on('keypress', (cm, kb) => {
	    if (this.mode !== 'javascript') {
	      return;
	    }

	    var typed = String.fromCharCode(kb.which || kb.keyCode);

	    if (/[\w\.]/.exec(typed)) {
	      server.complete(cm);
	    }
	  });
	  this.codemirror = codemirror;
	}
	/**
	 * 设置编辑器脚本代码
	 * @param {*} source 源码
	 * @param {*} mode 模式 javascript, vertexShader, fragmentShader, json
	 * @param {*} cursorPosition 光标位置
	 * @param {*} scrollInfo 滚动信息
	 */

	ScriptEditor.prototype.setValue = function (source = '', mode = 'javascript', cursorPosition = {
	  line: 0,
	  ch: 0
	}, scrollInfo = {
	  left: 0,
	  top: 0
	}) {
	  this.source = source;
	  this.mode = mode;
	  var codemirror = this.codemirror;
	  var history = codemirror.getHistory();
	  codemirror.setValue(source);

	  if (mode === 'json') {
	    codemirror.setOption('mode', {
	      name: 'javascript',
	      json: true
	    });
	  } else if (mode === 'vertexShader' || mode === 'fragmentShader') {
	    codemirror.setOption('mode', 'glsl');
	  } else {
	    codemirror.setOption('mode', mode);
	  }

	  codemirror.focus();
	  codemirror.setCursor(cursorPosition);
	  codemirror.scrollTo(scrollInfo.left, scrollInfo.top);
	  codemirror.setHistory(history);
	};
	/**
	 * 获取编辑器脚本代码
	 */


	ScriptEditor.prototype.getValue = function () {
	  return this.codemirror.getValue();
	};
	/**
	 * 清空编辑器
	 */


	ScriptEditor.prototype.clear = function () {
	  this.setValue();
	}; // ---------------------- 内部函数 -----------------------------------------

	/**
	 * 代码修改事件
	 */


	ScriptEditor.prototype.onCodeMirrorChange = function () {
	  var codemirror = this.codemirror;

	  if (codemirror.state.focused === false) {
	    return;
	  }

	  if (this.delay) {
	    clearTimeout(this.delay);
	  }

	  this.delay = setTimeout(() => {
	    var code = codemirror.getValue();
	    this.validate(code);
	  }, this.delayTime);
	};
	/**
	 * 校验编辑器中代码正确性
	 * @param {*} string 
	 */


	ScriptEditor.prototype.validate = function (string) {
	  var codemirror = this.codemirror;
	  var mode = this.mode;
	  var errorLines = this.errorLines;
	  var widgets = this.widgets;
	  var errors = [];
	  return codemirror.operation(() => {
	    while (errorLines.length > 0) {
	      codemirror.removeLineClass(errorLines.shift(), 'background', 'errorLine');
	    }

	    while (widgets.length > 0) {
	      codemirror.removeLineWidget(widgets.shift());
	    }

	    switch (mode) {
	      case 'javascript':
	        try {
	          var syntax = esprima.parse(string, {
	            tolerant: true
	          });
	          errors = syntax.errors;
	        } catch (error) {
	          errors.push({
	            lineNumber: error.lineNumber - 1,
	            message: error.message
	          });
	        }

	        for (var i = 0; i < errors.length; i++) {
	          var error = errors[i];
	          error.message = error.message.replace(/Line [0-9]+: /, '');
	        }

	        break;

	      case 'json':
	        jsonlint.parseError = (message, info) => {
	          message = message.split('\n')[3];
	          errors.push({
	            lineNumber: info.loc.first_line - 1,
	            message: message
	          });
	        };

	        try {
	          jsonlint.parse(string);
	        } catch (error) {// ignore failed error recovery
	        }

	        break;

	      case 'vertexShader':
	      case 'fragmentShader':
	        try {
	          var shaderType = mode === 'vertexShader' ? glslprep.Shader.VERTEX : glslprep.Shader.FRAGMENT;
	          glslprep.parseGlsl(string, shaderType);
	        } catch (error) {
	          if (error instanceof glslprep.SyntaxError) {
	            errors.push({
	              lineNumber: error.line,
	              message: "Syntax Error: " + error.message
	            });
	          } else {
	            console.error(error.stack || error);
	          }
	        }

	    }

	    for (var i = 0; i < errors.length; i++) {
	      var error = errors[i];
	      var message = document.createElement('div');
	      message.className = 'esprima-error';
	      message.textContent = error.message;
	      var lineNumber = Math.max(error.lineNumber, 0);
	      errorLines.push(lineNumber);
	      codemirror.addLineClass(lineNumber, 'background', 'errorLine');
	      var widget = codemirror.addLineWidget(lineNumber, message);
	      widgets.push(widget);
	    }

	    return errors.length === 0;
	  });
	};

	/**
	 * 脚本面板
	 * @author tengge / https://github.com/tengge1
	 */

	class ScriptEditorPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      show: false,
	      uuid: null,
	      name: '',
	      type: 'javascript',
	      source: ''
	    };
	    this.callback = null;
	    this.ref = React.createRef();
	    this.handleEditScript = this.handleEditScript.bind(this);
	    this.handleSave = this.handleSave.bind(this);
	  }

	  render() {
	    const {
	      show,
	      name,
	      type
	    } = this.state;
	    let title = name;

	    switch (type) {
	      case 'javascript':
	        title = name + '.js';
	        break;

	      case 'vertexShader':
	      case 'fragmentShader':
	        title = name + '.glsl';
	        break;

	      case 'json':
	        title = name + '.json';
	        break;
	    }

	    return React.createElement("div", {
	      className: bind('ScriptEditorPanel', !show && 'hidden')
	    }, React.createElement("div", {
	      className: 'header'
	    }, React.createElement("div", {
	      className: 'title'
	    }, title), React.createElement(Icon, {
	      icon: 'close',
	      onClick: this.handleSave
	    })), React.createElement("div", {
	      className: 'content',
	      ref: this.ref
	    }));
	  }

	  componentDidMount() {
	    app.require(['codemirror', 'codemirror-addon', 'esprima', 'jsonlint', 'glslprep', 'acorn', 'ternjs']).then(() => {
	      app.scriptEditor = new ScriptEditor(this.ref.current);
	    });

	    app.on(`editScript.ScriptPanel`, this.handleEditScript);
	  }

	  handleEditScript(uuid, name, type, source, callback) {
	    this.callback = callback;
	    this.setState({
	      show: true,
	      uuid,
	      name,
	      type,
	      source
	    }, () => {
	      app.scriptEditor.setValue(source, type);
	    });
	  }

	  handleSave() {
	    const {
	      uuid,
	      name,
	      type
	    } = this.state;
	    const source = app.scriptEditor.getValue();
	    this.callback && this.callback(uuid, name, type, source);
	    this.callback = null;
	    this.setState({
	      show: false,
	      uuid: null,
	      name: '',
	      type: 'javascript',
	      source: ''
	    });
	  }

	}

	/**
	 * 视口
	 * @author tengge / https://github.com/tengge1
	 */

	class Viewport extends React.Component {
	  constructor(props) {
	    super(props);
	    this.viewportRef = React.createRef();
	    this.editorRef = React.createRef();
	    this.svgRef = React.createRef();
	    this.playerRef = React.createRef();
	  }

	  render() {
	    return React.createElement("div", {
	      className: 'Viewport',
	      ref: this.viewportRef
	    }, React.createElement("div", {
	      className: 'editor',
	      ref: this.editorRef
	    }), React.createElement("svg", {
	      className: 'svg',
	      ref: this.svgRef
	    }), React.createElement(ScriptEditorPanel, null), React.createElement("div", {
	      className: 'player',
	      ref: this.playerRef
	    }));
	  }

	  componentDidMount() {
	    app.viewportRef = this.viewportRef.current;
	    app.editorRef = this.editorRef.current;
	    app.svgRef = this.svgRef.current;
	    app.playerRef = this.playerRef.current; // 性能控件

	    app.stats = new Stats();
	    let showStats = app.storage.get('showStats');

	    if (showStats === undefined) {
	      showStats = true;
	      app.storage.set('showStats', true);
	    }

	    Object.assign(app.stats.dom.style, {
	      position: 'absolute',
	      left: '8px',
	      top: '8px',
	      zIndex: 'initial',
	      display: showStats ? 'block' : 'none'
	    });
	    app.viewportRef.appendChild(app.stats.dom);
	    app.viewport = this.editorRef.current;
	    app.player = new Player(this.playerRef.current, {
	      server: app.options.server,
	      enableThrowBall: false,
	      showStats: false
	    });
	  }

	}

	/**
	 * 时间轴面板
	 * @author tengge / https://github.com/tengge1
	 */

	class TimelinePanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      animations: [],
	      selectedLayer: null,
	      selected: null
	    };
	    this.handleAddLayer = this.handleAddLayer.bind(this);
	    this.commitAddLayer = this.commitAddLayer.bind(this);
	    this.handleEditLayer = this.handleEditLayer.bind(this);
	    this.commitEditLayer = this.commitEditLayer.bind(this);
	    this.handleDeleteLayer = this.handleDeleteLayer.bind(this);
	    this.commitDeleteLayer = this.commitDeleteLayer.bind(this);
	    this.handleSelectedLayerChange = this.handleSelectedLayerChange.bind(this);
	    this.handleAddAnimation = this.handleAddAnimation.bind(this);
	    this.handleDropAnimation = this.handleDropAnimation.bind(this);
	    this.handleClickAnimation = this.handleClickAnimation.bind(this);
	    this.updateUI = this.updateUI.bind(this);
	  }

	  render() {
	    const {
	      animations,
	      selectedLayer,
	      selected
	    } = this.state;
	    return React.createElement(Timeline, {
	      className: 'TimelinePanel',
	      animations: animations,
	      selectedLayer: selectedLayer,
	      selected: selected,
	      onAddLayer: this.handleAddLayer,
	      onEditLayer: this.handleEditLayer,
	      onDeleteLayer: this.handleDeleteLayer,
	      onSelectedLayerChange: this.handleSelectedLayerChange,
	      onAddAnimation: this.handleAddAnimation,
	      onDropAnimation: this.handleDropAnimation,
	      onClickAnimation: this.handleClickAnimation
	    });
	  }

	  componentDidMount() {
	    app.on(`appStarted.TimelinePanel`, this.updateUI);
	    app.on(`animationChanged.TimelinePanel`, this.updateUI);
	  }

	  updateUI() {
	    this.setState({
	      animations: app.editor.animations
	    });
	  } // ----------------------- 动画层管理 ------------------------------


	  handleAddLayer() {
	    app.prompt({
	      title: _t('Input Layer Name'),
	      content: _t('Layer Name'),
	      value: _t('New Layer'),
	      onOK: this.commitAddLayer
	    });
	  }

	  commitAddLayer(layerName) {
	    let animations = app.editor.animations;
	    const layer = Math.max.apply(Math, animations.map(n => n.layer)) + 1;
	    animations.push({
	      id: null,
	      layer,
	      layerName: layerName,
	      uuid: THREE.Math.generateUUID(),
	      animations: []
	    });
	    app.call(`animationChanged`, this);
	  }

	  handleEditLayer(id, event) {
	    if (!id) {
	      app.toast(_t('Please select an animation layer.'));
	      return;
	    }

	    const animations = app.editor.animations;
	    const layer = animations.filter(n => n.uuid === id)[0];
	    app.prompt({
	      title: _t('Edit Layer Name'),
	      content: _t('Layer Name'),
	      value: layer.layerName,
	      onOK: this.commitEditLayer
	    });
	  }

	  commitEditLayer(layerName) {
	    let animations = app.editor.animations;
	    const index = animations.findIndex(n => n.uuid === this.state.selectedLayer);

	    if (index > -1) {
	      animations[index].layerName = layerName;
	      app.call(`animationChanged`, this);
	    }
	  }

	  handleDeleteLayer(id, event) {
	    if (!id) {
	      app.toast(_t('Please select an animation layer.'));
	      return;
	    }

	    const animations = app.editor.animations;
	    const layer = animations.filter(n => n.uuid === id)[0];
	    app.confirm({
	      title: _t('Delete'),
	      content: _t(`Delete animation layer {{layerName}}?`, {
	        layerName: layer.layerName
	      }),
	      onOK: this.commitDeleteLayer
	    });
	  }

	  commitDeleteLayer() {
	    let animations = app.editor.animations;
	    const index = animations.findIndex(n => n.uuid === this.state.selectedLayer);

	    if (index > -1) {
	      animations.splice(index, 1);
	      app.call(`animationChanged`, this);
	    }
	  }

	  handleSelectedLayerChange(value) {
	    this.setState({
	      selectedLayer: value
	    });
	  } // ---------------------------- 动画管理 ---------------------------------


	  handleAddAnimation(layerID, beginTime, endTime, event) {
	    let layer = app.editor.animations.filter(n => n.uuid === layerID)[0];

	    if (!layer) {
	      console.warn(`TimelinePanel: layer ${layerID} is not defined.`);
	      return;
	    }

	    layer.animations.push({
	      id: null,
	      uuid: THREE.Math.generateUUID(),
	      name: _t('Animation'),
	      target: null,
	      type: 'Tween',
	      beginTime,
	      endTime,
	      data: {
	        beginStatus: 'Current',
	        // 开始状态：Current-当前位置、Custom-自定义位置
	        beginPositionX: 0,
	        beginPositionY: 0,
	        beginPositionZ: 0,
	        beginRotationX: 0,
	        beginRotationY: 0,
	        beginRotationZ: 0,
	        beginScaleLock: true,
	        beginScaleX: 1.0,
	        beginScaleY: 1.0,
	        beginScaleZ: 1.0,
	        ease: 'linear',
	        // linear, quadIn, quadOut, quadInOut, cubicIn, cubicOut, cubicInOut, quartIn, quartOut, quartInOut, quintIn, quintOut, quintInOut, sineIn, sineOut, sineInOut, backIn, backOut, backInOut, circIn, circOut, circInOut, bounceIn, bounceOut, bounceInOut, elasticIn, elasticOut, elasticInOut
	        endStatus: 'Current',
	        endPositionX: 0,
	        endPositionY: 0,
	        endPositionZ: 0,
	        endRotationX: 0,
	        endRotationY: 0,
	        endRotationZ: 0,
	        endScaleLock: true,
	        endScaleX: 1.0,
	        endScaleY: 1.0,
	        endScaleZ: 1.0
	      }
	    });
	    app.call(`animationChanged`, this);
	  }

	  handleDropAnimation(id, oldLayerID, newLayerID, beginTime, event) {
	    let oldLayer = app.editor.animations.filter(n => n.uuid === oldLayerID)[0];

	    if (!oldLayer) {
	      console.warn(`TimelinePanel: layer ${oldLayerID} is not defined.`);
	      return;
	    }

	    let newLayer = app.editor.animations.filter(n => n.uuid === newLayerID)[0];

	    if (!newLayer) {
	      console.warn(`TimelinePanel: layer ${newLayerID} is not defined.`);
	      return;
	    }

	    let index = oldLayer.animations.findIndex(n => n.uuid === id);

	    if (index === -1) {
	      console.warn(`TimelinePanel: animation ${id} is not defined.`);
	      return;
	    }

	    let animation = oldLayer.animations[index];
	    let duration = animation.endTime - animation.beginTime;
	    animation.beginTime = beginTime;
	    animation.endTime = beginTime + duration;
	    oldLayer.animations.splice(index, 1);
	    newLayer.animations.push(animation);
	    app.call(`animationChanged`, this);
	  }

	  handleClickAnimation(id, pid, event) {
	    const layer = app.editor.animations.filter(n => n.uuid === pid)[0];

	    if (!layer) {
	      console.warn(`TimelinePanel: layer ${pid} is not defined.`);
	      return;
	    }

	    const animation = layer.animations.filter(n => n.uuid === id)[0];

	    if (!animation) {
	      console.warn(`TimelinePanel: animation ${id} is not defined.`);
	      return;
	    }

	    app.call('animationSelected', this, animation);
	    this.setState({
	      selected: animation.uuid
	    });
	  }

	}

	/**
	 * 移动物体命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param object THREE.Object3D
	 * @param newParent THREE.Object3D
	 * @param newBefore THREE.Object3D
	 * @constructor
	 */

	function MoveObjectCommand(object, newParent, newBefore) {
	  Command.call(this);
	  this.type = 'MoveObjectCommand';
	  this.name = _t('Move Object');
	  this.object = object;
	  this.oldParent = object !== undefined ? object.parent : undefined;
	  this.oldIndex = this.oldParent !== undefined ? this.oldParent.children.indexOf(this.object) : undefined;
	  this.newParent = newParent;

	  if (newBefore !== undefined) {
	    this.newIndex = newParent !== undefined ? newParent.children.indexOf(newBefore) : undefined;
	  } else {
	    this.newIndex = newParent !== undefined ? newParent.children.length : undefined;
	  }

	  if (this.oldParent === this.newParent && this.newIndex > this.oldIndex) {
	    this.newIndex--;
	  }

	  this.newBefore = newBefore;
	}
	MoveObjectCommand.prototype = Object.create(Command.prototype);
	Object.assign(MoveObjectCommand.prototype, {
	  constructor: MoveObjectCommand,
	  execute: function () {
	    this.oldParent.remove(this.object);
	    var children = this.newParent.children;
	    children.splice(this.newIndex, 0, this.object);
	    this.object.parent = this.newParent;
	  },
	  undo: function () {
	    this.newParent.remove(this.object);
	    var children = this.oldParent.children;
	    children.splice(this.oldIndex, 0, this.object);
	    this.object.parent = this.oldParent;
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.newParentUuid = this.newParent.uuid;
	    output.oldParentUuid = this.oldParent.uuid;
	    output.newIndex = this.newIndex;
	    output.oldIndex = this.oldIndex;
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.oldParent = this.editor.objectByUuid(json.oldParentUuid);

	    if (this.oldParent === undefined) {
	      this.oldParent = this.editor.scene;
	    }

	    this.newParent = this.editor.objectByUuid(json.newParentUuid);

	    if (this.newParent === undefined) {
	      this.newParent = this.editor.scene;
	    }

	    this.newIndex = json.newIndex;
	    this.oldIndex = json.oldIndex;
	  }
	});

	/**
	 * 场景树状图
	 * @author tengge / https://github.com/tengge1
	 */

	class HierarchyPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.expanded = {};
	    this.checked = {};
	    this.state = {
	      data: [],
	      selected: null
	    };
	    this.updateUI = this.updateUI.bind(this);
	    this.handleObjectSelected = this.handleObjectSelected.bind(this);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleCheck = this.handleCheck.bind(this);
	    this.handleDoubleClick = this.handleDoubleClick.bind(this);
	    this.handleClickVisible = this.handleClickVisible.bind(this);
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleDrop = this.handleDrop.bind(this);
	  }

	  render() {
	    const {
	      data,
	      selected,
	      checked
	    } = this.state;
	    return React.createElement(Tree, {
	      data: data,
	      selected: selected,
	      checked: checked,
	      onSelect: this.handleSelect,
	      onCheck: this.handleCheck,
	      onDoubleClick: this.handleDoubleClick,
	      onClickIcon: this.handleClickVisible,
	      onExpand: this.handleExpand,
	      onDrop: this.handleDrop
	    });
	  }

	  componentDidMount() {
	    app.on(`sceneGraphChanged.HierarchyPanel`, this.updateUI); // bug: https://gitee.com/tengge1/ShadowEditor/issues/ITCA9

	    app.on(`objectChanged.HierarchyPanel`, this.updateUI);
	    app.on(`objectRemoved.HierarchyPanel`, this.updateUI);
	    app.on(`objectSelected.HierarchyPanel`, this.handleObjectSelected);
	  }
	  /**
	   * 单击树节点
	   * @param {*} value 
	   */


	  handleSelect(value) {
	    this.setState({
	      selected: value
	    });
	    app.editor.selectByUuid(value);
	  }

	  handleCheck(value, name, event) {
	    let checked = this.checked;

	    if (value && !checked[name]) {
	      checked[name] = true;
	    } else if (!value && checked[name]) {
	      delete checked[name];
	    } else {
	      console.warn(`HierarchyPanel: handleCheck error.`);
	    }

	    this.updateUI();
	  }

	  handleDoubleClick(value) {
	    this.setState({
	      selected: value
	    });
	    app.editor.focusByUUID(value);
	  }

	  handleClickVisible(value, name, event) {
	    let obj = app.editor.objectByUuid(value);

	    if (obj) {
	      obj.visible = !obj.visible;
	      app.call(`objectChanged`, this, obj.visible); // this.updateUI();
	    }
	  }
	  /**
	   * 选中物体改变
	   * @param {*} object 
	   */


	  handleObjectSelected(object) {
	    this.setState({
	      selected: object ? object.uuid : null
	    });
	  }
	  /**
	   * 根据场景变化，更新场景树状图
	   */


	  updateUI() {
	    const scene = app.editor.scene;
	    const camera = app.editor.camera;
	    let list = [{
	      value: camera.uuid,
	      text: camera.name,
	      cls: 'Camera',
	      expanded: false,
	      checked: this.checked[camera.uuid] || false,
	      draggable: false,
	      children: []
	    }];

	    this._parseData(scene, list);

	    this.setState({
	      data: list
	    });
	  }

	  _parseData(obj, list) {
	    const scene = app.editor.scene;
	    const camera = app.editor.camera;
	    let cls = null;

	    if (obj === scene) {
	      cls = 'Scene';
	    } else if (obj instanceof THREE.Line) {
	      cls = 'Line';
	    } else if (obj instanceof THREE.Light) {
	      cls = 'Light';
	    } else if (obj instanceof THREE.Points) {
	      cls = 'Points';
	    } else {
	      cls = 'Default';
	    }

	    let expanded = this.expanded;

	    if (obj === scene && expanded[obj.uuid] === undefined) {
	      expanded[obj.uuid] = true;
	    }

	    var data = {
	      value: obj.uuid,
	      text: obj.name,
	      expanded: expanded[obj.uuid],
	      checked: this.checked[obj.uuid] || false,
	      draggable: obj !== scene && obj !== camera,
	      cls: cls,
	      children: [],
	      icons: [{
	        name: 'visible',
	        icon: obj.visible ? 'visible' : 'invisible'
	      }]
	    };
	    list.push(data);

	    if (Array.isArray(obj.children)) {
	      obj.children.forEach(n => {
	        this._parseData(n, data.children);
	      });
	    }
	  }
	  /**
	   * 展开关闭节点
	   * @param {*} value 
	   */


	  handleExpand(value) {
	    let expanded = this.expanded;

	    if (expanded[value]) {
	      expanded[value] = false;
	    } else {
	      expanded[value] = true;
	    }

	    this.updateUI();
	  }
	  /**
	   * 拖动节点
	   */


	  handleDrop(value, newParentValue, newBeforeValue) {
	    var editor = app.editor;
	    let object = editor.objectByUuid(value);
	    let newParent = editor.objectByUuid(newParentValue);
	    let newBefore = null;

	    if (newBeforeValue) {
	      newBefore = editor.objectByUuid(newBeforeValue);
	    }

	    app.editor.execute(new MoveObjectCommand(object, newParent, newBefore));
	    this.expanded[newParentValue] = true;
	    this.updateUI();
	  }

	}

	/**
	 * 历史面板
	 * @author tengge / https://github.com/tengge1
	 */

	class HistoryPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      undos: [],
	      redos: []
	    };
	    this.ref = React.createRef();
	    this.update = this.update.bind(this);
	    this.handleClick = this.handleClick.bind(this);
	    this.handleClear = this.handleClear.bind(this);
	  }

	  render() {
	    const {
	      undos,
	      redos
	    } = this.state;
	    return React.createElement("div", {
	      className: 'HistoryPanel'
	    }, React.createElement("div", {
	      className: 'toolbar'
	    }, React.createElement(Button, {
	      onClick: this.handleClear
	    }, _t('Clear'))), React.createElement("div", {
	      className: 'content',
	      ref: this.ref,
	      onClick: this.handleClick
	    }, undos.map(n => {
	      return React.createElement("div", {
	        className: 'undo',
	        value: n.id,
	        key: n.id,
	        onClick: this.handleClick
	      }, n.name);
	    }), redos.map(n => {
	      return React.createElement("div", {
	        className: 'redo',
	        value: n.id,
	        key: n.id,
	        onClick: this.handleClick
	      }, n.name);
	    })));
	  }

	  componentDidMount() {
	    app.on(`editorCleared.HistoryPanel`, this.update);
	    app.on(`historyChanged.HistoryPanel`, this.update);
	  }

	  componentDidUpdate() {
	    let dom = this.ref.current;
	    dom.scrollTop = dom.scrollHeight;
	  }

	  update() {
	    var history = app.editor.history;
	    let undos = [],
	        redos = [];
	    history.undos.forEach(n => {
	      undos.push({
	        id: n.id,
	        name: n.name
	      });
	    });
	    history.redos.forEach(n => {
	      redos.push({
	        id: n.id,
	        name: n.name
	      });
	    });
	    undos.sort((a, b) => {
	      return a.id - b.id;
	    });
	    redos.sort((a, b) => {
	      return a.id - b.id;
	    });
	    this.setState({
	      undos,
	      redos
	    });
	  }

	  handleClick(event) {
	    const id = event.target.getAttribute('value');

	    if (!id) {
	      return;
	    }

	    app.editor.history.goToState(parseInt(id));
	    this.update();
	  }

	  handleClear() {
	    var editor = app.editor;
	    app.confirm({
	      title: _t('Confirm'),
	      content: _t('Undo/Redo history will be cleared. Are you sure?'),
	      onOK: () => {
	        editor.history.clear();
	      }
	    });
	  }

	}

	/**
	 * 设置值命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param object THREE.Object3D
	 * @param attributeName string
	 * @param newValue number, string, boolean or object
	 * @constructor
	 */

	function SetValueCommand(object, attributeName, newValue) {
	  Command.call(this);
	  this.type = 'SetValueCommand';
	  this.name = _t('Set') + ' ' + attributeName;
	  this.updatable = true;
	  this.object = object;
	  this.attributeName = attributeName;
	  this.oldValue = object !== undefined ? object[attributeName] : undefined;
	  this.newValue = newValue;
	}
	SetValueCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetValueCommand.prototype, {
	  constructor: SetValueCommand,
	  execute: function () {
	    this.object[this.attributeName] = this.newValue;
	    app.call('objectChanged', this, this.object);
	  },
	  undo: function () {
	    this.object[this.attributeName] = this.oldValue;
	    app.call('objectChanged', this, this.object);
	  },
	  update: function (cmd) {
	    this.newValue = cmd.newValue;
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.attributeName = this.attributeName;
	    output.oldValue = this.oldValue;
	    output.newValue = this.newValue;
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.attributeName = json.attributeName;
	    this.oldValue = json.oldValue;
	    this.newValue = json.newValue;
	    this.object = this.editor.objectByUuid(json.objectUuid);
	  }
	});

	/**
	 * 基本信息组件
	 * @author tengge / https://github.com/tengge1
	 */

	class BasicComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      show: false,
	      expanded: true,
	      name: '',
	      type: '',
	      visible: true
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChangeName = this.handleChangeName.bind(this);
	    this.handleChangeVisible = this.handleChangeVisible.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      name,
	      type,
	      visible
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Basic Info'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(TextProperty, {
	      label: _t('Name'),
	      name: 'name',
	      value: name,
	      onChange: this.handleChangeName
	    }), React.createElement(DisplayProperty, {
	      label: _t('Type'),
	      name: 'type',
	      value: type
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('Visible'),
	      name: 'visible',
	      value: visible,
	      onChange: this.handleChangeVisible
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.BasicComponent`, this.handleUpdate);
	    app.on(`objectChanged.BasicComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      name: this.selected.name,
	      type: this.selected.constructor.name,
	      visible: this.selected.visible
	    });
	  }

	  handleChangeName(value) {
	    this.setState({
	      name: value
	    });
	    app.editor.execute(new SetValueCommand(this.selected, 'name', value)); // bug: https://gitee.com/tengge1/ShadowEditor/issues/IV1V3

	    if (this.selected instanceof Text) {
	      this.selected.updateText(value);
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeVisible(value) {
	    this.setState({
	      visible: value
	    });
	    this.selected.visible = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 相机组件
	 * @author tengge / https://github.com/tengge1
	 */

	class CameraComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      show: false,
	      expanded: true,
	      fov: 70,
	      near: 0.1,
	      far: 1000
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChangeFov = this.handleChangeFov.bind(this);
	    this.handleChangeNear = this.handleChangeNear.bind(this);
	    this.handleChangeFar = this.handleChangeFar.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      fov,
	      near,
	      far
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Camera Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: _t('Fov'),
	      name: 'fov',
	      value: fov,
	      onChange: this.handleChangeFov
	    }), React.createElement(NumberProperty, {
	      label: _t('Near'),
	      name: 'near',
	      value: near,
	      onChange: this.handleChangeNear
	    }), React.createElement(NumberProperty, {
	      label: _t('Far'),
	      name: 'far',
	      value: far,
	      onChange: this.handleChangeFar
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.CameraComponent`, this.handleUpdate);
	    app.on(`objectChanged.CameraComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor; // TODO: 应判断是否等于默认相机

	    if (!editor.selected || !(editor.selected instanceof THREE.PerspectiveCamera)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      fov: this.selected.fov,
	      near: this.selected.near,
	      far: this.selected.far
	    });
	  }

	  handleChangeFov(value) {
	    if (value === null) {
	      this.setState({
	        fov: value
	      });
	      return;
	    }

	    app.editor.execute(new SetValueCommand(this.selected, 'fov', value));
	  }

	  handleChangeNear(value) {
	    if (value === null) {
	      this.setState({
	        near: value
	      });
	      return;
	    }

	    app.editor.execute(new SetValueCommand(this.selected, 'near', value));
	  }

	  handleChangeFar(value) {
	    if (value === null) {
	      this.setState({
	        far: value
	      });
	      return;
	    }

	    app.editor.execute(new SetValueCommand(this.selected, 'far', value));
	  }

	}

	/**
	 * 火焰组件
	 * @author tengge / https://github.com/tengge1
	 */

	class FireComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.isPlaying = false;
	    this.state = {
	      show: false,
	      expanded: true,
	      width: 2,
	      height: 4,
	      depth: 2,
	      sliceSpacing: 2,
	      previewText: _t('Preview')
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	    this.handlePreview = this.handlePreview.bind(this);
	    this.onAnimate = this.onAnimate.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      width,
	      height,
	      depth,
	      sliceSpacing,
	      previewText
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Fire Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: _t('Width'),
	      name: 'width',
	      value: width,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Height'),
	      name: 'height',
	      value: height,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Depth'),
	      name: 'depth',
	      value: depth,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('SliceSpacing'),
	      name: 'sliceSpacing',
	      value: sliceSpacing,
	      onChange: this.handleChange
	    }), React.createElement(ButtonProperty, {
	      text: previewText,
	      onChange: this.handlePreview
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.FireComponent`, this.handleUpdate);
	    app.on(`objectChanged.FireComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected.userData.type === 'Fire')) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      width: this.selected.userData.width,
	      height: this.selected.userData.height,
	      depth: this.selected.userData.depth,
	      sliceSpacing: this.selected.userData.sliceSpacing,
	      previewText: this.isPlaying ? _t('Cancel') : _t('Preview')
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    let {
	      width,
	      height,
	      depth,
	      sliceSpacing
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    VolumetricFire.texturePath = 'assets/textures/VolumetricFire/';
	    const editor = app.editor;
	    let fire = new VolumetricFire(width, height, depth, sliceSpacing, editor.camera);
	    fire.mesh.name = this.selected.name;
	    fire.mesh.position.copy(this.selected.position);
	    fire.mesh.rotation.copy(this.selected.rotation);
	    fire.mesh.scale.copy(this.selected.scale);
	    Object.assign(fire.mesh.userData, {
	      type: 'Fire',
	      fire,
	      width,
	      height,
	      depth,
	      sliceSpacing
	    });
	    const index = editor.scene.children.indexOf(this.selected);

	    if (index > -1) {
	      editor.select(null);
	      editor.scene.children[index] = fire.mesh;
	      fire.mesh.parent = this.selected.parent;
	      this.selected.parent = null;
	      app.call(`objectRemoved`, this, this.selected);
	      app.call(`objectAdded`, this, fire.mesh);
	      editor.select(fire.mesh);
	      fire.update(0);
	    }
	  }

	  handlePreview() {
	    if (this.isPlaying) {
	      this.stopPreview();
	    } else {
	      this.startPreview();
	    }
	  }

	  startPreview() {
	    this.isPlaying = true;
	    this.setState({
	      previewText: _t('Cancel')
	    });
	    app.on(`animate.FireComponent`, this.onAnimate);
	  }

	  stopPreview() {
	    this.isPlaying = false;
	    this.setState({
	      previewText: _t('Preview')
	    });
	    app.on(`animate.FireComponent`, null);
	  }

	  onAnimate(clock, deltaTime) {
	    const elapsed = clock.getElapsedTime();
	    const fire = this.selected.userData.fire;
	    fire.update(elapsed);
	  }

	}

	/**
	 * 光源组件
	 * @author tengge / https://github.com/tengge1
	 */

	class LightComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: true,
	      showColor: false,
	      color: '#ffffff',
	      showIntensity: false,
	      intensity: 1,
	      showDistance: false,
	      distance: 0,
	      showAngle: false,
	      angle: Math.PI * 0.1,
	      showPenumbra: false,
	      penumbra: 0,
	      showDecay: false,
	      decay: 1,
	      showSkyColor: false,
	      skyColor: '#00aaff',
	      showGroundColor: false,
	      groundColor: '#ffaa00',
	      showWidth: false,
	      width: 20,
	      showHeight: false,
	      height: 10
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChangeColor = this.handleChangeColor.bind(this);
	    this.handleChangeIntensity = this.handleChangeIntensity.bind(this);
	    this.handleChangeDistance = this.handleChangeDistance.bind(this);
	    this.handleChangeAngle = this.handleChangeAngle.bind(this);
	    this.handleChangePenumbra = this.handleChangePenumbra.bind(this);
	    this.handleChangeDecay = this.handleChangeDecay.bind(this);
	    this.handleChangeSkyColor = this.handleChangeSkyColor.bind(this);
	    this.handleChangeGroundColor = this.handleChangeGroundColor.bind(this);
	    this.handleChangeWidth = this.handleChangeWidth.bind(this);
	    this.handleChangeHeight = this.handleChangeHeight.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      showColor,
	      color,
	      showIntensity,
	      intensity,
	      showDistance,
	      distance,
	      showAngle,
	      angle,
	      showPenumbra,
	      penumbra,
	      showDecay,
	      decay,
	      showSkyColor,
	      skyColor,
	      showGroundColor,
	      groundColor,
	      showWidth,
	      width,
	      showHeight,
	      height
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Light Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(ColorProperty, {
	      label: _t('Color'),
	      name: 'color',
	      value: color,
	      show: showColor,
	      onChange: this.handleChangeColor
	    }), React.createElement(NumberProperty, {
	      label: _t('Intensity'),
	      name: 'intensity',
	      value: intensity,
	      show: showIntensity,
	      onChange: this.handleChangeIntensity
	    }), React.createElement(NumberProperty, {
	      label: _t('Distance'),
	      name: 'distance',
	      value: distance,
	      show: showDistance,
	      onChange: this.handleChangeDistance
	    }), React.createElement(NumberProperty, {
	      label: _t('Angle'),
	      name: 'angle',
	      value: angle,
	      show: showAngle,
	      onChange: this.handleChangeAngle
	    }), React.createElement(NumberProperty, {
	      label: _t('Penumbra'),
	      name: 'penumbra',
	      value: penumbra,
	      show: showPenumbra,
	      onChange: this.handleChangePenumbra
	    }), React.createElement(NumberProperty, {
	      label: _t('Decay'),
	      name: 'decay',
	      value: decay,
	      show: showDecay,
	      onChange: this.handleChangeDecay
	    }), React.createElement(ColorProperty, {
	      label: _t('SkyColor'),
	      name: 'skyColor',
	      value: skyColor,
	      show: showSkyColor,
	      onChange: this.handleChangeSkyColor
	    }), React.createElement(ColorProperty, {
	      label: _t('GroundColor'),
	      name: 'groundColor',
	      value: groundColor,
	      show: showGroundColor,
	      onChange: this.handleChangeGroundColor
	    }), React.createElement(NumberProperty, {
	      label: _t('Width'),
	      name: 'width',
	      value: width,
	      show: showWidth,
	      onChange: this.handleChangeWidth
	    }), React.createElement(NumberProperty, {
	      label: _t('Height'),
	      name: 'height',
	      value: height,
	      show: showHeight,
	      onChange: this.handleChangeHeight
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.LightComponent`, this.handleUpdate);
	    app.on(`objectChanged.LightComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Light)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let state = {
	      show: true
	    };

	    if (this.selected instanceof THREE.HemisphereLight) {
	      state.showColor = false;
	    } else {
	      state.showColor = true;
	      state.color = `#${this.selected.color.getHexString()}`;
	    }

	    state.showIntensity = true;
	    state.intensity = this.selected.intensity;

	    if (this.selected instanceof THREE.PointLight || this.selected instanceof THREE.SpotLight) {
	      state.showDistance = true;
	      state.showDecay = true;
	      state.distance = this.selected.distance;
	      state.decay = this.selected.decay;
	    } else {
	      state.showDistance = false;
	      state.showDecay = false;
	    }

	    if (this.selected instanceof THREE.SpotLight) {
	      state.showAngle = true;
	      state.showPenumbra = true;
	      state.angle = this.selected.angle;
	      state.penumbra = this.selected.penumbra;
	    } else {
	      state.showAngle = false;
	      state.showPenumbra = false;
	    }

	    if (this.selected instanceof THREE.HemisphereLight) {
	      state.showSkyColor = true;
	      state.showGroundColor = true;
	      state.skyColor = `#${this.selected.color.getHexString()}`;
	      state.groundColor = `#${this.selected.groundColor.getHexString()}`;
	    } else {
	      state.showSkyColor = false;
	      state.showGroundColor = false;
	    }

	    if (this.selected instanceof THREE.RectAreaLight) {
	      state.showWidth = true;
	      state.showHeight = true;
	      state.width = this.selected.width;
	      state.height = this.selected.height;
	    } else {
	      state.showWidth = false;
	      state.showHeight = false;
	    }

	    this.setState(state);
	  }

	  handleChangeColor(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.color = new THREE.Color(value);
	    let helper = this.selected.children.filter(n => n.userData.type === 'helper')[0];

	    if (helper) {
	      helper.material.color = this.selected.color;
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeIntensity(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.intensity = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeDistance(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.distance = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeAngle(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.angle = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangePenumbra(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.penumbra = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeDecay(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.decay = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeSkyColor(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.color = new THREE.Color(value);
	    let sky = this.selected.children.filter(n => n.userData.type === 'sky')[0];

	    if (sky) {
	      sky.material.uniforms.topColor.value = this.selected.color;
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeGroundColor(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.groundColor = new THREE.Color(value);
	    let ground = this.selected.children.filter(n => n.userData.type === 'sky')[0];

	    if (ground) {
	      ground.material.uniforms.bottomColor.value = this.selected.groundColor;
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeWidth(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.width = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeHeight(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.height = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * LMesh组件
	 * @author tengge / https://github.com/tengge1
	 */

	class LMeshComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.isPlaying = false;
	    this.state = {
	      show: false,
	      expanded: true,
	      options: [],
	      animation: '',
	      previewText: _t('Preview')
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	    this.handlePreview = this.handlePreview.bind(this);
	    this.onAnimate = this.onAnimate.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      options,
	      animation,
	      previewText
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('LMesh Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(SelectProperty, {
	      label: _t('Animation'),
	      name: 'animation',
	      options: options,
	      value: animation,
	      onChange: this.handleChange
	    }), React.createElement(ButtonProperty, {
	      text: previewText,
	      onChange: this.handlePreview
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.LMeshComponent`, this.handleUpdate);
	    app.on(`objectChanged.LMeshComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected.userData.type === 'lol')) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const model = this.selected.userData.model;
	    const animNames = model.getAnimations();
	    let options = {};
	    animNames.forEach(n => {
	      options[n] = n;
	    });
	    this.setState({
	      show: true,
	      options,
	      animation: animNames[0],
	      previewText: this.isPlaying ? _t('Cancel') : _t('Preview')
	    });
	  }

	  handleChange(value, name) {
	    const model = this.selected.userData.model;
	    model.setAnimation(value);
	    this.setState({
	      animation: value
	    });
	  }

	  handlePreview() {
	    if (this.isPlaying) {
	      this.stopPreview();
	    } else {
	      this.startPreview();
	    }
	  }

	  startPreview() {
	    const animation = this.state.animation;

	    if (!animation) {
	      app.toast(`Please select animation.`);
	      return;
	    }

	    this.isPlaying = true;
	    this.setState({
	      previewText: _t('Cancel')
	    });
	    const model = this.selected.userData.model;
	    model.setAnimation(animation);
	    app.on(`animate.LMeshComponent`, this.onAnimate);
	  }

	  stopPreview() {
	    this.isPlaying = false;
	    this.setState({
	      previewText: _t('Preview')
	    });
	    app.on(`animate.LMeshComponent`, null);
	  }

	  onAnimate(clock, deltaTime) {
	    var model = this.selected.userData.model;
	    model.update(clock.getElapsedTime() * 1000);
	  }

	}

	/**
	 * 设置材质命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param object THREE.Object3D
	 * @param newMaterial THREE.Material
	 * @constructor
	 */

	function SetMaterialCommand(object, newMaterial) {
	  Command.call(this);
	  this.type = 'SetMaterialCommand';
	  this.name = _t('New Material');
	  this.object = object;
	  this.oldMaterial = object !== undefined ? object.material : undefined;
	  this.newMaterial = newMaterial;
	}
	SetMaterialCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetMaterialCommand.prototype, {
	  constructor: SetMaterialCommand,
	  execute: function () {
	    this.object.material = this.newMaterial;
	  },
	  undo: function () {
	    this.object.material = this.oldMaterial;
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.oldMaterial = this.oldMaterial.toJSON();
	    output.newMaterial = this.newMaterial.toJSON();
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.oldMaterial = parseMaterial(json.oldMaterial);
	    this.newMaterial = parseMaterial(json.newMaterial);

	    function parseMaterial(json) {
	      var loader = new THREE.ObjectLoader();
	      var images = loader.parseImages(json.images);
	      var textures = loader.parseTextures(json.textures, images);
	      var materials = loader.parseMaterials([json], textures);
	      return materials[json.uuid];
	    }
	  }
	});

	let color = new THREE.Color();
	/**
	 * 设置材质颜色命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param object THREE.Object3D
	 * @param attributeName string
	 * @param newValue integer representing a hex color value or a hex string startsWith `#`
	 * @constructor
	 */

	function SetMaterialColorCommand(object, attributeName, newValue) {
	  Command.call(this);
	  this.type = 'SetMaterialColorCommand';
	  this.name = _t('Set Material') + '.' + attributeName;
	  this.updatable = true;
	  this.object = object;
	  this.attributeName = attributeName;
	  this.oldValue = object !== undefined ? this.object.material[this.attributeName].getHex() : undefined;

	  if (Number.isInteger(newValue)) {
	    this.newValue = newValue;
	  } else {
	    // #ffffff
	    color.set(newValue);
	    this.newValue = color.getHex();
	  }
	}
	SetMaterialColorCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetMaterialColorCommand.prototype, {
	  constructor: SetMaterialColorCommand,
	  execute: function () {
	    this.object.material[this.attributeName].setHex(this.newValue);
	  },
	  undo: function () {
	    this.object.material[this.attributeName].setHex(this.oldValue);
	  },
	  update: function (cmd) {
	    this.newValue = cmd.newValue;
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.attributeName = this.attributeName;
	    output.oldValue = this.oldValue;
	    output.newValue = this.newValue;
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.attributeName = json.attributeName;
	    this.oldValue = json.oldValue;
	    this.newValue = json.newValue;
	  }
	});

	/**
	 * 设置材质值命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param object THREE.Object3D
	 * @param attributeName string
	 * @param newValue number, string, boolean or object
	 * @constructor
	 */

	function SetMaterialValueCommand(object, attributeName, newValue) {
	  Command.call(this);
	  this.type = 'SetMaterialValueCommand';
	  this.name = _t('Set Material') + '.' + attributeName;
	  this.updatable = true;
	  this.object = object;
	  this.oldValue = object !== undefined ? object.material[attributeName] : undefined;
	  this.newValue = newValue;
	  this.attributeName = attributeName;
	}
	SetMaterialValueCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetMaterialValueCommand.prototype, {
	  constructor: SetMaterialValueCommand,
	  execute: function () {
	    this.object.material[this.attributeName] = this.newValue;
	    this.object.material.needsUpdate = true;
	    app.call('objectChanged', this, this.object);
	  },
	  undo: function () {
	    this.object.material[this.attributeName] = this.oldValue;
	    this.object.material.needsUpdate = true;
	    app.call('objectChanged', this, this.object);
	  },
	  update: function (cmd) {
	    this.newValue = cmd.newValue;
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.attributeName = this.attributeName;
	    output.oldValue = this.oldValue;
	    output.newValue = this.newValue;
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.attributeName = json.attributeName;
	    this.oldValue = json.oldValue;
	    this.newValue = json.newValue;
	    this.object = this.editor.objectByUuid(json.objectUuid);
	  }
	});

	/**
	 * 设置材质纹理命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param object THREE.Object3D
	 * @param mapName string
	 * @param newMap THREE.Texture
	 * @constructor
	 */

	function SetMaterialMapCommand(object, mapName, newMap) {
	  Command.call(this);
	  this.type = 'SetMaterialMapCommand';
	  this.name = _t('Set Material') + '.' + mapName;
	  this.object = object;
	  this.mapName = mapName;
	  this.oldMap = object !== undefined ? object.material[mapName] : undefined;
	  this.newMap = newMap;
	}
	SetMaterialMapCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetMaterialMapCommand.prototype, {
	  constructor: SetMaterialMapCommand,
	  execute: function () {
	    this.object.material[this.mapName] = this.newMap;
	    this.object.material.needsUpdate = true;
	  },
	  undo: function () {
	    this.object.material[this.mapName] = this.oldMap;
	    this.object.material.needsUpdate = true;
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.mapName = this.mapName;
	    output.newMap = serializeMap(this.newMap);
	    output.oldMap = serializeMap(this.oldMap);
	    return output; // serializes a map (THREE.Texture)

	    function serializeMap(map) {
	      if (map === null || map === undefined) return null;
	      var meta = {
	        geometries: {},
	        materials: {},
	        textures: {},
	        images: {}
	      };
	      var json = map.toJSON(meta);
	      var images = extractFromCache(meta.images);
	      if (images.length > 0) json.images = images;
	      json.sourceFile = map.sourceFile;
	      return json;
	    } // Note: The function 'extractFromCache' is copied from Object3D.toJSON()
	    // extract data from the cache hash
	    // remove metadata on each item
	    // and return as array


	    function extractFromCache(cache) {
	      var values = [];

	      for (var key in cache) {
	        var data = cache[key];
	        delete data.metadata;
	        values.push(data);
	      }

	      return values;
	    }
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.mapName = json.mapName;
	    this.oldMap = parseTexture(json.oldMap);
	    this.newMap = parseTexture(json.newMap);

	    function parseTexture(json) {
	      var map = null;

	      if (json !== null) {
	        var loader = new THREE.ObjectLoader();
	        var images = loader.parseImages(json.images);
	        var textures = loader.parseTextures([json], images);
	        map = textures[json.uuid];
	        map.sourceFile = json.sourceFile;
	      }

	      return map;
	    }
	  }
	});

	var ShaderMaterialVertex = "void main()\t{\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}";

	var ShaderMaterialFragment = "void main()\t{\r\n\tgl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n}";

	var RawShaderMaterialVertex = "precision mediump float;\r\n\r\nuniform mat4 modelViewMatrix;\r\nuniform mat4 projectionMatrix;\r\n\r\nattribute vec3 position;\r\n\r\nvoid main()\t{\r\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}";

	var RawShaderMaterialFragment = "precision mediump float;\r\n\r\nvoid main()\t{\r\n\tgl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n}";

	/**
	 * 纹理设置窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class TextureSettingWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.wrapS = {
	      [THREE.ClampToEdgeWrapping]: _t('Clamp To Edge'),
	      [THREE.RepeatWrapping]: _t('Repeat'),
	      [THREE.MirroredRepeatWrapping]: _t('Mirrored Repeat')
	    };
	    this.wrapT = {
	      [THREE.ClampToEdgeWrapping]: _t('Clamp To Edge'),
	      [THREE.RepeatWrapping]: _t('Repeat'),
	      [THREE.MirroredRepeatWrapping]: _t('Mirrored Repeat')
	    };
	    this.magFilter = {
	      [THREE.LinearFilter]: 'LinearFilter',
	      [THREE.NearestFilter]: 'NearestFilter'
	    };
	    this.minFilter = {
	      [THREE.LinearMipMapLinearFilter]: 'LinearMipMapLinearFilter',
	      [THREE.NearestFilter]: 'NearestFilter',
	      [THREE.NearestMipMapNearestFilter]: 'NearestMipMapNearestFilter',
	      [THREE.NearestMipMapLinearFilter]: 'NearestMipMapLinearFilter',
	      [THREE.LinearFilter]: 'LinearFilter',
	      [THREE.LinearMipMapNearestFilter]: 'LinearMipMapNearestFilter'
	    };
	    this.type = {
	      [THREE.UnsignedByteType]: 'UnsignedByteType',
	      [THREE.ByteType]: 'ByteType',
	      [THREE.ShortType]: 'ShortType',
	      [THREE.UnsignedShortType]: 'UnsignedShortType',
	      [THREE.IntType]: 'IntType',
	      [THREE.UnsignedIntType]: 'UnsignedIntType',
	      [THREE.FloatType]: 'FloatType',
	      [THREE.HalfFloatType]: 'HalfFloatType',
	      [THREE.UnsignedShort4444Type]: 'UnsignedShort4444Type',
	      [THREE.UnsignedShort5551Type]: 'UnsignedShort5551Type',
	      [THREE.UnsignedShort565Type]: 'UnsignedShort565Type',
	      [THREE.UnsignedInt248Type]: 'UnsignedInt248Type'
	    };
	    this.encoding = {
	      [THREE.LinearEncoding]: 'LinearEncoding',
	      [THREE.sRGBEncoding]: 'sRGBEncoding',
	      [THREE.GammaEncoding]: 'GammaEncoding',
	      [THREE.RGBEEncoding]: 'RGBEEncoding',
	      [THREE.LogLuvEncoding]: 'LogLuvEncoding',
	      [THREE.RGBM7Encoding]: 'RGBM7Encoding',
	      [THREE.RGBM16Encoding]: 'RGBM16Encoding',
	      [THREE.RGBDEncoding]: 'RGBDEncoding',
	      [THREE.BasicDepthPacking]: 'BasicDepthPacking',
	      [THREE.RGBADepthPacking]: 'RGBADepthPacking'
	    };
	    this.format = {
	      [THREE.RGBAFormat]: 'RGBAFormat',
	      [THREE.AlphaFormat]: 'AlphaFormat',
	      [THREE.RGBFormat]: 'RGBFormat',
	      [THREE.LuminanceFormat]: 'LuminanceFormat',
	      [THREE.LuminanceAlphaFormat]: 'LuminanceAlphaFormat',
	      [THREE.RGBEFormat]: 'RGBEFormat',
	      [THREE.DepthFormat]: 'DepthFormat',
	      [THREE.DepthStencilFormat]: 'DepthStencilFormat'
	    };
	    this.mapping = {
	      [THREE.UVMapping]: 'UVMapping',
	      [THREE.CubeReflectionMapping]: 'CubeReflectionMapping',
	      [THREE.CubeRefractionMapping]: 'CubeRefractionMapping',
	      [THREE.EquirectangularReflectionMapping]: 'EquirectangularReflectionMapping',
	      [THREE.EquirectangularRefractionMapping]: 'EquirectangularRefractionMapping',
	      [THREE.SphericalReflectionMapping]: 'SphericalReflectionMapping',
	      [THREE.CubeUVReflectionMapping]: 'CubeUVReflectionMapping',
	      [THREE.CubeUVRefractionMapping]: 'CubeUVRefractionMapping'
	    };
	    this.unpackAlignment = {
	      [4]: '4',
	      [1]: '1',
	      [2]: '2',
	      [8]: '8'
	    };
	    const {
	      anisotropy,
	      center,
	      offset,
	      repeat,
	      rotation,
	      type,
	      encoding,
	      flipY,
	      format,
	      generateMipmaps,
	      magFilter,
	      minFilter,
	      mapping,
	      premultiplyAlpha,
	      unpackAlignment,
	      wrapS,
	      wrapT
	    } = this.props.map;
	    const centerX = center.x,
	          centerY = center.y,
	          offsetX = offset.x,
	          offsetY = offset.y,
	          repeatX = repeat.x,
	          repeatY = repeat.y;
	    this.state = {
	      anisotropy,
	      center,
	      offset,
	      repeat,
	      rotation,
	      type,
	      encoding,
	      flipY,
	      format,
	      generateMipmaps,
	      magFilter,
	      minFilter,
	      mapping,
	      premultiplyAlpha,
	      unpackAlignment,
	      wrapS,
	      wrapT,
	      centerX,
	      centerY,
	      offsetX,
	      offsetY,
	      repeatX,
	      repeatY
	    };
	    this.handleChange = this.handleChange.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      anisotropy,
	      center,
	      offset,
	      repeat,
	      rotation,
	      type,
	      encoding,
	      flipY,
	      format,
	      generateMipmaps,
	      magFilter,
	      minFilter,
	      mapping,
	      premultiplyAlpha,
	      unpackAlignment,
	      wrapS,
	      wrapT,
	      centerX,
	      centerY,
	      offsetX,
	      offsetY,
	      repeatX,
	      repeatY
	    } = this.state;
	    return React.createElement(Window, {
	      className: 'TextureSettingWindow',
	      title: _t('Texture Settings'),
	      style: {
	        width: '360px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, React.createElement(Content, null, React.createElement(Form, null, React.createElement(FormControl, null, React.createElement(Label, null, _t('Center X')), React.createElement(Input, {
	      name: 'centerX',
	      value: centerX,
	      type: 'number',
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Center Y')), React.createElement(Input, {
	      name: 'centerY',
	      value: centerY,
	      type: 'number',
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Offset X')), React.createElement(Input, {
	      name: 'offsetX',
	      value: offsetX,
	      type: 'number',
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Offset Y')), React.createElement(Input, {
	      name: 'offsetY',
	      value: offsetY,
	      type: 'number',
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Repeat X')), React.createElement(Input, {
	      name: 'repeatX',
	      value: repeatX,
	      type: 'number',
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Repeat Y')), React.createElement(Input, {
	      name: 'repeatY',
	      value: repeatY,
	      type: 'number',
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Rotation')), React.createElement(Input, {
	      name: 'rotation',
	      value: rotation,
	      type: 'number',
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('WrapS')), React.createElement(Select, {
	      options: this.wrapS,
	      name: 'wrapS',
	      value: wrapS,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('WrapT')), React.createElement(Select, {
	      options: this.wrapT,
	      name: 'wrapT',
	      value: wrapT,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('FlipY')), React.createElement(CheckBox, {
	      name: 'flipY',
	      checked: flipY,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Mag Filter')), React.createElement(Select, {
	      options: this.magFilter,
	      name: 'magFilter',
	      value: magFilter,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Min Filter')), React.createElement(Select, {
	      options: this.minFilter,
	      name: 'minFilter',
	      value: minFilter,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Type')), React.createElement(Select, {
	      options: this.type,
	      name: 'type',
	      value: type,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Encoding')), React.createElement(Select, {
	      options: this.encoding,
	      name: 'encoding',
	      value: encoding,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Format')), React.createElement(Select, {
	      options: this.format,
	      name: 'format',
	      value: format,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Generate Mipmaps')), React.createElement(CheckBox, {
	      name: 'generateMipmaps',
	      checked: generateMipmaps,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Mapping')), React.createElement(Select, {
	      options: this.mapping,
	      name: 'mapping',
	      value: mapping,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Premultiply Alpha')), React.createElement(CheckBox, {
	      name: 'premultiplyAlpha',
	      checked: premultiplyAlpha,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Unpack Alignment')), React.createElement(Select, {
	      options: this.unpackAlignment,
	      name: 'unpackAlignment',
	      value: unpackAlignment,
	      onChange: this.handleChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Anisotropy')), React.createElement(Input, {
	      name: 'anisotropy',
	      value: anisotropy,
	      type: 'number',
	      precision: 0,
	      onChange: this.handleChange
	    })))), React.createElement(Buttons, null, React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Close'))));
	  }

	  handleChange(value, name) {
	    this.setState({
	      [name]: value
	    });

	    if (value === null) {
	      return;
	    }

	    const {
	      anisotropy,
	      center,
	      offset,
	      repeat,
	      rotation,
	      type,
	      encoding,
	      flipY,
	      format,
	      generateMipmaps,
	      magFilter,
	      minFilter,
	      mapping,
	      premultiplyAlpha,
	      unpackAlignment,
	      wrapS,
	      wrapT,
	      centerX,
	      centerY,
	      offsetX,
	      offsetY,
	      repeatX,
	      repeatY
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let map = this.props.map;
	    Object.assign(map, {
	      anisotropy,
	      rotation,
	      type: parseInt(type),
	      encoding: parseInt(encoding),
	      flipY,
	      format: parseInt(format),
	      generateMipmaps,
	      magFilter: parseInt(magFilter),
	      minFilter: parseInt(minFilter),
	      mapping: parseInt(mapping),
	      premultiplyAlpha,
	      unpackAlignment: parseInt(unpackAlignment),
	      wrapS: parseInt(wrapS),
	      wrapT: parseInt(wrapT)
	    });
	    map.center.set(centerX, centerY);
	    map.offset.set(offsetX, offsetY);
	    map.repeat.set(repeatX, repeatY);
	    map.needsUpdate = true;
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	TextureSettingWindow.propTypes = {
	  map: (props, propName, componentName) => {
	    const map = props[propName];

	    if (!(map instanceof THREE.Texture)) {
	      return new TypeError(`Invalid prop \`${propName}\` of type supplied to \`${componentName}\`, expected \`THREE.Texture\`.`);
	    }
	  }
	};
	TextureSettingWindow.defaultProps = {
	  map: null
	};

	/**
	 * 创建材质球图片
	 * @param {*} material 材质
	 * @param {*} width 宽度
	 * @param {*} height 高度
	 */
	function createMaterialImage(material, width = 160, height = 160) {
	  var scene = new THREE.Scene();
	  var camera = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, 0, 1000);
	  camera.position.z = 80;
	  var renderer = new THREE.WebGLRenderer({
	    antialias: true
	  });
	  renderer.setSize(width, height);
	  var light1 = new THREE.AmbientLight(0xffffff, 0.3);
	  scene.add(light1);
	  var light2 = new THREE.DirectionalLight(0xffffff, 0.8);
	  scene.add(light2);
	  light2.position.set(0, 10, 10);
	  light2.lookAt(new THREE.Vector3());
	  var geometry = new THREE.SphereBufferGeometry(72, 32, 32);
	  var mesh = new THREE.Mesh(geometry, material);
	  scene.add(mesh);
	  renderer.setClearColor(0xeeeeee);
	  renderer.clear();
	  renderer.render(scene, camera);
	  geometry.dispose();
	  renderer.dispose();
	  return renderer.domElement;
	}
	/**
	 * 材质工具类
	 */


	const MaterialUtils = {
	  createMaterialImage: createMaterialImage
	};

	/**
	 * 材质组件
	 * @author tengge / https://github.com/tengge1
	 */

	class MaterialComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.materials = {
	      'LineBasicMaterial': _t('LineBasicMaterial'),
	      'LineDashedMaterial': _t('LineDashedMaterial'),
	      'MeshBasicMaterial': _t('MeshBasicMaterial'),
	      'MeshDepthMaterial': _t('MeshDepthMaterial'),
	      'MeshNormalMaterial': _t('MeshNormalMaterial'),
	      'MeshLambertMaterial': _t('MeshLambertMaterial'),
	      'MeshPhongMaterial': _t('MeshPhongMaterial'),
	      'PointsMaterial': _t('PointCloudMaterial'),
	      'MeshStandardMaterial': _t('MeshStandardMaterial'),
	      'MeshPhysicalMaterial': _t('MeshPhysicalMaterial'),
	      'SpriteMaterial': _t('SpriteMaterial'),
	      'ShaderMaterial': _t('ShaderMaterial'),
	      'RawShaderMaterial': _t('RawShaderMaterial')
	    };
	    this.vertexColors = {
	      0: _t('No Colors'),
	      1: _t('Face Colors'),
	      2: _t('Vertex Colors')
	    };
	    this.side = {
	      0: _t('Front Side'),
	      1: _t('Back Side'),
	      2: _t('Double Side')
	    };
	    this.blending = {
	      0: _t('No Blending'),
	      1: _t('Normal Blending'),
	      2: _t('Additive Blending'),
	      3: _t('Substractive Blending'),
	      4: _t('Multiply Blending'),
	      5: _t('Custom Blending')
	    };
	    this.mapNames = [// 用于判断属性是否是纹理
	    'map', 'alphaMap', 'bumpMap', 'normalMap', 'displacementMap', 'roughnessMap', 'metalnessMap', 'specularMap', 'envMap', 'lightMap', 'aoMap', 'emissiveMap'];
	    this.state = {
	      show: false,
	      expanded: false,
	      type: null,
	      showProgram: false,
	      showColor: false,
	      color: null,
	      showRoughness: false,
	      roughness: null,
	      showMetalness: false,
	      metalness: null,
	      showEmissive: false,
	      emissive: null,
	      showSpecular: false,
	      specular: null,
	      showShininess: false,
	      shininess: null,
	      showClearCoat: false,
	      clearCoat: null,
	      showClearCoatRoughness: false,
	      clearCoatRoughness: null,
	      showVertexColors: false,
	      vertexColors: null,
	      showSkinning: false,
	      skinning: null,
	      showMap: false,
	      map: null,
	      showAlphaMap: false,
	      alphaMap: null,
	      showBumpMap: false,
	      bumpMap: null,
	      bumpScale: null,
	      showNormalMap: false,
	      normalMap: null,
	      showDisplacementMap: false,
	      displacementMap: null,
	      displacementScale: null,
	      showRoughnessMap: false,
	      roughnessMap: null,
	      showMetalnessMap: false,
	      metalnessMap: null,
	      showSpecularMap: false,
	      specularMap: null,
	      showEnvMap: false,
	      envMap: null,
	      reflectivity: null,
	      showLightMap: false,
	      lightMap: null,
	      showAoMap: false,
	      aoMap: null,
	      aoScale: null,
	      showEmissiveMap: false,
	      emissiveMap: null,
	      showSide: false,
	      side: null,
	      showFlatShading: false,
	      flatShading: null,
	      showBlending: false,
	      blending: null,
	      showOpacity: false,
	      opacity: 1,
	      showTransparent: false,
	      transparent: false,
	      showAlphaTest: false,
	      alphaTest: 1,
	      showWireframe: false,
	      wireframe: false,
	      wireframeLinewidth: 1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	    this.handleTextureSetting = this.handleTextureSetting.bind(this);
	    this.editProgramInfo = this.editProgramInfo.bind(this);
	    this.saveProgramInfo = this.saveProgramInfo.bind(this);
	    this.editVertexShader = this.editVertexShader.bind(this);
	    this.saveVertexShader = this.saveVertexShader.bind(this);
	    this.editFragmentShader = this.editFragmentShader.bind(this);
	    this.saveFragmentShader = this.saveFragmentShader.bind(this);
	    this.onSave = this.onSave.bind(this);
	    this.onLoad = this.onLoad.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      type,
	      showProgram,
	      showColor,
	      color,
	      showRoughness,
	      roughness,
	      showMetalness,
	      metalness,
	      showEmissive,
	      emissive,
	      showSpecular,
	      specular,
	      showShininess,
	      shininess,
	      showClearCoat,
	      clearCoat,
	      showClearCoatRoughness,
	      clearCoatRoughness,
	      showVertexColors,
	      vertexColors,
	      showSkinning,
	      skinning,
	      showMap,
	      map,
	      showAlphaMap,
	      alphaMap,
	      showBumpMap,
	      bumpMap,
	      bumpScale,
	      showNormalMap,
	      normalMap,
	      showDisplacementMap,
	      displacementMap,
	      displacementScale,
	      showRoughnessMap,
	      roughnessMap,
	      showMetalnessMap,
	      metalnessMap,
	      showSpecularMap,
	      specularMap,
	      showEnvMap,
	      envMap,
	      reflectivity,
	      showLightMap,
	      lightMap,
	      showAoMap,
	      aoMap,
	      aoScale,
	      showEmissiveMap,
	      emissiveMap,
	      showSide,
	      side,
	      showFlatShading,
	      flatShading,
	      showBlending,
	      blending,
	      showOpacity,
	      opacity,
	      showTransparent,
	      transparent,
	      showAlphaTest,
	      alphaTest,
	      showWireframe,
	      wireframe,
	      wireframeLinewidth
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Material Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(ButtonsProperty, {
	      label: ''
	    }, React.createElement(Button, {
	      onClick: this.onSave
	    }, _t('Save')), React.createElement(Button, {
	      onClick: this.onLoad
	    }, _t('Select'))), React.createElement(SelectProperty, {
	      label: _t('Type'),
	      options: this.materials,
	      name: 'type',
	      value: type,
	      onChange: this.handleChange
	    }), React.createElement(ButtonProperty, {
	      label: _t('ShaderInfo'),
	      text: _t('Edit'),
	      show: showProgram,
	      onChange: this.editProgramInfo
	    }), React.createElement(ButtonProperty, {
	      label: _t('Vertex Shader'),
	      text: _t('Edit'),
	      show: showProgram,
	      onChange: this.editVertexShader
	    }), React.createElement(ButtonProperty, {
	      label: _t('Frag Shader'),
	      text: _t('Edit'),
	      show: showProgram,
	      onChange: this.editFragmentShader
	    }), React.createElement(ColorProperty, {
	      label: _t('Color'),
	      name: 'color',
	      value: color,
	      show: showColor,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Roughness'),
	      name: 'roughness',
	      value: roughness,
	      show: showRoughness,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('MetalNess'),
	      name: 'metalness',
	      value: metalness,
	      show: showMetalness,
	      onChange: this.handleChange
	    }), React.createElement(ColorProperty, {
	      label: _t('Emissive'),
	      name: 'emissive',
	      value: emissive,
	      show: showEmissive,
	      onChange: this.handleChange
	    }), React.createElement(ColorProperty, {
	      label: _t('Specular'),
	      name: 'specular',
	      value: specular,
	      show: showSpecular,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Shininess'),
	      name: 'shininess',
	      value: shininess,
	      show: showShininess,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('ClearCoat'),
	      name: 'clearCoat',
	      value: clearCoat,
	      show: showClearCoat,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('ClearCoatRoughness'),
	      name: 'clearCoatRoughness',
	      value: clearCoatRoughness,
	      show: showClearCoatRoughness,
	      onChange: this.handleChange
	    }), React.createElement(SelectProperty, {
	      label: _t('Vertex Color'),
	      options: this.vertexColors,
	      name: 'vertexColors',
	      value: vertexColors,
	      show: showVertexColors,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('Skin'),
	      name: 'skinning',
	      value: skinning,
	      show: showSkinning,
	      onChange: this.handleChange
	    }), React.createElement(TextureProperty, {
	      label: _t('Map'),
	      name: 'map',
	      value: map,
	      show: showMap,
	      onChange: this.handleChange
	    }), React.createElement(ButtonProperty, {
	      text: _t('Texture Settings'),
	      onChange: this.handleTextureSetting
	    }), React.createElement(TextureProperty, {
	      label: _t('AlphaMap'),
	      name: 'alphaMap',
	      value: alphaMap,
	      show: showAlphaMap,
	      onChange: this.handleChange
	    }), React.createElement(TextureProperty, {
	      label: _t('BumpMap'),
	      name: 'bumpMap',
	      value: bumpMap,
	      show: showBumpMap,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Bump Scale'),
	      name: 'bumpScale',
	      value: bumpScale,
	      show: showBumpMap,
	      onChange: this.handleChange
	    }), React.createElement(TextureProperty, {
	      label: _t('NormalMap'),
	      name: 'normalMap',
	      value: normalMap,
	      show: showNormalMap,
	      onChange: this.handleChange
	    }), React.createElement(TextureProperty, {
	      label: _t('DisplacementMap'),
	      name: 'displacementMap',
	      value: displacementMap,
	      show: showDisplacementMap,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Displace Scale'),
	      name: 'displacementScale',
	      value: displacementScale,
	      show: showDisplacementMap,
	      onChange: this.handleChange
	    }), React.createElement(TextureProperty, {
	      label: _t('RoughnessMap'),
	      name: 'roughnessMap',
	      value: roughnessMap,
	      show: showRoughnessMap,
	      onChange: this.handleChange
	    }), React.createElement(TextureProperty, {
	      label: _t('MetalnessMap'),
	      name: 'metalnessMap',
	      value: metalnessMap,
	      show: showMetalnessMap,
	      onChange: this.handleChange
	    }), React.createElement(TextureProperty, {
	      label: _t('SpecularMap'),
	      name: 'specularMap',
	      value: specularMap,
	      show: showSpecularMap,
	      onChange: this.handleChange
	    }), React.createElement(TextureProperty, {
	      label: _t('EnvMap'),
	      name: 'envMap',
	      value: envMap,
	      show: showEnvMap,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Reflectivity'),
	      name: 'reflectivity',
	      value: reflectivity,
	      show: showEnvMap,
	      onChange: this.handleChange
	    }), React.createElement(TextureProperty, {
	      label: _t('LightMap'),
	      name: 'lightMap',
	      value: lightMap,
	      show: showLightMap,
	      onChange: this.handleChange
	    }), React.createElement(TextureProperty, {
	      label: _t('AoMap'),
	      name: 'aoMap',
	      value: aoMap,
	      show: showAoMap,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Ao Scale'),
	      name: 'aoScale',
	      value: aoScale,
	      show: showAoMap,
	      onChange: this.handleChange
	    }), React.createElement(TextureProperty, {
	      label: _t('EmissiveMap'),
	      name: 'emissiveMap',
	      value: emissiveMap,
	      show: showEmissiveMap,
	      onChange: this.handleChange
	    }), React.createElement(SelectProperty, {
	      label: _t('Side'),
	      options: this.side,
	      name: 'side',
	      value: side,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('Flat Shading'),
	      name: 'flatShading',
	      value: flatShading,
	      onChange: this.handleChange
	    }), React.createElement(SelectProperty, {
	      label: _t('Blending'),
	      options: this.blending,
	      name: 'blending',
	      value: blending,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Opacity'),
	      name: 'opacity',
	      value: opacity,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('Transparent'),
	      name: 'transparent',
	      value: transparent,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('AlphaTest'),
	      name: 'alphaTest',
	      value: alphaTest,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('Wireframe'),
	      name: 'wireframe',
	      value: wireframe,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('WireWidth'),
	      name: 'wireframeLinewidth',
	      value: wireframeLinewidth,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.MaterialComponent`, this.handleUpdate);
	    app.on(`objectChanged.MaterialComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected.material instanceof THREE.Material)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let material = this.selected.material;
	    let state = {
	      show: true,
	      type: material.type,
	      showProgram: material instanceof THREE.ShaderMaterial || material instanceof THREE.RawShaderMaterial
	    };

	    if (material.color) {
	      state.showColor = true;
	      state.color = `#${material.color.getHexString()}`;
	    } else {
	      state.showColor = false;
	    }

	    if (material.roughness !== undefined) {
	      state.showRoughness = true;
	      state.roughness = material.roughness;
	    } else {
	      state.showRoughness = false;
	    }

	    if (material.metalness !== undefined) {
	      state.showMetalness = true;
	      state.metalness = material.metalness;
	    } else {
	      state.showMetalness = false;
	    }

	    if (material.emissive !== undefined) {
	      state.showEmissive = true;
	      state.emissive = `#${material.emissive.getHexString()}`;
	    } else {
	      state.showEmissive = false;
	    }

	    if (material.specular !== undefined) {
	      state.showSpecular = true;
	      state.specular = `#${material.specular.getHexString()}`;
	    } else {
	      state.showSpecular = false;
	    }

	    if (material.shininess !== undefined) {
	      state.showShininess = true;
	      state.shininess = material.shininess;
	    } else {
	      state.showShininess = false;
	    }

	    if (material.clearCoat !== undefined) {
	      state.showClearCoat = true;
	      state.clearCoat = material.clearCoat;
	    } else {
	      state.showClearCoat = false;
	    }

	    if (material.clearCoatRoughness !== undefined) {
	      state.showClearCoatRoughness = true;
	      state.clearCoatRoughness = material.clearCoatRoughness;
	    } else {
	      state.showClearCoatRoughness = false;
	    }

	    if (material.vertexColors !== undefined) {
	      state.showVertexColors = true;
	      state.vertexColors = material.vertexColors;
	    } else {
	      state.showVertexColors = false;
	    }

	    if (material.skinning !== undefined) {
	      state.showSkinning = true;
	      state.skinning = material.skinning;
	    } else {
	      state.showSkinning = false;
	    }

	    if (material.map !== undefined) {
	      state.showMap = true;
	      state.map = material.map;
	    } else {
	      state.showMap = false;
	    }

	    if (material.alphaMap !== undefined) {
	      state.showAlphaMap = true;
	      state.alphaMap = material.alphaMap;
	    } else {
	      state.showAlphaMap = false;
	    }

	    if (material.bumpMap !== undefined) {
	      state.showBumpMap = true;
	      state.bumpMap = material.bumpMap;
	      state.bumpScale = material.bumpScale;
	    } else {
	      state.showBumpMap = false;
	    }

	    if (material.normalMap !== undefined) {
	      state.showNormalMap = true;
	      state.normalMap = material.normalMap;
	    } else {
	      state.showNormalMap = false;
	    }

	    if (material.displacementMap !== undefined) {
	      state.showDisplacementMap = true;
	      state.displacementMap = material.displacementMap;
	      state.displacementScale = material.displacementScale;
	    } else {
	      state.showDisplacementMap = false;
	    }

	    if (material.roughnessMap !== undefined) {
	      state.showRoughnessMap = true;
	      state.roughnessMap = material.roughnessMap;
	    } else {
	      state.showRoughnessMap = false;
	    }

	    if (material.metalnessMap !== undefined) {
	      state.showMetalnessMap = true;
	      state.metalnessMap = material.metalnessMap;
	    } else {
	      state.showMetalnessMap = false;
	    }

	    if (material.specularMap !== undefined) {
	      state.showSpecularMap = true;
	      state.specularMap = material.specularMap;
	    } else {
	      state.showSpecularMap = false;
	    }

	    if (material.envMap !== undefined) {
	      state.showEnvMap = true;
	      state.envMap = material.envMap;

	      if (material.reflectivity !== undefined) {
	        state.reflectivity = material.reflectivity;
	      }
	    } else {
	      state.showEnvMap = false;
	    }

	    if (material.lightMap !== undefined) {
	      state.showLightMap = true;
	      state.lightMap = material.lightMap;
	    } else {
	      state.showLightMap = false;
	    }

	    if (material.aoMap !== undefined) {
	      state.showAoMap = true;
	      state.aoMap = material.aoMap;
	      state.aoScale = material.aoMapIntensity;
	    } else {
	      state.showAoMap = false;
	    }

	    if (material.emissiveMap !== undefined) {
	      state.showEmissiveMap = true;
	      state.emissiveMap = material.emissiveMap;
	    } else {
	      state.showEmissiveMap = false;
	    }

	    if (material.side !== undefined) {
	      state.side = material.side;
	    }

	    if (material.flatShading !== undefined) {
	      state.flatShading = material.flatShading;
	    }

	    if (material.blending !== undefined) {
	      state.blending = material.blending;
	    }

	    if (material.opacity !== undefined) {
	      state.opacity = material.opacity;
	    }

	    if (material.transparent !== undefined) {
	      state.transparent = material.transparent;
	    }

	    if (material.alphaTest !== undefined) {
	      state.alphaTest = material.alphaTest;
	    }

	    if (material.wireframe !== undefined) {
	      state.wireframe = material.wireframe;
	    }

	    if (material.wireframeLinewidth !== undefined) {
	      state.wireframeLinewidth = material.wireframeLinewidth;
	    }

	    this.setState(state);
	  }

	  handleChange(value, name) {
	    // 当name是纹理时，value为null表示不显示纹理，不应该跳过。
	    if (value === null && this.mapNames.indexOf(name) === -1) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const editor = app.editor;
	    const object = this.selected;
	    let material = object.material;
	    const {
	      type,
	      showProgram,
	      showColor,
	      color,
	      showRoughness,
	      roughness,
	      showMetalness,
	      metalness,
	      showEmissive,
	      emissive,
	      showSpecular,
	      specular,
	      showShininess,
	      shininess,
	      showClearCoat,
	      clearCoat,
	      showClearCoatRoughness,
	      clearCoatRoughness,
	      showVertexColors,
	      vertexColors,
	      showSkinning,
	      skinning,
	      showMap,
	      map,
	      showAlphaMap,
	      alphaMap,
	      showBumpMap,
	      bumpMap,
	      bumpScale,
	      showNormalMap,
	      normalMap,
	      showDisplacementMap,
	      displacementMap,
	      displacementScale,
	      showRoughnessMap,
	      roughnessMap,
	      showMetalnessMap,
	      metalnessMap,
	      showSpecularMap,
	      specularMap,
	      showEnvMap,
	      envMap,
	      reflectivity,
	      showLightMap,
	      lightMap,
	      showAoMap,
	      aoMap,
	      aoScale,
	      showEmissiveMap,
	      emissiveMap,
	      showSide,
	      side,
	      showFlatShading,
	      flatShading,
	      showBlending,
	      blending,
	      showOpacity,
	      opacity,
	      showTransparent,
	      transparent,
	      showAlphaTest,
	      alphaTest,
	      showWireframe,
	      wireframe,
	      wireframeLinewidth
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });

	    if (material instanceof THREE[type] === false) {
	      material = new THREE[type]();

	      if (material instanceof THREE.ShaderMaterial) {
	        material.uniforms = {
	          time: {
	            value: 1.0
	          }
	        };
	        material.vertexShader = ShaderMaterialVertex;
	        material.fragmentShader = ShaderMaterialFragment;
	      }

	      if (material instanceof THREE.RawShaderMaterial) {
	        material.uniforms = {
	          time: {
	            value: 1.0
	          }
	        };
	        material.vertexShader = RawShaderMaterialVertex;
	        material.fragmentShader = RawShaderMaterialFragment;
	      }

	      editor.execute(new SetMaterialCommand(object, material), _t('New Material') + ':' + type);
	    }

	    if (material.color !== undefined && `#${material.color.getHexString()}` !== color) {
	      editor.execute(new SetMaterialColorCommand(object, 'color', color));
	    }

	    if (material.roughness !== undefined && Math.abs(material.roughness - roughness) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'roughness', roughness));
	    }

	    if (material.metalness !== undefined && Math.abs(material.metalness - metalness) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'metalness', metalness));
	    }

	    if (material.emissive !== undefined && `#${material.emissive.getHexString()}` !== emissive) {
	      editor.execute(new SetMaterialColorCommand(object, 'emissive', emissive));
	    }

	    if (material.specular !== undefined && `#${material.specular.getHexString()}` !== specular) {
	      editor.execute(new SetMaterialColorCommand(object, 'specular', specular));
	    }

	    if (material.shininess !== undefined && Math.abs(material.shininess - shininess) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'shininess', shininess));
	    }

	    if (material.clearCoat !== undefined && Math.abs(material.clearCoat - clearCoat) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'clearCoat', clearCoat));
	    }

	    if (material.clearCoatRoughness !== undefined && Math.abs(material.clearCoatRoughness - clearCoatRoughness) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'clearCoatRoughness', clearCoatRoughness));
	    }

	    if (material.vertexColors !== undefined && material.vertexColors !== vertexColors) {
	      editor.execute(new SetMaterialValueCommand(object, 'vertexColors', vertexColors));
	    }

	    if (material.skinning !== undefined && material.skinning !== skinning) {
	      editor.execute(new SetMaterialValueCommand(object, 'skinning', skinning));
	    }

	    if (name === 'map' && material.map !== undefined) {
	      if (material.map !== map) {
	        editor.execute(new SetMaterialMapCommand(object, 'map', map));
	      }
	    }

	    if (name === 'alphaMap' && material.alphaMap !== undefined) {
	      if (material.alphaMap !== alphaMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'alphaMap', alphaMap));
	      }
	    }

	    if (name === 'bumpMap' && material.bumpMap !== undefined) {
	      if (material.bumpMap !== bumpMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'bumpMap', bumpMap));
	      }
	    }

	    if (name === 'bumpScale' && material.bumpScale !== undefined) {
	      editor.execute(new SetMaterialValueCommand(object, 'bumpScale', bumpScale));
	    }

	    if (name === 'normalMap' && material.normalMap !== undefined) {
	      if (material.normalMap !== normalMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'normalMap', normalMap));
	      }
	    }

	    if (name === 'displacementMap' && material.displacementMap !== undefined) {
	      if (material.displacementMap !== displacementMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'displacementMap', displacementMap));
	      }
	    }

	    if (name === 'displacementScale' && material.displacementScale !== undefined) {
	      editor.execute(new SetMaterialValueCommand(object, 'displacementScale', displacementScale));
	    }

	    if (name === 'roughnessMap' && material.roughnessMap !== undefined) {
	      if (material.roughnessMap !== roughnessMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'roughnessMap', roughnessMap));
	      }
	    }

	    if (name === 'metalnessMap' && material.metalnessMap !== undefined) {
	      if (material.metalnessMap !== metalnessMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'metalnessMap', metalnessMap));
	      }
	    }

	    if (name === 'specularMap' && material.specularMap !== undefined) {
	      if (material.specularMap !== specularMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'specularMap', specularMap));
	      }
	    }

	    if (name === 'envMap' && material.envMap !== undefined) {
	      if (material.envMap !== envMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'envMap', envMap));
	      }
	    }

	    if (name === 'reflectivity' && material.reflectivity !== undefined) {
	      editor.execute(new SetMaterialValueCommand(object, 'reflectivity', reflectivity));
	    }

	    if (name === 'lightMap' && material.lightMap !== undefined) {
	      if (material.lightMap !== lightMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'lightMap', lightMap));
	      }
	    }

	    if (name === 'aoMap' && material.aoMap !== undefined) {
	      if (material.aoMap !== aoMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'aoMap', aoMap));
	      }
	    }

	    if (name === 'aoScale' && material.aoMapIntensity !== undefined) {
	      editor.execute(new SetMaterialValueCommand(object, 'aoMapIntensity', aoScale));
	    }

	    if (name === 'emissiveMap' && material.emissiveMap !== undefined) {
	      if (material.emissiveMap !== emissiveMap) {
	        editor.execute(new SetMaterialMapCommand(object, 'emissiveMap', emissiveMap));
	      }
	    }

	    if (material.side !== undefined && material.side !== side) {
	      editor.execute(new SetMaterialValueCommand(object, 'side', side));
	    }

	    if (material.flatShading !== undefined && material.flatShading != flatShading) {
	      editor.execute(new SetMaterialValueCommand(object, 'flatShading', flatShading));
	    }

	    if (material.blending !== undefined && material.blending !== blending) {
	      editor.execute(new SetMaterialValueCommand(object, 'blending', blending));
	    }

	    if (material.opacity !== undefined && Math.abs(material.opacity - opacity) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'opacity', opacity));
	    }

	    if (material.transparent !== undefined && material.transparent !== transparent) {
	      editor.execute(new SetMaterialValueCommand(object, 'transparent', transparent));
	    }

	    if (material.alphaTest !== undefined && Math.abs(material.alphaTest - alphaTest) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'alphaTest', alphaTest));
	    }

	    if (material.wireframe !== undefined && material.wireframe !== wireframe) {
	      editor.execute(new SetMaterialValueCommand(object, 'wireframe', wireframe));
	    }

	    if (material.wireframeLinewidth !== undefined && Math.abs(material.wireframeLinewidth - wireframeLinewidth) >= 0.01) {
	      editor.execute(new SetMaterialValueCommand(object, 'wireframeLinewidth', wireframeLinewidth));
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleTextureSetting() {
	    if (!this.selected.material.map) {
	      app.toast(_t('Please select texture first.'));
	      return;
	    }

	    let win = app.createElement(TextureSettingWindow, {
	      map: this.selected.material.map
	    });
	    app.addElement(win);
	  }

	  editProgramInfo() {
	    let material = this.selected.material;
	    let obj = {
	      defines: material.defines,
	      uniforms: material.uniforms,
	      attributes: material.attributes
	    };
	    app.call(`editScript`, this, material.uuid, this.selected.name + '-ProgramInfo', 'json', JSON.stringify(obj), this.saveProgramInfo);
	  }

	  saveProgramInfo(uuid, name, type, source) {
	    let material = this.selected.material;

	    try {
	      let obj = JSON.parse(source);
	      material.defines = obj.defines;
	      material.uniforms = obj.uniforms;
	      material.attributes = obj.attributes;
	      material.needsUpdate = true;
	    } catch (e) {
	      app.error(this.selected.name + `-${_t('Shader cannot be parsed.')}`);
	    }
	  }

	  editVertexShader() {
	    let material = this.selected.material;
	    app.call(`editScript`, this, material.uuid, this.selected.name + '-VertexShader', 'vertexShader', material.vertexShader, this.saveVertexShader);
	  }

	  saveVertexShader(uuid, name, type, source) {
	    let material = this.selected.material;
	    material.vertexShader = source;
	    material.needsUpdate = true;
	  }

	  editFragmentShader() {
	    let material = this.selected.material;
	    app.call(`editScript`, this, material.uuid, this.selected.name + '-FragmentShader', 'fragmentShader', material.fragmentShader, this.saveFragmentShader);
	  }

	  saveFragmentShader(uuid, name, type, source) {
	    let material = this.selected.material;
	    material.fragmentShader = source;
	    material.needsUpdate = true;
	  } // --------------------------------------- 材质保存载入 --------------------------------------------------


	  onSave() {
	    app.prompt({
	      title: _t('Please enter material name'),
	      content: _t('Name'),
	      value: _t('New Material'),
	      onOK: value => {
	        this.commitSave(value);
	      }
	    });
	  }

	  commitSave(name) {
	    const material = this.selected.material;
	    const data = new MaterialsSerializer().toJSON(material); // 材质球图片

	    const dataURL = MaterialUtils.createMaterialImage(material).toDataURL('image/png');
	    const file = Converter$1.dataURLtoFile(dataURL, name); // 上传图片

	    Ajax.post(`${app.options.server}/api/Upload/Upload`, {
	      file: file
	    }, result => {
	      let obj = JSON.parse(result);

	      if (obj.Code === 300) {
	        app.toast(_t(obj.Msg));
	        return;
	      }

	      Ajax.post(`${app.options.server}/api/Material/Save`, {
	        Name: name,
	        Data: JSON.stringify(data),
	        Thumbnail: obj.Data.url
	      }, result => {
	        obj = JSON.parse(result);

	        if (obj.Code === 200) {
	          app.call(`showBottomPanel`, this, 'material');
	        }

	        app.toast(_t(obj.Msg));
	      });
	    });
	  }

	  onLoad() {
	    app.call(`selectBottomPanel`, this, 'material');
	    app.toast(_t('Please click material on material panel.'));
	    app.on(`selectMaterial.MaterialComponent`, this.onWaitingForMaterial.bind(this));
	  }

	  onWaitingForMaterial(material) {
	    app.on(`selectMaterial.MaterialComponent`, null);

	    if (this.selected.material) {
	      this.selected.material.dispose();
	    }

	    this.selected.material = material;
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * MMD模型组件
	 * @author tengge / https://github.com/tengge1
	 */

	class MMDComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: true,
	      animation: null,
	      cameraAnimation: null,
	      audio: null
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleSelectAnimation = this.handleSelectAnimation.bind(this);
	    this.onSelectAnimation = this.onSelectAnimation.bind(this);
	    this.handleSelectCameraAnimation = this.handleSelectCameraAnimation.bind(this);
	    this.onSelectCameraAnimation = this.onSelectCameraAnimation.bind(this);
	    this.handleSelectAudio = this.handleSelectAudio.bind(this);
	    this.onSelectAudio = this.onSelectAudio.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      animation,
	      cameraAnimation,
	      audio
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('MMD Model'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(DisplayProperty, {
	      label: _t('Model Animation'),
	      name: 'animation',
	      value: animation,
	      btnShow: true,
	      btnText: _t('Select'),
	      onClick: this.handleSelectAnimation
	    }), React.createElement(DisplayProperty, {
	      label: _t('Camera Animation'),
	      name: 'cameraAnimation',
	      value: cameraAnimation,
	      btnShow: true,
	      btnText: _t('Select'),
	      onClick: this.handleSelectCameraAnimation
	    }), React.createElement(DisplayProperty, {
	      label: _t('Audio'),
	      name: 'audio',
	      value: audio,
	      btnShow: true,
	      btnText: _t('Select'),
	      onClick: this.handleSelectAudio
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.MMDComponent`, this.handleUpdate);
	    app.on(`objectChanged.MMDComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected.userData.Type === 'pmd' || editor.selected.userData.Type === 'pmx')) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let state = {
	      show: true,
	      animation: this.selected.userData.Animation ? this.selected.userData.Animation.Name : null,
	      cameraAnimation: this.selected.userData.CameraAnimation ? this.selected.userData.CameraAnimation.Name : null,
	      audio: this.selected.userData.Audio ? this.selected.userData.Audio.Name : null
	    };
	    this.setState(state);
	  } // ----------------------------- 模型动画 ------------------------------------------


	  handleSelectAnimation() {
	    app.call(`selectBottomPanel`, this, 'animation');
	    app.toast(_t('Please click the animation in the animation panel.'));
	    app.on(`selectAnimation.MMDComponent`, this.onSelectAnimation);
	  }

	  onSelectAnimation(data) {
	    if (data.Type !== 'mmd') {
	      app.toast(_t('Please select MMD animation only.'));
	      return;
	    }

	    app.on(`selectAnimation.MMDComponent`, null);
	    this.selected.userData.Animation = {};
	    Object.assign(this.selected.userData.Animation, data);
	    app.call(`objectChanged`, this, this.selected);
	  } // ---------------------------- 相机动画 -------------------------------------------


	  handleSelectCameraAnimation() {
	    app.call(`selectBottomPanel`, this, 'animation');
	    app.toast(_t('Please select camera animation.'));
	    app.on(`selectAnimation.MMDComponent`, this.onSelectCameraAnimation);
	  }

	  onSelectCameraAnimation(data) {
	    if (data.Type !== 'mmd') {
	      app.toast(_t('Please select camera animation only.'));
	      return;
	    }

	    app.on(`selectAnimation.MMDComponent`, null);
	    this.selected.userData.CameraAnimation = {};
	    Object.assign(this.selected.userData.CameraAnimation, data);
	    app.call(`objectChanged`, this, this.selected);
	  } // ------------------------------ MMD音乐 --------------------------------------------


	  handleSelectAudio() {
	    app.call(`selectBottomPanel`, this, 'audio');
	    app.toast(_t('Please select MMD audio.'));
	    app.on(`selectAudio.MMDComponent`, this.onSelectAudio.bind(this));
	  }

	  onSelectAudio(data) {
	    app.on(`selectAudio.MMDComponent`, null);
	    this.selected.userData.Audio = {};
	    Object.assign(this.selected.userData.Audio, data);
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 粒子发射器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class ParticleEmitterComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.isPlaying = false;
	    this.state = {
	      show: false,
	      expanded: true,
	      positionX: 0,
	      positionY: 0,
	      positionZ: 0,
	      positionSpreadX: 0,
	      positionSpreadY: 0,
	      positionSpreadZ: 0,
	      velocityX: 0,
	      velocityY: 0,
	      velocityZ: 0,
	      velocitySpreadX: 0,
	      velocitySpreadY: 0,
	      velocitySpreadZ: 0,
	      accelerationX: 0,
	      accelerationY: 0,
	      accelerationZ: 0,
	      accelerationSpreadX: 0,
	      accelerationSpreadY: 0,
	      accelerationSpreadZ: 0,
	      color1: null,
	      color2: null,
	      color3: null,
	      color4: null,
	      size: 1,
	      sizeSpread: 0,
	      texture: null,
	      particleCount: 1000,
	      maxAge: 5,
	      maxAgeSpread: 2,
	      previewText: _t('Preview')
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChangePosition = this.handleChangePosition.bind(this);
	    this.handleChangeVelocity = this.handleChangeVelocity.bind(this);
	    this.handleChangeAcceleration = this.handleChangeAcceleration.bind(this);
	    this.handleChangeColor = this.handleChangeColor.bind(this);
	    this.handleChangeSize = this.handleChangeSize.bind(this);
	    this.handleChangeTexture = this.handleChangeTexture.bind(this);
	    this.handleChangeParticleCount = this.handleChangeParticleCount.bind(this);
	    this.handleChangeMaxAge = this.handleChangeMaxAge.bind(this);
	    this.handleChangeMaxAgeSpread = this.handleChangeMaxAgeSpread.bind(this);
	    this.handlePreview = this.handlePreview.bind(this);
	    this.startPreview = this.startPreview.bind(this);
	    this.stopPreview = this.stopPreview.bind(this);
	    this.onAnimate = this.onAnimate.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      positionX,
	      positionY,
	      positionZ,
	      positionSpreadX,
	      positionSpreadY,
	      positionSpreadZ,
	      velocityX,
	      velocityY,
	      velocityZ,
	      velocitySpreadX,
	      velocitySpreadY,
	      velocitySpreadZ,
	      accelerationX,
	      accelerationY,
	      accelerationZ,
	      accelerationSpreadX,
	      accelerationSpreadY,
	      accelerationSpreadZ,
	      color1,
	      color2,
	      color3,
	      color4,
	      size,
	      sizeSpread,
	      texture,
	      particleCount,
	      maxAge,
	      maxAgeSpread,
	      previewText
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('ParticleEmitter'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: `${_t('Position')}X`,
	      name: 'positionX',
	      value: positionX,
	      onChange: this.handleChangePosition
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Position')}Y`,
	      name: 'positionY',
	      value: positionY,
	      onChange: this.handleChangePosition
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Position')}Z`,
	      name: 'positionZ',
	      value: positionZ,
	      onChange: this.handleChangePosition
	    }), React.createElement(NumberProperty, {
	      label: `${_t('PositionSpread')}X`,
	      name: 'positionSpreadX',
	      value: positionSpreadX,
	      onChange: this.handleChangePosition
	    }), React.createElement(NumberProperty, {
	      label: `${_t('PositionSpread')}Y`,
	      name: 'positionSpreadY',
	      value: positionSpreadY,
	      onChange: this.handleChangePosition
	    }), React.createElement(NumberProperty, {
	      label: `${_t('PositionSpread')}Z`,
	      name: 'positionSpreadZ',
	      value: positionSpreadZ,
	      onChange: this.handleChangePosition
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Velocity')}X`,
	      name: 'velocityX',
	      value: velocityX,
	      onChange: this.handleChangeVelocity
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Velocity')}Y`,
	      name: 'velocityY',
	      value: velocityY,
	      onChange: this.handleChangeVelocity
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Velocity')}Z`,
	      name: 'velocityZ',
	      value: velocityZ,
	      onChange: this.handleChangeVelocity
	    }), React.createElement(NumberProperty, {
	      label: `${_t('VelocitySpread')}X`,
	      name: 'velocitySpreadX',
	      value: velocitySpreadX,
	      onChange: this.handleChangeVelocity
	    }), React.createElement(NumberProperty, {
	      label: `${_t('VelocitySpread')}Y`,
	      name: 'velocitySpreadY',
	      value: velocitySpreadY,
	      onChange: this.handleChangeVelocity
	    }), React.createElement(NumberProperty, {
	      label: `${_t('VelocitySpread')}Z`,
	      name: 'velocitySpreadZ',
	      value: velocitySpreadZ,
	      onChange: this.handleChangeVelocity
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Acceleration')}X`,
	      name: 'accelerationX',
	      value: accelerationX,
	      onChange: this.handleChangeAcceleration
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Acceleration')}Y`,
	      name: 'accelerationY',
	      value: accelerationY,
	      onChange: this.handleChangeAcceleration
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Acceleration')}Z`,
	      name: 'accelerationZ',
	      value: accelerationZ,
	      onChange: this.handleChangeAcceleration
	    }), React.createElement(NumberProperty, {
	      label: `${_t('AccelerationSpread')}X`,
	      name: 'accelerationSpreadX',
	      value: accelerationSpreadX,
	      onChange: this.handleChangeAcceleration
	    }), React.createElement(NumberProperty, {
	      label: `${_t('AccelerationSpread')}Y`,
	      name: 'accelerationSpreadY',
	      value: accelerationSpreadY,
	      onChange: this.handleChangeAcceleration
	    }), React.createElement(NumberProperty, {
	      label: `${_t('AccelerationSpread')}Z`,
	      name: 'accelerationSpreadZ',
	      value: accelerationSpreadZ,
	      onChange: this.handleChangeAcceleration
	    }), React.createElement(ColorProperty, {
	      label: `${_t('Color')}1`,
	      name: 'color1',
	      value: color1,
	      onChange: this.handleChangeColor
	    }), React.createElement(ColorProperty, {
	      label: `${_t('Color')}2`,
	      name: 'color2',
	      value: color2,
	      onChange: this.handleChangeColor
	    }), React.createElement(ColorProperty, {
	      label: `${_t('Color')}3`,
	      name: 'color3',
	      value: color3,
	      onChange: this.handleChangeColor
	    }), React.createElement(ColorProperty, {
	      label: `${_t('Color')}4`,
	      name: 'color4',
	      value: color4,
	      onChange: this.handleChangeColor
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Size')}`,
	      name: 'size',
	      value: size,
	      onChange: this.handleChangeSize
	    }), React.createElement(NumberProperty, {
	      label: `${_t('SizeSpread')}`,
	      name: 'sizeSpread',
	      value: sizeSpread,
	      onChange: this.handleChangeSize
	    }), React.createElement(TextureProperty, {
	      label: `${_t('Texture')}`,
	      name: 'texture',
	      value: texture,
	      onChange: this.handleChangeTexture
	    }), React.createElement(IntegerProperty, {
	      label: `${_t('ParticleCount')}`,
	      name: 'particleCount',
	      value: particleCount,
	      onChange: this.handleChangeParticleCount
	    }), React.createElement(NumberProperty, {
	      label: `${_t('MaxAge')}`,
	      name: 'maxAge',
	      value: maxAge,
	      onChange: this.handleChangeMaxAge
	    }), React.createElement(NumberProperty, {
	      label: `${_t('maxAgeSpread')}`,
	      name: 'maxAgeSpread',
	      value: maxAgeSpread,
	      onChange: this.maxAgeSpread
	    }), React.createElement(ButtonProperty, {
	      text: previewText,
	      onChange: this.handlePreview
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.ParticleEmitterComponent`, this.handleUpdate);
	    app.on(`objectChanged.ParticleEmitterComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected.userData.type === 'ParticleEmitter')) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    let state = {
	      show: true,
	      positionX: emitter.position.value.x,
	      positionY: emitter.position.value.y,
	      positionZ: emitter.position.value.z,
	      positionSpreadX: emitter.position.spread.x,
	      positionSpreadY: emitter.position.spread.y,
	      positionSpreadZ: emitter.position.spread.z,
	      velocityX: emitter.velocity.value.x,
	      velocityY: emitter.velocity.value.y,
	      velocityZ: emitter.velocity.value.z,
	      velocitySpreadX: emitter.velocity.spread.x,
	      velocitySpreadY: emitter.velocity.spread.y,
	      velocitySpreadZ: emitter.velocity.spread.z,
	      accelerationX: emitter.acceleration.value.x,
	      accelerationY: emitter.acceleration.value.y,
	      accelerationZ: emitter.acceleration.value.z,
	      accelerationSpreadX: emitter.acceleration.spread.x,
	      accelerationSpreadY: emitter.acceleration.spread.y,
	      accelerationSpreadZ: emitter.acceleration.spread.z,
	      color1: `#${emitter.color.value[0].getHexString()}`,
	      color2: `#${emitter.color.value[1].getHexString()}`,
	      color3: `#${emitter.color.value[2].getHexString()}`,
	      color4: `#${emitter.color.value[3].getHexString()}`,
	      size: emitter.size.value[0],
	      sizeSpread: emitter.size.spread[0],
	      texture: group.texture,
	      particleCount: emitter.particleCount,
	      maxAge: emitter.maxAge.value,
	      maxAgeSpread: emitter.maxAge.spread,
	      previewText: this.isPlaying ? _t('Cancel') : _t('Preview')
	    };
	    this.setState(state);
	  }

	  handleChangePosition(value, name) {
	    this.setState({
	      [name]: value
	    });

	    if (value === null) {
	      return;
	    }

	    const {
	      positionX,
	      positionY,
	      positionZ,
	      positionSpreadX,
	      positionSpreadY,
	      positionSpreadZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    emitter.position.value.x = positionX;
	    emitter.position.value.y = positionY;
	    emitter.position.value.z = positionZ;
	    emitter.position.spread.x = positionSpreadX;
	    emitter.position.spread.y = positionSpreadY;
	    emitter.position.spread.z = positionSpreadZ;
	    emitter.updateFlags.position = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeVelocity(value, name) {
	    this.setState({
	      [name]: value
	    });

	    if (value === null) {
	      return;
	    }

	    const {
	      velocityX,
	      velocityY,
	      velocityZ,
	      velocitySpreadX,
	      velocitySpreadY,
	      velocitySpreadZ
	    } = Object.assign({}, this.selected, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    emitter.velocity.value.x = velocityX;
	    emitter.velocity.value.y = velocityY;
	    emitter.velocity.value.z = velocityZ;
	    emitter.velocity.spread.x = velocitySpreadX;
	    emitter.velocity.spread.y = velocitySpreadY;
	    emitter.velocity.spread.z = velocitySpreadZ;
	    emitter.updateFlags.velocity = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeAcceleration(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      accelerationX,
	      accelerationY,
	      accelerationZ,
	      accelerationSpreadX,
	      accelerationSpreadY,
	      accelerationSpreadZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    emitter.acceleration.value.x = accelerationX;
	    emitter.acceleration.value.y = accelerationY;
	    emitter.acceleration.value.z = accelerationZ;
	    emitter.acceleration.spread.x = accelerationSpreadX;
	    emitter.acceleration.spread.y = accelerationSpreadY;
	    emitter.acceleration.spread.z = accelerationSpreadZ;
	    emitter.updateFlags.acceleration = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeColor(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      color1,
	      color2,
	      color3,
	      color4
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    emitter.color.value[0] = new THREE.Color(color1);
	    emitter.color.value[1] = new THREE.Color(color2);
	    emitter.color.value[2] = new THREE.Color(color3);
	    emitter.color.value[3] = new THREE.Color(color4);
	    emitter.updateFlags.color = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeSize(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      size,
	      sizeSpread
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];

	    for (var i = 0; i < emitter.size.value.length; i++) {
	      emitter.size.value[i] = size;
	      emitter.size.spread[i] = sizeSpread;
	    }

	    emitter.updateFlags.size = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeTexture(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      texture
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    texture.needsUpdate = true;
	    group.texture = texture;
	    group.material.uniforms.texture.value = texture;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeParticleCount(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      particleCount
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    emitter.particleCount = particleCount;
	    emitter.updateFlags.params = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeMaxAge(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      maxAge
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    emitter.maxAge.value = maxAge;
	    emitter.updateFlags.params = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeMaxAgeSpread(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      maxAgeSpread
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let group = this.selected.userData.group;
	    let emitter = group.emitters[0];
	    emitter.maxAge.spread = maxAgeSpread;
	    emitter.updateFlags.params = true;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handlePreview() {
	    if (this.isPlaying) {
	      this.stopPreview();
	    } else {
	      this.startPreview();
	    }
	  }

	  startPreview() {
	    this.isPlaying = true;
	    this.setState({
	      previewText: _t('Cancel')
	    });
	    app.on(`animate.ParticleEmitterComponent`, this.onAnimate);
	  }

	  stopPreview() {
	    this.isPlaying = false;
	    this.setState({
	      previewText: _t('Preview')
	    });
	    let group = this.selected.userData.group;
	    let emitter = this.selected.userData.emitter;
	    group.removeEmitter(emitter);
	    group.addEmitter(emitter);
	    group.tick(0);
	    app.on(`animate.ParticleEmitterComponent`, null);
	  }

	  onAnimate(clock, deltaTime) {
	    let group = this.selected.userData.group;
	    group.tick(deltaTime);
	  }

	}

	/**
	 * 反光组件
	 * @author tengge / https://github.com/tengge1
	 */

	class ReflectorComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.sizes = {
	      '512': '512*512',
	      '1024': '1024*1024',
	      '2048': '2048*2048'
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      reflect: false,
	      showColor: false,
	      color: '#ffffff',
	      showSize: false,
	      size: '1024',
	      showClipBias: false,
	      clipBias: 0,
	      showRecursion: false,
	      recursion: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      reflect,
	      showColor,
	      color,
	      showSize,
	      size,
	      showClipBias,
	      clipBias,
	      showRecursion,
	      recursion
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Reflector Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('Reflect'),
	      name: 'reflect',
	      value: reflect,
	      onChange: this.handleChange
	    }), React.createElement(ColorProperty, {
	      label: _t('Color'),
	      name: 'color',
	      value: color,
	      show: showColor,
	      onChange: this.handleChange
	    }), React.createElement(SelectProperty, {
	      label: _t('TextureSize'),
	      name: 'size',
	      options: this.sizes,
	      value: size,
	      show: showSize,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('ClipBias'),
	      name: 'clipBias',
	      value: clipBias,
	      show: showClipBias,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('Recursion'),
	      name: 'recursion',
	      value: recursion,
	      show: showRecursion,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.ReflectorComponent`, this.handleUpdate);
	    app.on(`objectChanged.ReflectorComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let state = {
	      show: true
	    };

	    if (this.selected instanceof THREE.Reflector) {
	      Object.assign(state, {
	        reflect: true,
	        showColor: true,
	        color: this.selected.userData.color,
	        showSize: true,
	        size: this.selected.userData.size,
	        showClipBias: true,
	        clipBias: this.selected.userData.clipBias,
	        showRecursion: true,
	        recursion: this.selected.userData.recursion
	      });
	    } else {
	      Object.assign(state, {
	        reflect: false,
	        showColor: false,
	        showSize: false,
	        showClipBias: false,
	        showRecursion: false
	      });
	    }

	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      reflect,
	      color,
	      size,
	      clipBias,
	      recursion
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let editor = app.editor;

	    if (reflect) {
	      let reflector = new THREE.Reflector(this.selected.geometry, {
	        color: color,
	        textureWidth: parseInt(size),
	        textureHeight: parseInt(size),
	        clipBias: clipBias,
	        recursion: recursion ? 1 : 0
	      });
	      reflector.name = this.selected.name;
	      reflector.position.copy(this.selected.position);
	      reflector.rotation.copy(this.selected.rotation);
	      reflector.scale.copy(this.selected.scale);
	      reflector.castShadow = this.selected.castShadow;
	      reflector.receiveShadow = this.selected.receiveShadow;

	      if (this.selected instanceof THREE.Reflector) {
	        Object.assign(reflector.userData, this.selected.userData);
	      } else {
	        Object.assign(reflector.userData, this.selected.userData, {
	          mesh: this.selected
	        });
	      }

	      reflector.userData.color = color;
	      reflector.userData.size = size;
	      reflector.userData.clipBias = clipBias;
	      reflector.userData.recursion = recursion;
	      var index = editor.scene.children.indexOf(this.selected);

	      if (index > -1) {
	        editor.scene.children[index] = reflector;
	        reflector.parent = this.selected.parent;
	        editor.select(null);
	        this.selected.parent = null;
	        app.call(`objectRemoved`, this, this.selected);
	        app.call(`objectAdded`, this, reflector);
	        editor.select(reflector);
	      }
	    } else {
	      if (this.selected instanceof THREE.Reflector) {
	        let mesh = this.selected.userData.mesh;
	        this.selected.userData.mesh = null;
	        mesh.name = this.selected.name;
	        mesh.position.copy(this.selected.position);
	        mesh.rotation.copy(this.selected.rotation);
	        mesh.scale.copy(this.selected.scale);
	        mesh.castShadow = this.selected.castShadow;
	        mesh.receiveShadow = this.selected.receiveShadow;

	        if (!Array.isArray(mesh.material) && mesh.material.color) {
	          mesh.material.color = new THREE.Color(color);
	        }

	        Object.assign(mesh.userData, this.selected.userData);
	        let index = editor.scene.children.indexOf(this.selected);

	        if (index > -1) {
	          editor.scene.children[index] = mesh;
	          mesh.parent = this.selected.parent;
	          this.selected.parent = null;
	          app.call(`objectRemoved`, this, this.selected);
	          app.call(`objectAdded`, this, mesh);
	          editor.select(mesh);
	        }
	      }
	    }
	  }

	}

	/**
	 * 场景组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SceneComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.backgroundType = {
	      'Color': _t('Solid Color'),
	      'Image': _t('Background Image'),
	      'SkyBox': _t('Cube Texture')
	    };
	    this.fogType = {
	      'None': _t('None'),
	      'Fog': _t('Linear'),
	      'FogExp2': _t('Exponential')
	    };
	    this.state = {
	      show: false,
	      expanded: true,
	      backgroundType: 'Color',
	      backgroundColor: '#aaaaaa',
	      backgroundColorShow: false,
	      backgroundImage: null,
	      backgroundImageShow: false,
	      backgroundPosX: null,
	      backgroundNegX: null,
	      backgroundPosY: null,
	      backgroundNegY: null,
	      backgroundPosZ: null,
	      backgroundNegZ: null,
	      backgroundCubeTextureShow: false,
	      fogType: 'None',
	      fogColor: '#aaaaaa',
	      fogColorShow: false,
	      fogNear: 0.1,
	      fogNearShow: false,
	      fogFar: 50,
	      fogFarShow: false,
	      fogDensity: 0.05,
	      fogDensityShow: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChangeBackgroundType = this.handleChangeBackgroundType.bind(this);
	    this.handleChangeBackgroundColor = this.handleChangeBackgroundColor.bind(this);
	    this.handleChangeBackgroundImage = this.handleChangeBackgroundImage.bind(this);
	    this.handleChangeBackgroundCubeTexture = this.handleChangeBackgroundCubeTexture.bind(this);
	    this.handleLoadCubeTexture = this.handleLoadCubeTexture.bind(this);
	    this.handleSelectCubeMap = this.handleSelectCubeMap.bind(this);
	    this.handleSaveCubeTexture = this.handleSaveCubeTexture.bind(this);
	    this.handleChangeFogType = this.handleChangeFogType.bind(this);
	    this.handleChangeFogColor = this.handleChangeFogColor.bind(this);
	    this.handleChangeFogNear = this.handleChangeFogNear.bind(this);
	    this.handleChangeFogFar = this.handleChangeFogFar.bind(this);
	    this.handleChangeFogDensity = this.handleChangeFogDensity.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      backgroundType,
	      backgroundColor,
	      backgroundColorShow,
	      backgroundImage,
	      backgroundImageShow,
	      backgroundPosX,
	      backgroundNegX,
	      backgroundPosY,
	      backgroundNegY,
	      backgroundPosZ,
	      backgroundNegZ,
	      backgroundCubeTextureShow,
	      backgroundCubeTextureCommandShow,
	      fogType,
	      fogColor,
	      fogColorShow,
	      fogNear,
	      fogNearShow,
	      fogFar,
	      fogFarShow,
	      fogDensity,
	      fogDensityShow
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('SceneComponent'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(SelectProperty, {
	      label: _t('Background'),
	      name: 'backgroundType',
	      options: this.backgroundType,
	      value: backgroundType,
	      onChange: this.handleChangeBackgroundType
	    }), React.createElement(ColorProperty, {
	      label: _t('BackgroundColor'),
	      name: 'backgroundColor',
	      value: backgroundColor,
	      show: backgroundColorShow,
	      onChange: this.handleChangeBackgroundColor
	    }), React.createElement(TextureProperty, {
	      label: _t('Background Image'),
	      name: 'backgroundImage',
	      value: backgroundImage,
	      show: backgroundImageShow,
	      onChange: this.handleChangeBackgroundImage
	    }), React.createElement(TextureProperty, {
	      label: _t('PosX'),
	      name: 'backgroundPosX',
	      value: backgroundPosX,
	      show: backgroundCubeTextureShow,
	      onChange: this.handleChangeBackgroundCubeTexture
	    }), React.createElement(TextureProperty, {
	      label: _t('NegX'),
	      name: 'backgroundNegX',
	      value: backgroundNegX,
	      show: backgroundCubeTextureShow,
	      onChange: this.handleChangeBackgroundCubeTexture
	    }), React.createElement(TextureProperty, {
	      label: _t('PosY'),
	      name: 'backgroundPosY',
	      value: backgroundPosY,
	      show: backgroundCubeTextureShow,
	      onChange: this.handleChangeBackgroundCubeTexture
	    }), React.createElement(TextureProperty, {
	      label: _t('NegY'),
	      name: 'backgroundNegY',
	      value: backgroundNegY,
	      show: backgroundCubeTextureShow,
	      onChange: this.handleChangeBackgroundCubeTexture
	    }), React.createElement(TextureProperty, {
	      label: _t('PosZ'),
	      name: 'backgroundPosZ',
	      value: backgroundPosZ,
	      show: backgroundCubeTextureShow,
	      onChange: this.handleChangeBackgroundCubeTexture
	    }), React.createElement(TextureProperty, {
	      label: _t('NegZ'),
	      name: 'backgroundNegZ',
	      value: backgroundNegZ,
	      show: backgroundCubeTextureShow,
	      onChange: this.handleChangeBackgroundCubeTexture
	    }), React.createElement(ButtonsProperty, {
	      show: backgroundCubeTextureShow
	    }, React.createElement(Button, {
	      onClick: this.handleLoadCubeTexture
	    }, _t('Select')), React.createElement(Button, {
	      onClick: this.handleSaveCubeTexture
	    }, _t('Upload'))), React.createElement(SelectProperty, {
	      label: _t('Fog'),
	      name: 'fogType',
	      options: this.fogType,
	      value: fogType,
	      onChange: this.handleChangeFogType
	    }), React.createElement(ColorProperty, {
	      label: _t('FogColor'),
	      name: 'fogColor',
	      value: fogColor,
	      show: fogColorShow,
	      onChange: this.handleChangeFogColor
	    }), React.createElement(NumberProperty, {
	      label: _t('FogNear'),
	      name: 'fogNear',
	      value: fogNear,
	      show: fogNearShow,
	      onChange: this.handleChangeFogNear
	    }), React.createElement(NumberProperty, {
	      label: _t('FogFar'),
	      name: 'fogFar',
	      value: fogFar,
	      show: fogFarShow,
	      onChange: this.handleChangeFogFar
	    }), React.createElement(NumberProperty, {
	      label: _t('FogDensity'),
	      name: 'fogDensity',
	      value: fogDensity,
	      show: fogDensityShow,
	      onChange: this.handleChangeFogDensity
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SceneComponent`, this.handleUpdate);
	    app.on(`objectChanged.SceneComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== app.editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const background = this.selected.background;
	    const fog = this.selected.fog;
	    const {
	      backgroundColor,
	      fogColor,
	      fogNear,
	      fogFar,
	      fogDensity
	    } = this.state;
	    let state = {
	      show: true,
	      // 背景
	      backgroundType: background instanceof THREE.CubeTexture ? 'SkyBox' : background instanceof THREE.Texture ? 'Image' : 'Color',
	      backgroundColor: background instanceof THREE.Color ? `#${background.getHexString()}` : backgroundColor,
	      backgroundColorShow: background instanceof THREE.Color,
	      backgroundImage: background instanceof THREE.Texture && !(background instanceof THREE.CubeTexture) ? background : null,
	      backgroundImageShow: background instanceof THREE.Texture && !(background instanceof THREE.CubeTexture),
	      backgroundPosX: background instanceof THREE.CubeTexture ? new THREE.Texture(background.image[0]) : null,
	      backgroundNegX: background instanceof THREE.CubeTexture ? new THREE.Texture(background.image[1]) : null,
	      backgroundPosY: background instanceof THREE.CubeTexture ? new THREE.Texture(background.image[2]) : null,
	      backgroundNegY: background instanceof THREE.CubeTexture ? new THREE.Texture(background.image[3]) : null,
	      backgroundPosZ: background instanceof THREE.CubeTexture ? new THREE.Texture(background.image[4]) : null,
	      backgroundNegZ: background instanceof THREE.CubeTexture ? new THREE.Texture(background.image[5]) : null,
	      backgroundCubeTextureShow: background instanceof THREE.CubeTexture,
	      // 雾效
	      fogType: fog == null ? 'None' : fog instanceof THREE.FogExp2 ? 'FogExp2' : 'Fog',
	      fogColor: fog == null ? fogColor : `#${fog.color.getHexString()}`,
	      fogColorShow: fog !== null,
	      fogNear: fog instanceof THREE.Fog ? fog.near : fogNear,
	      fogNearShow: fog !== null && fog instanceof THREE.Fog,
	      fogFar: fog instanceof THREE.Fog ? fog.far : fogFar,
	      fogFarShow: fog instanceof THREE.Fog,
	      fogDensity: fog instanceof THREE.FogExp2 ? fog.density : fogDensity,
	      fogDensityShow: fog instanceof THREE.FogExp2
	    };
	    this.setState(state);
	  }

	  handleChangeBackgroundType(value, name) {
	    const {
	      backgroundType,
	      backgroundColor,
	      backgroundImage,
	      backgroundPosX,
	      backgroundNegX,
	      backgroundPosY,
	      backgroundNegY,
	      backgroundPosZ,
	      backgroundNegZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;

	    switch (backgroundType) {
	      case 'Color':
	        scene.background = new THREE.Color(backgroundColor);
	        break;

	      case 'Image':
	        if (backgroundImage) {
	          scene.background = backgroundImage;
	        } else {
	          scene.background = new THREE.Color(backgroundColor);
	          this.setState({
	            [name]: value,
	            backgroundColorShow: false,
	            backgroundImageShow: true,
	            backgroundCubeTextureShow: false
	          });
	          return;
	        }

	        break;

	      case 'SkyBox':
	        if (backgroundPosX && backgroundNegX && backgroundPosY && backgroundNegY && backgroundPosZ && backgroundNegZ) {
	          scene.background = new THREE.CubeTexture([backgroundPosX.image, backgroundNegX.image, backgroundPosY.image, backgroundNegY.image, backgroundPosZ.image, backgroundNegZ.image]);
	          scene.background.needsUpdate = true;
	        } else {
	          scene.background = new THREE.Color(backgroundColor);
	          this.setState({
	            [name]: value,
	            backgroundColorShow: false,
	            backgroundImageShow: false,
	            backgroundCubeTextureShow: true
	          });
	          return;
	        }

	        break;
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeBackgroundColor(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.background = new THREE.Color(value);
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeBackgroundImage(value, name) {
	    if (value === null) {
	      this.selected.background = new THREE.Color(this.state.backgroundColor);
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.background = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeBackgroundCubeTexture(value, name) {
	    if (value === null) {
	      this.selected.background = new THREE.Color(this.state.backgroundColor);
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      backgroundPosX,
	      backgroundNegX,
	      backgroundPosY,
	      backgroundNegY,
	      backgroundPosZ,
	      backgroundNegZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });

	    if (backgroundPosX && backgroundNegX && backgroundPosY && backgroundNegY && backgroundPosZ && backgroundNegZ) {
	      let scene = this.selected;
	      scene.background = new THREE.CubeTexture([backgroundPosX.image, backgroundNegX.image, backgroundPosY.image, backgroundNegY.image, backgroundPosZ.image, backgroundNegZ.image]);
	      scene.background.needsUpdate = true;
	      app.call(`objectChanged`, this, this.selected);
	    } else {
	      this.setState({
	        [name]: value
	      });
	    }
	  }

	  handleLoadCubeTexture() {
	    app.call(`selectBottomPanel`, this, 'map');
	    app.toast(_t('Please click the map in the Map Panel.'));
	    app.on(`selectMap.SceneComponent`, this.handleSelectCubeMap);
	  }

	  handleSelectCubeMap(model) {
	    if (model.Type !== 'cube') {
	      app.toast(_t('You should select Cube Texture.'));
	      return;
	    }

	    app.on(`selectMap.SceneComponent`, null);
	    var urls = model.Url.split(';');
	    var loader = new THREE.TextureLoader();
	    var promises = urls.map(url => {
	      return new Promise(resolve => {
	        loader.load(`${app.options.server}${url}`, texture => {
	          resolve(texture);
	        }, undefined, error => {
	          console.error(error);
	          app.toast(_t('Cube Texture fetch failed.'));
	        });
	      });
	    });
	    let scene = this.selected;
	    Promise.all(promises).then(textures => {
	      scene.background = new THREE.CubeTexture([textures[0].image, textures[1].image, textures[2].image, textures[3].image, textures[4].image, textures[5].image]);
	      scene.background.needsUpdate = true;
	      app.call(`objectChanged`, this, this.selected);
	    });
	  }

	  handleSaveCubeTexture() {
	    const {
	      backgroundPosX,
	      backgroundNegX,
	      backgroundPosY,
	      backgroundNegY,
	      backgroundPosZ,
	      backgroundNegZ
	    } = this.state;

	    if (!backgroundPosX || !backgroundNegX || !backgroundPosY || !backgroundNegY || !backgroundPosZ || !backgroundNegZ) {
	      app.toast(_t('Please upload all the textures before save.'));
	      return;
	    }

	    const posXSrc = backgroundPosX.image.src;
	    const negXSrc = backgroundNegX.image.src;
	    const posYSrc = backgroundPosY.image.src;
	    const negYSrc = backgroundNegY.image.src;
	    const posZSrc = backgroundPosZ.image.src;
	    const negZSrc = backgroundNegZ.image.src;

	    if (posXSrc.startsWith('http') || negXSrc.startsWith('http') || posYSrc.startsWith('http') || negYSrc.startsWith('http') || posZSrc.startsWith('http') || negZSrc.startsWith('http')) {
	      app.toast(_t('Cube texture has already been uploaded.'));
	      return;
	    }

	    const promises = [Converter$1.dataURLtoFile(posXSrc, 'posX'), Converter$1.dataURLtoFile(negXSrc, 'negX'), Converter$1.dataURLtoFile(posYSrc, 'posY'), Converter$1.dataURLtoFile(negYSrc, 'negY'), Converter$1.dataURLtoFile(posZSrc, 'posZ'), Converter$1.dataURLtoFile(negZSrc, 'negZ')];
	    Promise.all(promises).then(files => {
	      Ajax.post(`${app.options.server}/api/Map/Add`, {
	        posX: files[0],
	        negX: files[1],
	        posY: files[2],
	        negY: files[3],
	        posZ: files[4],
	        negZ: files[5]
	      }, result => {
	        let obj = JSON.parse(result);
	        app.toast(_t(obj.Msg));
	      });
	    });
	  }

	  handleChangeFogType(value, name) {
	    const {
	      fogType,
	      fogColor,
	      fogNear,
	      fogFar,
	      fogDensity
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;

	    switch (fogType) {
	      case 'None':
	        scene.fog = null;
	        break;

	      case 'Fog':
	        scene.fog = new THREE.Fog(fogColor, fogNear, fogFar);
	        break;

	      case 'FogExp2':
	        scene.fog = new THREE.FogExp2(fogColor, fogDensity);
	        break;
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeFogColor(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.fog.color.set(value);
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeFogNear(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.fog.near = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeFogFar(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.fog.far = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeFogDensity(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.fog.density = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 阴影组件
	 * @author tengge / https://github.com/tengge1
	 */

	class ShadowComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.mapSize = {
	      '512': '512*512',
	      '1024': '1024*1024',
	      '2048': '2048*2048',
	      '4096': '4096*4096'
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      castShadow: false,
	      castShadowShow: false,
	      receiveShadow: false,
	      receiveShadowShow: false,
	      shadowRadius: 1,
	      shadowRadiusShow: false,
	      mapSize: 512,
	      mapSizeShow: false,
	      bias: 0,
	      biasShow: false,
	      cameraLeft: -5,
	      cameraRight: 5,
	      cameraTop: 5,
	      cameraBottom: -5,
	      cameraNear: 0.5,
	      cameraFar: 1000,
	      cameraShow: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChangeCastShadow = this.handleChangeCastShadow.bind(this);
	    this.handleChangeReceiveShadow = this.handleChangeReceiveShadow.bind(this);
	    this.handleChangeShadowRadius = this.handleChangeShadowRadius.bind(this);
	    this.handleChangeMapSize = this.handleChangeMapSize.bind(this);
	    this.handleChangeBias = this.handleChangeBias.bind(this);
	    this.handleChangeCameraLeft = this.handleChangeCameraLeft.bind(this);
	    this.handleChangeCameraRight = this.handleChangeCameraRight.bind(this);
	    this.handleChangeCameraTop = this.handleChangeCameraTop.bind(this);
	    this.handleChangeCameraBottom = this.handleChangeCameraBottom.bind(this);
	    this.handleChangeCameraNear = this.handleChangeCameraNear.bind(this);
	    this.handleChangeCameraFar = this.handleChangeCameraFar.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      castShadow,
	      castShadowShow,
	      receiveShadow,
	      receiveShadowShow,
	      shadowRadius,
	      shadowRadiusShow,
	      mapSize,
	      mapSizeShow,
	      bias,
	      biasShow,
	      cameraLeft,
	      cameraRight,
	      cameraTop,
	      cameraBottom,
	      cameraNear,
	      cameraFar,
	      cameraShow
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Shadow Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('Cast'),
	      name: 'castShadow',
	      value: castShadow,
	      show: castShadowShow,
	      onChange: this.handleChangeCastShadow
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('Receive'),
	      name: 'receiveShadow',
	      value: receiveShadow,
	      show: receiveShadowShow,
	      onChange: this.handleChangeReceiveShadow
	    }), React.createElement(NumberProperty, {
	      label: _t('Radius'),
	      name: 'shadowRadius',
	      value: shadowRadius,
	      show: shadowRadiusShow,
	      onChange: this.handleChangeShadowRadius
	    }), React.createElement(SelectProperty, {
	      label: _t('MapSize'),
	      options: this.mapSize,
	      name: 'mapSize',
	      value: mapSize.toString(),
	      show: mapSizeShow,
	      onChange: this.handleChangeMapSize
	    }), React.createElement(NumberProperty, {
	      label: _t('Bias'),
	      name: 'bias',
	      value: bias,
	      show: biasShow,
	      onChange: this.handleChangeBias
	    }), React.createElement(NumberProperty, {
	      label: _t('CameraLeft'),
	      name: 'cameraLeft',
	      value: cameraLeft,
	      show: cameraShow,
	      onChange: this.handleChangeCameraLeft
	    }), React.createElement(NumberProperty, {
	      label: _t('CameraRight'),
	      name: 'cameraRight',
	      value: cameraRight,
	      show: cameraShow,
	      onChange: this.handleChangeCameraRight
	    }), React.createElement(NumberProperty, {
	      label: _t('CameraTop'),
	      name: 'cameraTop',
	      value: cameraTop,
	      show: cameraShow,
	      onChange: this.handleChangeCameraTop
	    }), React.createElement(NumberProperty, {
	      label: _t('CameraBottom'),
	      name: 'cameraBottom',
	      value: cameraBottom,
	      show: cameraShow,
	      onChange: this.handleChangeCameraBottom
	    }), React.createElement(NumberProperty, {
	      label: _t('CameraNear'),
	      name: 'cameraNear',
	      value: cameraNear,
	      show: cameraShow,
	      onChange: this.handleChangeCameraNear
	    }), React.createElement(NumberProperty, {
	      label: _t('CameraFar'),
	      name: 'cameraFar',
	      value: cameraFar,
	      show: cameraShow,
	      onChange: this.handleChangeCameraFar
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.ShadowComponent`, this.handleUpdate);
	    app.on(`objectChanged.ShadowComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh || editor.selected instanceof THREE.DirectionalLight || editor.selected instanceof THREE.PointLight || editor.selected instanceof THREE.SpotLight)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let state = {
	      show: true,
	      castShadow: this.selected.castShadow,
	      castShadowShow: true
	    };

	    if (this.selected instanceof THREE.Light) {
	      Object.assign(state, {
	        receiveShadowShow: false,
	        shadowRadius: this.selected.shadow.radius,
	        shadowRadiusShow: true,
	        mapSize: this.selected.shadow.mapSize.x,
	        mapSizeShow: true,
	        bias: this.selected.shadow.bias,
	        biasShow: true,
	        cameraLeft: this.selected.shadow.camera.left,
	        cameraRight: this.selected.shadow.camera.right,
	        cameraTop: this.selected.shadow.camera.top,
	        cameraBottom: this.selected.shadow.camera.bottom,
	        cameraNear: this.selected.shadow.camera.near,
	        cameraFar: this.selected.shadow.camera.far,
	        cameraShow: true
	      });
	    } else {
	      Object.assign(state, {
	        receiveShadow: this.selected.receiveShadow,
	        receiveShadowShow: true,
	        shadowRadiusShow: false,
	        mapSizeShow: false,
	        biasShow: false,
	        cameraShow: false
	      });
	    }

	    this.setState(state);
	  }

	  handleChangeCastShadow(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.castShadow = value;

	    if (this.selected instanceof THREE.Mesh) {
	      this.updateMaterial(this.selected.material);
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeReceiveShadow(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.receiveShadow = value;

	    if (this.selected instanceof THREE.Mesh) {
	      this.updateMaterial(this.selected.material);
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeShadowRadius(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.radius = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  updateMaterial(material) {
	    if (Array.isArray(material)) {
	      material.forEach(n => {
	        n.needsUpdate = true;
	      });
	    } else {
	      material.needsUpdate = true;
	    }
	  }

	  handleChangeMapSize(value, name) {
	    this.selected.shadow.mapSize.x = this.selected.shadow.mapSize.y = parseInt(value);
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeBias(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.bias = value;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeCameraLeft(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.camera.left = value;
	    this.selected.shadow.camera.updateProjectionMatrix();
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeCameraRight(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.camera.right = value;
	    this.selected.shadow.camera.updateProjectionMatrix();
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeCameraTop(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.camera.top = value;
	    this.selected.shadow.camera.updateProjectionMatrix();
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeCameraBottom(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.camera.bottom = value;
	    this.selected.shadow.camera.updateProjectionMatrix();
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeCameraNear(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.camera.near = value;
	    this.selected.shadow.camera.updateProjectionMatrix();
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeCameraFar(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    this.selected.shadow.camera.far = value;
	    this.selected.shadow.camera.updateProjectionMatrix();
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 烟组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SmokeComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.isPlaying = false;
	    this.state = {
	      show: false,
	      expanded: true,
	      size: 2,
	      lifetime: 10,
	      previewText: _t('Preview')
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	    this.handlePreview = this.handlePreview.bind(this);
	    this.onAnimate = this.onAnimate.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      size,
	      lifetime,
	      previewText
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('SmokeComponent'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: _t('Size'),
	      name: 'size',
	      value: size,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('TimeSpan'),
	      name: 'lifetime',
	      value: lifetime,
	      onChange: this.handleChange
	    }), React.createElement(ButtonProperty, {
	      text: previewText,
	      onChange: this.handlePreview
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SmokeComponent`, this.handleUpdate);
	    app.on(`objectChanged.SmokeComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected.userData.type === 'Smoke')) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      size: this.selected.userData.size,
	      lifetime: this.selected.userData.lifetime,
	      previewText: this.isPlaying ? _t('Cancel') : _t('Preview')
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      size,
	      lifetime
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.userData.size = size;
	    this.selected.userData.lifetime = lifetime;
	    this.selected.material.uniforms.size.value = size;
	    this.selected.material.uniforms.lifetime.value = lifetime;
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handlePreview() {
	    if (this.isPlaying) {
	      this.stopPreview();
	    } else {
	      this.startPreview();
	    }
	  }

	  startPreview() {
	    this.isPlaying = true;
	    this.setState({
	      previewText: _t('Cancel')
	    });
	    app.on(`animate.SmokeComponent`, this.onAnimate);
	  }

	  stopPreview() {
	    this.isPlaying = false;
	    this.setState({
	      previewText: _t('Preview')
	    });
	    app.on(`animate.SmokeComponent`, null);
	  }

	  onAnimate(clock, deltaTime) {
	    const elapsed = clock.getElapsedTime();
	    this.selected.update(elapsed);
	  }

	}

	/**
	 * 位移组件
	 * @author tengge / https://github.com/tengge1
	 */

	class TransformComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      positionX: 0.0,
	      positionY: 0.0,
	      positionZ: 0.0,
	      rotationX: 0.0,
	      rotationY: 0.0,
	      rotationZ: 0.0,
	      scaleX: 1.0,
	      scaleY: 1.0,
	      scaleZ: 1.0,
	      scaleLocked: true
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChangePosition = this.handleChangePosition.bind(this);
	    this.handleChangeRotation = this.handleChangeRotation.bind(this);
	    this.handleChangeScale = this.handleChangeScale.bind(this);
	    this.handleChangeScaleLock = this.handleChangeScaleLock.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      positionX,
	      positionY,
	      positionZ,
	      rotationX,
	      rotationY,
	      rotationZ,
	      scaleX,
	      scaleY,
	      scaleZ,
	      scaleLocked
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Transform Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      name: 'positionX',
	      label: `${_t('Translate')}X`,
	      value: positionX,
	      onChange: this.handleChangePosition
	    }), React.createElement(NumberProperty, {
	      name: 'positionY',
	      label: `${_t('Translate')}Y`,
	      value: positionY,
	      onChange: this.handleChangePosition
	    }), React.createElement(NumberProperty, {
	      name: 'positionZ',
	      label: `${_t('Translate')}Z`,
	      value: positionZ,
	      onChange: this.handleChangePosition
	    }), React.createElement(NumberProperty, {
	      name: 'rotationX',
	      label: `${_t('Rotate')}X`,
	      value: rotationX,
	      onChange: this.handleChangeRotation
	    }), React.createElement(NumberProperty, {
	      name: 'rotationY',
	      label: `${_t('Rotate')}Y`,
	      value: rotationY,
	      onChange: this.handleChangeRotation
	    }), React.createElement(NumberProperty, {
	      name: 'rotationZ',
	      label: `${_t('Rotate')}Z`,
	      value: rotationZ,
	      onChange: this.handleChangeRotation
	    }), React.createElement(NumberProperty, {
	      name: 'scaleX',
	      label: `${_t('Scale')}X`,
	      value: scaleX,
	      onChange: this.handleChangeScale
	    }), React.createElement(NumberProperty, {
	      name: 'scaleY',
	      label: `${_t('Scale')}Y`,
	      value: scaleY,
	      onChange: this.handleChangeScale
	    }), React.createElement(NumberProperty, {
	      name: 'scaleZ',
	      label: `${_t('Scale')}Z`,
	      value: scaleZ,
	      onChange: this.handleChangeScale
	    }), React.createElement(CheckBoxProperty, {
	      name: 'scaleLocked',
	      label: _t('Scale Locked'),
	      value: scaleLocked,
	      onChange: this.handleChangeScaleLock
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.TransformComponent`, this.handleUpdate);
	    app.on(`objectChanged.TransformComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected === app.editor.scene || editor.selected.isGlobe) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      positionX: this.selected.position.x,
	      positionY: this.selected.position.y,
	      positionZ: this.selected.position.z,
	      rotationX: this.selected.rotation.x * 180 / Math.PI,
	      rotationY: this.selected.rotation.y * 180 / Math.PI,
	      rotationZ: this.selected.rotation.z * 180 / Math.PI,
	      scaleX: this.selected.scale.x,
	      scaleY: this.selected.scale.y,
	      scaleZ: this.selected.scale.z
	    });
	  }

	  handleChangePosition(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      positionX,
	      positionY,
	      positionZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    app.editor.execute(new SetPositionCommand(this.selected, new THREE.Vector3(positionX, positionY, positionZ)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeRotation(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      rotationX,
	      rotationY,
	      rotationZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    app.editor.execute(new SetRotationCommand(this.selected, new THREE.Euler(rotationX * Math.PI / 180, rotationY * Math.PI / 180, rotationZ * Math.PI / 180)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeScale(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      scaleX,
	      scaleY,
	      scaleZ,
	      scaleLocked
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });

	    if (scaleLocked) {
	      app.editor.execute(new SetScaleCommand(this.selected, new THREE.Vector3(value, value, value)));
	    } else {
	      app.editor.execute(new SetScaleCommand(this.selected, new THREE.Vector3(scaleX, scaleY, scaleZ)));
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	  handleChangeScaleLock(value, name) {
	    this.setState({
	      scaleLocked: value
	    });
	  }

	}

	/**
	 * 设置几何体命令
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 * @param object THREE.Object3D
	 * @param newGeometry THREE.Geometry
	 * @constructor
	 */

	function SetGeometryCommand(object, newGeometry) {
	  Command.call(this);
	  this.type = 'SetGeometryCommand';
	  this.name = _t('Set Geometry');
	  this.updatable = true;
	  this.object = object;
	  this.oldGeometry = object !== undefined ? object.geometry : undefined;
	  this.newGeometry = newGeometry;
	}
	SetGeometryCommand.prototype = Object.create(Command.prototype);
	Object.assign(SetGeometryCommand.prototype, {
	  constructor: SetGeometryCommand,
	  execute: function () {
	    this.object.geometry.dispose();
	    this.object.geometry = this.newGeometry;
	    this.object.geometry.computeBoundingSphere();
	    app.call('geometryChanged', this, this.object);
	  },
	  undo: function () {
	    this.object.geometry.dispose();
	    this.object.geometry = this.oldGeometry;
	    this.object.geometry.computeBoundingSphere();
	    app.call('geometryChanged', this, this.object);
	  },
	  update: function (cmd) {
	    this.newGeometry = cmd.newGeometry;
	  },
	  toJSON: function () {
	    var output = Command.prototype.toJSON.call(this);
	    output.objectUuid = this.object.uuid;
	    output.oldGeometry = this.object.geometry.toJSON();
	    output.newGeometry = this.newGeometry.toJSON();
	    return output;
	  },
	  fromJSON: function (json) {
	    Command.prototype.fromJSON.call(this, json);
	    this.object = this.editor.objectByUuid(json.objectUuid);
	    this.oldGeometry = parseGeometry(json.oldGeometry);
	    this.newGeometry = parseGeometry(json.newGeometry);

	    function parseGeometry(data) {
	      var loader = new THREE.ObjectLoader();
	      return loader.parseGeometries([data])[data.uuid];
	    }
	  }
	});

	/**
	 * 音频监听器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class AudioListenerComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      masterVolume: 1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      masterVolume
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('AudioListener'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: _t('Max Volume'),
	      name: 'masterVolume',
	      value: masterVolume,
	      min: 0,
	      max: 1,
	      step: 0.1,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.AudioListenerComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.AudioListenerComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.camera || editor.selected.children.indexOf(editor.audioListener) === -1) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let audioListener = editor.audioListener;
	    this.setState({
	      show: true,
	      masterVolume: audioListener.getMasterVolume()
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      masterVolume
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let audioListener = app.editor.audioListener;
	    audioListener.setMasterVolume(masterVolume);
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 音频监听器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class BackgroundMusicComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: true,
	      name: '',
	      autoplay: false,
	      loop: true,
	      volume: 1,
	      showPlayButton: false,
	      isPlaying: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.onSelectAudio = this.onSelectAudio.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	    this.handlePlay = this.handlePlay.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      name,
	      autoplay,
	      loop,
	      volume,
	      showPlayButton,
	      isPlaying
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Background Music'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(DisplayProperty, {
	      label: _t('Audio'),
	      name: 'name',
	      value: name === '' ? `(${_t('None')})` : name,
	      btnShow: true,
	      btnText: _t('Select'),
	      onClick: this.handleSelect
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('Auto Play'),
	      name: 'autoplay',
	      value: autoplay,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('Loop'),
	      name: 'loop',
	      value: loop,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Volume'),
	      name: 'volume',
	      value: volume,
	      onChange: this.handleChange
	    }), React.createElement(ButtonProperty, {
	      text: isPlaying ? _t('Stop') : _t('Play'),
	      show: showPlayButton,
	      onChange: this.handlePlay
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.BackgroundMusicComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.BackgroundMusicComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Audio)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let state = {
	      show: true,
	      name: this.selected.userData.Name || '',
	      autoplay: this.selected.userData.autoplay || false,
	      loop: this.selected.getLoop(),
	      volumn: this.selected.getVolume(),
	      showPlayButton: this.selected.buffer != null,
	      isPlaying: this.selected.isPlaying || false
	    };
	    this.setState(state);
	  }

	  handleSelect() {
	    app.call(`selectBottomPanel`, this, 'audio');
	    app.toast(_t('Please click the audio in the Audio Panel.'));
	    app.on(`selectAudio.BackgroundMusicComponent`, this.onSelectAudio);
	  }

	  onSelectAudio(obj) {
	    app.on(`selectAudio.BackgroundMusicComponent`, null);
	    Object.assign(this.selected.userData, obj);
	    let loader = new THREE.AudioLoader();
	    loader.load(obj.Url, buffer => {
	      this.selected.setBuffer(buffer);
	      this.setState({
	        name: obj.Name,
	        showPlayButton: true
	      });
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      autoplay,
	      loop,
	      volumn
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.userData.autoplay = autoplay; // 这里不能给this.selected赋值，否则音频会自动播放

	    this.selected.setLoop(loop);
	    this.selected.setVolume(volumn);
	    app.call('objectChanged', this, this.selected);
	  }

	  handlePlay() {
	    if (!this.selected.buffer) {
	      this.setState({
	        showPlayButton: false,
	        isPlaying: false
	      });
	      return;
	    }

	    if (this.selected.isPlaying) {
	      this.selected.stop();
	    } else {
	      this.selected.play();
	    }

	    this.setState({
	      showPlayButton: true,
	      isPlaying: this.selected.isPlaying
	    });
	  }

	}

	/**
	 * 场景控制器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class ControlComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.type = {
	      '': _t('None'),
	      'FirstPersonControls': _t('First Person Controls'),
	      'FlyControls': _t('Fly Controls'),
	      'OrbitControls': _t('Orbit Controls'),
	      'PointerLockControls': _t('Pointer Lock Controls'),
	      'TrackballControls': _t('Traceball Controls')
	    };
	    this.state = {
	      show: false,
	      expanded: true,
	      type: ''
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      type
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Scene Controller'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(SelectProperty, {
	      label: _t('Type'),
	      options: this.type,
	      name: 'type',
	      value: type,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.ControlComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.ControlComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.camera) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      type: this.selected.userData.control || ''
	    });
	  }

	  handleChange(value, name) {
	    const {
	      type
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.userData.control = type;
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 第一视角控制器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class FirstPersonControlComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      movementSpeed: 10.0,
	      lookSpeed: 0.05,
	      lookVertical: true,
	      autoForward: false,
	      activeLook: true,
	      heightSpeed: false,
	      heightCoef: 1.0,
	      heightMin: 0.0,
	      heightMax: 1.0,
	      constrainVertical: false,
	      verticalMin: 0,
	      verticalMax: 3.14
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      movementSpeed,
	      lookSpeed,
	      lookVertical,
	      autoForward,
	      activeLook,
	      heightSpeed,
	      heightCoef,
	      heightMin,
	      heightMax,
	      constrainVertical,
	      verticalMin,
	      verticalMax
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('First Person Controls'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: _t('MovementSpeed'),
	      name: 'movementSpeed',
	      value: movementSpeed,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('LookSpeed'),
	      name: 'lookSpeed',
	      value: lookSpeed,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('LookVertical'),
	      name: 'lookVertical',
	      value: lookVertical,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('AutoForward'),
	      name: 'autoForward',
	      value: autoForward,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('ActiveLock'),
	      name: 'activeLook',
	      value: activeLook,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('HeightSpeed'),
	      name: 'heightSpeed',
	      value: heightSpeed,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('HeightCoef'),
	      name: 'heightCoef',
	      value: heightCoef,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('HeightMin'),
	      name: 'heightMin',
	      value: heightMin,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('HeightMax'),
	      name: 'heightMax',
	      value: heightMax,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('ConstrainVertical'),
	      name: 'constrainVertical',
	      value: constrainVertical,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('VerticalMin'),
	      name: 'verticalMin',
	      value: verticalMin,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('VerticalMax'),
	      name: 'verticalMax',
	      value: verticalMax,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.FirstPersonControlComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.FirstPersonControlComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.camera || editor.selected.userData.control !== 'FirstPersonControls') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;

	    if (this.selected.userData.firstPersonOptions === undefined) {
	      this.selected.userData.firstPersonOptions = {
	        movementSpeed: 10.0,
	        lookSpeed: 0.05,
	        lookVertical: true,
	        autoForward: false,
	        activeLook: true,
	        heightSpeed: false,
	        heightCoef: 1.0,
	        heightMin: 0.0,
	        heightMax: 1.0,
	        constrainVertical: false,
	        verticalMin: 0,
	        verticalMax: 3.14
	      };
	    }

	    this.setState({
	      show: true,
	      ...this.selected.userData.firstPersonOptions
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      movementSpeed,
	      lookSpeed,
	      lookVertical,
	      autoForward,
	      activeLook,
	      heightSpeed,
	      heightCoef,
	      heightMin,
	      heightMax,
	      constrainVertical,
	      verticalMin,
	      verticalMax
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData.firstPersonOptions, {
	      movementSpeed,
	      lookSpeed,
	      lookVertical,
	      autoForward,
	      activeLook,
	      heightSpeed,
	      heightCoef,
	      heightMin,
	      heightMax,
	      constrainVertical,
	      verticalMin,
	      verticalMax
	    });
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 音频监听器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class FlyControlComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      movementSpeed: 10.0,
	      rollSpeed: 0.05,
	      dragToLook: false,
	      autoForward: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      movementSpeed,
	      rollSpeed,
	      dragToLook,
	      autoForward
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Fly Controls'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: _t('MovementSpeed'),
	      name: 'movementSpeed',
	      value: movementSpeed,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('RotateSpeed'),
	      name: 'rollSpeed',
	      value: rollSpeed,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('DragToLook'),
	      name: 'dragToLook',
	      value: dragToLook,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('AutoForward'),
	      name: 'autoForward',
	      value: autoForward,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.FlyControlComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.FlyControlComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.camera || editor.selected.userData.control !== 'FlyControls') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;

	    if (this.selected.userData.flyOptions === undefined) {
	      this.selected.userData.flyOptions = {
	        movementSpeed: 20.0,
	        rollSpeed: 0.2,
	        dragToLook: false,
	        autoForward: false
	      };
	    }

	    this.setState({
	      show: true,
	      ...this.selected.userData.flyOptions
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      movementSpeed,
	      rollSpeed,
	      dragToLook,
	      autoForward
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData.flyOptions, {
	      movementSpeed,
	      rollSpeed,
	      dragToLook,
	      autoForward
	    });
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 轨道控制器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class OrbitControlComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      minDistance: 0.0,
	      maxDistance: 100000,
	      minPolarAngle: 0,
	      maxPolarAngle: 3.14,
	      minAzimuthAngle: -100,
	      maxAzimuthAngle: 100,
	      enableDamping: false,
	      dampingFactor: 0.25,
	      enableZoom: true,
	      zoomSpeed: 1.0,
	      enableRotate: true,
	      rotateSpeed: 1.0,
	      enablePan: true,
	      panSpeed: 1.0,
	      screenSpacePanning: false,
	      keyPanSpeed: 7.0,
	      autoRotate: false,
	      autoRotateSpeed: 2.0,
	      enableKeys: true
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      minDistance,
	      maxDistance,
	      minPolarAngle,
	      maxPolarAngle,
	      minAzimuthAngle,
	      maxAzimuthAngle,
	      enableDamping,
	      dampingFactor,
	      enableZoom,
	      zoomSpeed,
	      enableRotate,
	      rotateSpeed,
	      enablePan,
	      panSpeed,
	      screenSpacePanning,
	      keyPanSpeed,
	      autoRotate,
	      autoRotateSpeed,
	      enableKeys
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Orbit Controls'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: _t('MinDistance'),
	      name: 'minDistance',
	      value: minDistance,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('MaxDistance'),
	      name: 'maxDistance',
	      value: maxDistance,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('MinPolarAngle'),
	      name: 'minPolarAngle',
	      value: minPolarAngle,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('MaxPolarAngle'),
	      name: 'maxPolarAngle',
	      value: maxPolarAngle,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('MinAzimuthAngle'),
	      name: 'minAzimuthAngle',
	      value: minAzimuthAngle,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('MaxAzimuthAngle'),
	      name: 'maxAzimuthAngle',
	      value: maxAzimuthAngle,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('EnableDamping'),
	      name: 'enableDamping',
	      value: enableDamping,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('DampingFactor'),
	      name: 'dampingFactor',
	      value: dampingFactor,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('EnableZoom'),
	      name: 'enableZoom',
	      value: enableZoom,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('ZoomSpeed'),
	      name: 'zoomSpeed',
	      value: zoomSpeed,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('EnableRotate'),
	      name: 'enableRotate',
	      value: enableRotate,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('RotateSpeed'),
	      name: 'rotateSpeed',
	      value: rotateSpeed,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('PanSpeed'),
	      name: 'enablePan',
	      value: enablePan,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('PanSpeed'),
	      name: 'panSpeed',
	      value: panSpeed,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('ScreenSpacePanning'),
	      name: 'screenSpacePanning',
	      value: screenSpacePanning,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('KeyPanSpeed'),
	      name: 'keyPanSpeed',
	      value: keyPanSpeed,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('AutoRotate'),
	      name: 'autoRotate',
	      value: autoRotate,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('AutoRotateSpeed'),
	      name: 'autoRotateSpeed',
	      value: autoRotateSpeed,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('EnableKeys'),
	      name: 'enableKeys',
	      value: enableKeys,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.OrbitControlComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.OrbitControlComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.camera || editor.selected.userData.control !== 'OrbitControls') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;

	    if (this.selected.userData.orbitOptions === undefined) {
	      this.selected.userData.orbitOptions = {
	        minDistance: 0,
	        maxDistance: 99999,
	        minPolarAngle: 0,
	        maxPolarAngle: Math.PI,
	        minAzimuthAngle: -9999,
	        maxAzimuthAngle: 9999,
	        enableDamping: false,
	        dampingFactor: 0.25,
	        enableZoom: true,
	        zoomSpeed: 1.0,
	        enableRotate: true,
	        rotateSpeed: 1.0,
	        enablePan: true,
	        panSpeed: 1.0,
	        screenSpacePanning: false,
	        keyPanSpeed: 7.0,
	        autoRotate: false,
	        autoRotateSpeed: 2.0,
	        enableKeys: true
	      };
	    }

	    this.setState({
	      show: true,
	      ...this.selected.userData.orbitOptions
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      minDistance,
	      maxDistance,
	      minPolarAngle,
	      maxPolarAngle,
	      minAzimuthAngle,
	      maxAzimuthAngle,
	      enableDamping,
	      dampingFactor,
	      enableZoom,
	      zoomSpeed,
	      enableRotate,
	      rotateSpeed,
	      enablePan,
	      panSpeed,
	      screenSpacePanning,
	      keyPanSpeed,
	      autoRotate,
	      autoRotateSpeed,
	      enableKeys
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData.orbitOptions, {
	      minDistance,
	      maxDistance,
	      minPolarAngle,
	      maxPolarAngle,
	      minAzimuthAngle,
	      maxAzimuthAngle,
	      enableDamping,
	      dampingFactor,
	      enableZoom,
	      zoomSpeed,
	      enableRotate,
	      rotateSpeed,
	      enablePan,
	      panSpeed,
	      screenSpacePanning,
	      keyPanSpeed,
	      autoRotate,
	      autoRotateSpeed,
	      enableKeys
	    });
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 指针锁定控制器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class PointerLockControlComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      isLocked: true
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      isLocked
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Pointer Lock Controls'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('IsLocked'),
	      name: 'isLocked',
	      value: isLocked,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.PointerLockControlComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.PointerLockControlComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.camera || editor.selected.userData.control !== 'PointerLockControls') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;

	    if (this.selected.userData.pointerLockOptions === undefined) {
	      this.selected.userData.pointerLockOptions = {
	        isLocked: true
	      };
	    }

	    this.setState({
	      show: true,
	      ...this.selected.userData.pointerLockOptions
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      isLocked
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData.pointerLockOptions, {
	      isLocked
	    });
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 轨迹球控制器组件
	 * @author tengge / https://github.com/tengge1
	 */

	class TrackballControlComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      rotateSpeed: 1.0,
	      zoomSpeed: 1.2,
	      panSpeed: 0.3,
	      noRotate: false,
	      noZoom: false,
	      noPan: false,
	      staticMoving: false,
	      dynamicDampingFactor: 0.2,
	      minDistance: 0,
	      maxDistance: 99999
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      rotateSpeed,
	      zoomSpeed,
	      panSpeed,
	      noRotate,
	      noZoom,
	      noPan,
	      staticMoving,
	      dynamicDampingFactor,
	      minDistance,
	      maxDistance
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Traceball Controls'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: _t('RotateSpeed'),
	      name: 'rotateSpeed',
	      value: rotateSpeed,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('ZoomSpeed'),
	      name: 'zoomSpeed',
	      value: zoomSpeed,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('PanSpeed'),
	      name: 'panSpeed',
	      value: panSpeed,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('NoRotate'),
	      name: 'noRotate',
	      value: noRotate,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('NoZoom'),
	      name: 'noZoom',
	      value: noZoom,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('NoPan'),
	      name: 'noPan',
	      value: noPan,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('StaticMoving'),
	      name: 'staticMoving',
	      value: staticMoving,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('DampingFactor'),
	      name: 'dynamicDampingFactor',
	      value: dynamicDampingFactor,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('MinDistance'),
	      name: 'minDistance',
	      value: minDistance,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('MaxDistance'),
	      name: 'maxDistance',
	      value: maxDistance,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.TrackballControlComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.TrackballControlComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.camera || editor.selected.userData.control !== 'TrackballControls') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;

	    if (this.selected.userData.trackballOptions === undefined) {
	      this.selected.userData.trackballOptions = {
	        rotateSpeed: 1.0,
	        zoomSpeed: 1.2,
	        panSpeed: 0.3,
	        noRotate: false,
	        noZoom: false,
	        noPan: false,
	        staticMoving: false,
	        dynamicDampingFactor: 0.2,
	        minDistance: 0,
	        maxDistance: 99999
	      };
	    }

	    this.setState({
	      show: true,
	      ...this.selected.userData.trackballOptions
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      rotateSpeed,
	      zoomSpeed,
	      panSpeed,
	      noRotate,
	      noZoom,
	      noPan,
	      staticMoving,
	      dynamicDampingFactor,
	      minDistance,
	      maxDistance
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData.trackballOptions, {
	      rotateSpeed,
	      zoomSpeed,
	      panSpeed,
	      noRotate,
	      noZoom,
	      noPan,
	      staticMoving,
	      dynamicDampingFactor,
	      minDistance,
	      maxDistance
	    });
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 正方体组件
	 * @author tengge / https://github.com/tengge1
	 */

	class BoxGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      type: '',
	      width: 1,
	      height: 1,
	      depth: 1,
	      widthSegments: 1,
	      heightSegments: 1,
	      depthSegments: 1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      type,
	      width,
	      height,
	      depth,
	      widthSegments,
	      heightSegments,
	      depthSegments
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(DisplayProperty, {
	      label: _t('Type'),
	      value: type
	    }), React.createElement(NumberProperty, {
	      name: 'width',
	      label: _t('Width'),
	      value: width,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'height',
	      label: _t('Height'),
	      value: height,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'depth',
	      label: _t('Depth'),
	      value: depth,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      name: 'widthSegments',
	      label: _t('WidthSegments'),
	      value: widthSegments,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      name: 'heightSegments',
	      label: _t('HeightSegments'),
	      value: heightSegments,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      name: 'depthSegments',
	      label: _t('DepthSegments'),
	      value: depthSegments,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.BoxGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.BoxGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.BoxBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      width,
	      height,
	      depth,
	      widthSegments,
	      heightSegments,
	      depthSegments
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      width: width === undefined ? 1 : width,
	      height: height === undefined ? 1 : height,
	      depth: depth === undefined ? 1 : depth,
	      widthSegments: widthSegments === undefined ? 1 : widthSegments,
	      heightSegments: heightSegments === undefined ? 1 : heightSegments,
	      depthSegments: depthSegments === undefined ? 1 : depthSegments
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      width,
	      height,
	      depth,
	      widthSegments,
	      heightSegments,
	      depthSegments
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 圆形组件
	 * @author tengge / https://github.com/tengge1
	 */

	class CircleGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      radius: 1.0,
	      segments: 16,
	      thetaStart: 0.0,
	      thetaLength: Math.PI * 2
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      radius,
	      segments,
	      thetaStart,
	      thetaLength
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      name: 'radius',
	      label: _t('Radius'),
	      value: radius,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      name: 'segments',
	      label: _t('Segments'),
	      value: segments,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'thetaStart',
	      label: _t('ThetaStart'),
	      value: thetaStart,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'thetaLength',
	      label: _t('ThetaLength'),
	      value: thetaLength,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.CircleGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.CircleGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.CircleBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      radius,
	      segments,
	      thetaStart,
	      thetaLength
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      radius: radius === undefined ? 1 : radius,
	      segments: segments === undefined ? 8 : segments,
	      thetaStart: thetaStart === undefined ? 0 : thetaStart,
	      thetaLength: thetaLength === undefined ? Math.PI * 2 : thetaLength
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      radius,
	      segments,
	      thetaStart,
	      thetaLength
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.CircleBufferGeometry(radius, segments, thetaStart, thetaLength)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 圆柱组件
	 * @author tengge / https://github.com/tengge1
	 */

	class CylinderGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      radiusTop: 1.0,
	      radiusBottom: 1.0,
	      height: 1.0,
	      radialSegments: 16,
	      heightSegments: 1,
	      openEnded: false,
	      thetaStart: 0,
	      thetaLength: Math.PI * 2
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      radiusTop,
	      radiusBottom,
	      height,
	      radialSegments,
	      heightSegments,
	      openEnded,
	      thetaStart,
	      thetaLength
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      name: 'radiusTop',
	      label: _t('RadiusTop'),
	      value: radiusTop,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'radiusBottom',
	      label: _t('RadiusBottom'),
	      value: radiusBottom,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'height',
	      label: _t('Height'),
	      value: height,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      name: 'radialSegments',
	      label: _t('RadialSegments'),
	      value: radialSegments,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      name: 'heightSegments',
	      label: _t('HeightSegments'),
	      value: heightSegments,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      name: 'openEnded',
	      label: _t('OpenEnded'),
	      value: openEnded,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'thetaStart',
	      label: _t('ThetaStart'),
	      value: thetaStart,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'thetaLength',
	      label: _t('ThetaLength'),
	      value: thetaLength,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.CylinderGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.CylinderGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.CylinderBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      radiusTop,
	      radiusBottom,
	      height,
	      radialSegments,
	      heightSegments,
	      openEnded,
	      thetaStart,
	      thetaLength
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      radiusTop: radiusTop === undefined ? 1 : radiusTop,
	      radiusBottom: radiusBottom === undefined ? 1 : radiusBottom,
	      height: height === undefined ? 1 : height,
	      radialSegments: radialSegments === undefined ? 8 : radialSegments,
	      heightSegments: heightSegments === undefined ? 1 : heightSegments,
	      openEnded: openEnded === undefined ? false : openEnded,
	      thetaStart: thetaStart === undefined ? 0 : thetaStart,
	      thetaLength: thetaLength === undefined ? Math.PI * 2 : thetaLength
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      radiusTop,
	      radiusBottom,
	      height,
	      radialSegments,
	      heightSegments,
	      openEnded,
	      thetaStart,
	      thetaLength
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 二十面体组件
	 * @author tengge / https://github.com/tengge1
	 */

	class IcosahedronGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      radius: 1.0,
	      detail: 1.0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      radius,
	      detail
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      name: 'radius',
	      label: _t('Radius'),
	      value: radius,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'detail',
	      label: _t('Detail'),
	      value: detail,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.IcosahedronGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.IcosahedronGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.IcosahedronBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      radius,
	      detail
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      radius: radius === undefined ? 1 : radius,
	      detail: detail === undefined ? 0 : detail
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      radius,
	      detail
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.setState(state);
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.IcosahedronBufferGeometry(radius, detail)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 车床组件
	 * @author tengge / https://github.com/tengge1
	 */

	class LatheGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      segments: 16,
	      phiStart: 0.0,
	      phiLength: Math.PI * 2
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      segments,
	      phiStart,
	      phiLength
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(IntegerProperty, {
	      name: 'segments',
	      label: _t('RadialSegments'),
	      value: segments,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'phiStart',
	      label: _t('PhiStart'),
	      value: phiStart,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'phiLength',
	      label: _t('PhiLength'),
	      value: phiLength,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.LatheGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.LatheGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.LatheBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      segments,
	      phiStart,
	      phiLength
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      segments: segments === undefined ? 12 : segments,
	      phiStart: phiStart === undefined ? 0 : phiStart,
	      phiLength: phiLength === undefined ? Math.PI * 2 : phiLength
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      segments,
	      phiStart,
	      phiLength
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    const points = this.selected.geometry.parameters.points;
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.LatheBufferGeometry(points, segments, phiStart, phiLength)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 平板组件
	 * @author tengge / https://github.com/tengge1
	 */

	class PlaneGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      width: 1,
	      height: 1,
	      widthSegments: 1,
	      heightSegments: 1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      width,
	      height,
	      widthSegments,
	      heightSegments
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      name: 'width',
	      label: _t('Width'),
	      value: width,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'height',
	      label: _t('Height'),
	      value: height,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      name: 'widthSegments',
	      label: _t('WidthSegments'),
	      value: widthSegments,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      name: 'heightSegments',
	      label: _t('HeightSegments'),
	      value: heightSegments,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.PlaneGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.PlaneGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.PlaneBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      width,
	      height,
	      widthSegments,
	      heightSegments
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      width: width === undefined ? 1 : width,
	      height: height === undefined ? 1 : height,
	      widthSegments: widthSegments === undefined ? 1 : widthSegments,
	      heightSegments: heightSegments === undefined ? 1 : heightSegments
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      width,
	      height,
	      widthSegments,
	      heightSegments
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 球体组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SphereGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      radius: 1,
	      widthSegments: 16,
	      heightSegments: 16,
	      phiStart: 0,
	      phiLength: Math.PI * 2,
	      thetaStart: 0,
	      thetaLength: Math.PI / 2
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      radius,
	      widthSegments,
	      heightSegments,
	      phiStart,
	      phiLength,
	      thetaStart,
	      thetaLength
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      name: 'radius',
	      label: _t('Radius'),
	      value: radius,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      name: 'widthSegments',
	      label: _t('WidthSegments'),
	      value: widthSegments,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      name: 'heightSegments',
	      label: _t('HeightSegments'),
	      value: heightSegments,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'phiStart',
	      label: _t('PhiStart'),
	      value: phiStart,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'phiLength',
	      label: _t('PhiLength'),
	      value: phiLength,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'thetaStart',
	      label: _t('ThetaStart'),
	      value: thetaStart,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'thetaLength',
	      label: _t('ThetaLength'),
	      value: thetaLength,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SphereGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.SphereGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.SphereBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      radius,
	      widthSegments,
	      heightSegments,
	      phiStart,
	      phiLength,
	      thetaStart,
	      thetaLength
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      radius: radius === undefined ? 1 : radius,
	      widthSegments: widthSegments === undefined ? 8 : widthSegments,
	      heightSegments: heightSegments === undefined ? 6 : heightSegments,
	      phiStart: phiStart === undefined ? 0 : phiStart,
	      phiLength: phiLength === undefined ? Math.PI * 2 : phiLength,
	      thetaStart: thetaStart === undefined ? 0 : thetaStart,
	      thetaLength: thetaLength === undefined ? Math.PI : thetaLength
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      radius,
	      widthSegments,
	      heightSegments,
	      phiStart,
	      phiLength,
	      thetaStart,
	      thetaLength
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 茶壶组件
	 * @author tengge / https://github.com/tengge1
	 */

	class TeapotGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      size: 3,
	      segments: 10,
	      bottom: true,
	      lid: true,
	      body: true,
	      fitLid: true,
	      blinn: true
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      size,
	      segments,
	      bottom,
	      lid,
	      body,
	      fitLid,
	      blinn
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      name: 'size',
	      label: _t('Size'),
	      value: size,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      name: 'segments',
	      label: _t('Segments'),
	      value: segments,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      name: 'bottom',
	      label: _t('Bottom'),
	      value: bottom,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      name: 'lid',
	      label: _t('Lid'),
	      value: lid,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      name: 'body',
	      label: _t('Body'),
	      value: body,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      name: 'fitLid',
	      label: _t('FitLid'),
	      value: fitLid,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      name: 'blinn',
	      label: _t('Blinn'),
	      value: blinn,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.TeapotGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.TeapotGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.TeapotBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      size,
	      segments,
	      bottom,
	      lid,
	      body,
	      fitLid,
	      blinn
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      size: size === undefined ? 50 : size,
	      segments: segments === undefined ? 10 : segments,
	      bottom: bottom === undefined ? true : bottom,
	      lid: lid === undefined ? true : lid,
	      body: body === undefined ? true : body,
	      fitLid: fitLid === undefined ? true : fitLid,
	      blinn: blinn === undefined ? true : blinn
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      size,
	      segments,
	      bottom,
	      lid,
	      body,
	      fitLid,
	      blinn
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let geometry = new THREE.TeapotBufferGeometry(size, segments, bottom, lid, body, fitLid, blinn);
	    geometry.type = 'TeapotBufferGeometry';
	    geometry.parameters = {
	      size,
	      segments,
	      bottom,
	      lid,
	      body,
	      fitLid,
	      blinn
	    };
	    app.editor.execute(new SetGeometryCommand(this.selected, geometry));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 花托组件
	 * @author tengge / https://github.com/tengge1
	 */

	class TorusGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      radius: 1,
	      tube: 1,
	      radialSegments: 16,
	      tubularSegments: 16,
	      arc: Math.PI * 2
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      radius,
	      tube,
	      radialSegments,
	      tubularSegments,
	      arc
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      name: 'radius',
	      label: _t('Radius'),
	      value: radius,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'tube',
	      label: _t('Tube'),
	      value: tube,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      name: 'radialSegments',
	      label: _t('RadialSegments'),
	      value: radialSegments,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      name: 'tubularSegments',
	      label: _t('TubelarSegments'),
	      value: tubularSegments,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'arc',
	      label: _t('Arc'),
	      value: arc,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.TorusGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.TorusGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.TorusBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      radius,
	      tube,
	      radialSegments,
	      tubularSegments,
	      arc
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      radius: radius === undefined ? 1 : radius,
	      tube: tube === undefined ? 0.4 : tube,
	      radialSegments: radialSegments === undefined ? 8 : radialSegments,
	      tubularSegments: tubularSegments === undefined ? 16 : tubularSegments,
	      arc: arc === undefined ? Math.PI * 2 : arc
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      radius,
	      tube,
	      radialSegments,
	      tubularSegments,
	      arc
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.setState(state);
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 环面纽结组件
	 * @author tengge / https://github.com/tengge1
	 */

	class TorusKnotGeometryComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      radius: 1,
	      tube: 1,
	      tubularSegments: 16,
	      radialSegments: 16,
	      p: 20,
	      q: 20
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      radius,
	      tube,
	      tubularSegments,
	      radialSegments,
	      p,
	      q
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Geometry Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      name: 'radius',
	      label: _t('Radius'),
	      value: radius,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'tube',
	      label: _t('Tube'),
	      value: tube,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      name: 'tubularSegments',
	      label: _t('TubelarSegments'),
	      value: tubularSegments,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      name: 'radialSegments',
	      label: _t('RadialSegments'),
	      value: radialSegments,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'p',
	      label: _t('TubeArc'),
	      value: p,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      name: 'q',
	      label: _t('DistortedArc'),
	      value: q,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.TorusKnotGeometryComponent`, this.handleUpdate);
	    app.on(`objectChanged.TorusKnotGeometryComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof THREE.Mesh) || !(editor.selected.geometry instanceof THREE.TorusKnotBufferGeometry)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    const {
	      radius,
	      tube,
	      tubularSegments,
	      radialSegments,
	      p,
	      q
	    } = Object.assign({}, this.selected.geometry.parameters);
	    this.setState({
	      show: true,
	      type: this.selected.geometry.constructor.name,
	      radius: radius === undefined ? 1 : radius,
	      tube: tube === undefined ? 0.4 : tube,
	      tubularSegments: tubularSegments === undefined ? 64 : tubularSegments,
	      radialSegments: radialSegments === undefined ? 8 : radialSegments,
	      p: p === undefined ? 2 : p,
	      q: q === undefined ? 3 : q
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      radius,
	      tube,
	      tubularSegments,
	      radialSegments,
	      p,
	      q
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.setState(state);
	    app.editor.execute(new SetGeometryCommand(this.selected, new THREE.TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q)));
	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * GIS基本组件
	 * @author tengge / https://github.com/tengge1
	 */

	class GisBasicComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.bakcground = {
	      google: _t('Google Map'),
	      bing: _t('Bing Map'),
	      tianditu: _t('Tianditu Map')
	    };
	    this.state = {
	      show: false,
	      expanded: true,
	      bakcground: 'google'
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      bakcground
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('GIS Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(SelectProperty, {
	      label: _t('Map'),
	      options: this.bakcground,
	      name: 'bakcground',
	      value: bakcground,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.GisBasicComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.GisBasicComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected.userData.type !== 'Globe') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      bakcground: this.selected.getBackground()
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      bakcground
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.setBackground(bakcground);
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * CatmullRom曲线组件
	 * @author tengge / https://github.com/tengge1
	 */

	class CatmullRomCurveComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.curveType = {
	      centripetal: _t('Centripetal Force'),
	      chordal: _t('Chord'),
	      catmullrom: _t('Catmullrom')
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      closed: true,
	      curveType: 'catmullrom',
	      tension: 1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleAddPoint = this.handleAddPoint.bind(this);
	    this.handleRemovePoint = this.handleRemovePoint.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      closed,
	      curveType,
	      tension
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('CatmullRom Curve'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(ButtonsProperty, null, React.createElement(Button, {
	      onClick: this.handleAddPoint
	    }, _t('Add Point')), React.createElement(Button, {
	      onClick: this.handleRemovePoint
	    }, _t('Remove Point'))), React.createElement(CheckBoxProperty, {
	      label: _t('Closed'),
	      name: 'closed',
	      value: closed,
	      onChange: this.handleChange
	    }), React.createElement(SelectProperty, {
	      label: _t('Curve Type'),
	      options: this.curveType,
	      name: 'curveType',
	      value: curveType,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Tension'),
	      name: 'tension',
	      value: tension,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.CatmullRomCurveComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.CatmullRomCurveComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected.userData.type !== 'CatmullRomCurve') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      closed: this.selected.userData.closed,
	      curveType: this.selected.userData.curveType,
	      tension: this.selected.userData.tension
	    });
	  }

	  handleAddPoint() {
	    let points = this.selected.userData.points;
	    let closed = this.selected.userData.closed;
	    let curveType = this.selected.userData.curveType;
	    let tension = this.selected.userData.tension;
	    let curve = new THREE.CatmullRomCurve3(points, closed, curveType, tension);
	    let point = new THREE.Vector3(parseInt((Math.random() - 0.5) * 40), parseInt(Math.random() * 20), parseInt((Math.random() - 0.5) * 40));
	    points.splice(points.length, 0, point);
	    this.selected.update();
	    app.call('objectChanged', this, this.selected);
	  }

	  handleRemovePoint() {
	    let points = this.selected.userData.points;

	    if (points.length === 3) {
	      app.toast(_t('CatmullRom curve should have at least 3 points.'));
	      return;
	    }

	    points.splice(points.length - 1, 1);
	    this.selected.update();
	    app.call('objectChanged', this, this.selected);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      closed,
	      curveType,
	      tension
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData, {
	      closed,
	      curveType,
	      tension
	    });
	    this.selected.update();
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 三次贝塞尔曲线组件
	 * @author tengge / https://github.com/tengge1
	 */

	class CubicBezierCurveComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      v0x: 0,
	      v0y: 0,
	      v0z: 0,
	      v1x: 0,
	      v1y: 0,
	      v1z: 0,
	      v2x: 0,
	      v2y: 0,
	      v2z: 0,
	      v3x: 0,
	      v3y: 0,
	      v3z: 0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      v0x,
	      v0y,
	      v0z,
	      v1x,
	      v1y,
	      v1z,
	      v2x,
	      v2y,
	      v2z,
	      v3x,
	      v3y,
	      v3z
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('CubicBezier Curve'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: 'Point1 X',
	      name: 'v0x',
	      value: v0x,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point1 Y',
	      name: 'v0y',
	      value: v0y,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point1 Z',
	      name: 'v0z',
	      value: v0z,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point2 X',
	      name: 'v1x',
	      value: v1x,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point2 Y',
	      name: 'v1y',
	      value: v1y,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point2 Z',
	      name: 'v1z',
	      value: v1z,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point3 X',
	      name: 'v2x',
	      value: v2x,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point3 Y',
	      name: 'v2y',
	      value: v2y,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point3 Z',
	      name: 'v2z',
	      value: v2z,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point4 X',
	      name: 'v3x',
	      value: v3x,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point4 Y',
	      name: 'v3y',
	      value: v3y,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point4 Z',
	      name: 'v3z',
	      value: v3z,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.CubicBezierCurveComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.CubicBezierCurveComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected.userData.type !== 'CubicBezierCurve') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let points = this.selected.userData.points;
	    this.setState({
	      show: true,
	      v0x: points[0].x,
	      v0y: points[0].y,
	      v0z: points[0].z,
	      v1x: points[1].x,
	      v1y: points[1].y,
	      v1z: points[1].z,
	      v2x: points[2].x,
	      v2y: points[2].y,
	      v2z: points[2].z,
	      v3x: points[3].x,
	      v3y: points[3].y,
	      v3z: points[3].z
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      v0x,
	      v0y,
	      v0z,
	      v1x,
	      v1y,
	      v1z,
	      v2x,
	      v2y,
	      v2z,
	      v3x,
	      v3y,
	      v3z
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.userData.points = [new THREE.Vector3(v0x, v0y, v0z), new THREE.Vector3(v1x, v1y, v1z), new THREE.Vector3(v2x, v2y, v2z), new THREE.Vector3(v3x, v3y, v3z)];
	    this.selected.update();
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 椭圆曲线组件
	 * @author tengge / https://github.com/tengge1
	 */

	class EllipseCurveComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      aX: 0,
	      aY: 0,
	      xRadius: 0,
	      yRadius: 0,
	      aStartAngle: 0,
	      aEndAngle: 0,
	      aClockwise: false,
	      aRotation: 0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      aX,
	      aY,
	      xRadius,
	      yRadius,
	      aStartAngle,
	      aEndAngle,
	      aClockwise,
	      aRotation
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Ellipse Curve'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: 'Center X',
	      name: 'aX',
	      value: aX,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Center Y',
	      name: 'aY',
	      value: aY,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Radius X',
	      name: 'xRadius',
	      value: xRadius,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Radius Y',
	      name: 'yRadius',
	      value: yRadius,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Start Angle',
	      name: 'aStartAngle',
	      value: aStartAngle,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'End Angle',
	      name: 'aEndAngle',
	      value: aEndAngle,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: 'Clockwise',
	      name: 'aClockwise',
	      value: aClockwise,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Rotation',
	      name: 'aRotation',
	      value: aRotation,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.EllipseCurveComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.EllipseCurveComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected.userData.type !== 'EllipseCurve') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      aX: this.selected.userData.aX,
	      aY: this.selected.userData.aY,
	      xRadius: this.selected.userData.xRadius,
	      yRadius: this.selected.userData.yRadius,
	      aStartAngle: this.selected.userData.aStartAngle,
	      aEndAngle: this.selected.userData.aEndAngle,
	      aClockwise: this.selected.userData.aClockwise,
	      aRotation: this.selected.userData.aRotation
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      aX,
	      aY,
	      xRadius,
	      yRadius,
	      aStartAngle,
	      aEndAngle,
	      aClockwise,
	      aRotation
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData, {
	      aX,
	      aY,
	      xRadius,
	      yRadius,
	      aStartAngle,
	      aEndAngle,
	      aClockwise,
	      aRotation
	    });
	    this.selected.update();
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 椭圆曲线组件
	 * @author tengge / https://github.com/tengge1
	 */

	class LineCurveComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      v1x: 0,
	      v1y: 0,
	      v1z: 0,
	      v2x: 0,
	      v2y: 0,
	      v2z: 0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      v1x,
	      v1y,
	      v1z,
	      v2x,
	      v2y,
	      v2z
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Line Curve'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: 'Point1 X',
	      name: 'v1x',
	      value: v1x,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point1 Y',
	      name: 'v1y',
	      value: v1y,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point1 Z',
	      name: 'v1z',
	      value: v1z,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point2 X',
	      name: 'v2x',
	      value: v2x,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point2 Y',
	      name: 'v2y',
	      value: v2y,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point2 Z',
	      name: 'v2z',
	      value: v2z,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.LineCurveComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.LineCurveComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected.userData.type !== 'LineCurve') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let points = this.selected.userData.points;
	    this.setState({
	      show: true,
	      v1x: points[0].x,
	      v1y: points[0].y,
	      v1z: points[0].z,
	      v2x: points[1].x,
	      v2y: points[1].y,
	      v2z: points[1].z
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      v1x,
	      v1y,
	      v1z,
	      v2x,
	      v2y,
	      v2z
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.userData.points = [new THREE.Vector3(v1x, v1y, v1z), new THREE.Vector3(v2x, v2y, v2z)];
	    this.selected.update();
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 二次贝塞尔曲线组件
	 * @author tengge / https://github.com/tengge1
	 */

	class QuadraticBezierCurveComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      v0x: 0,
	      v0y: 0,
	      v0z: 0,
	      v1x: 0,
	      v1y: 0,
	      v1z: 0,
	      v2x: 0,
	      v2y: 0,
	      v2z: 0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      v0x,
	      v0y,
	      v0z,
	      v1x,
	      v1y,
	      v1z,
	      v2x,
	      v2y,
	      v2z
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('QuadraticBezier Curve'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: 'Point1 X',
	      name: 'v0x',
	      value: v0x,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point1 Y',
	      name: 'v0y',
	      value: v0y,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point1 Z',
	      name: 'v0z',
	      value: v0z,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point2 X',
	      name: 'v1x',
	      value: v1x,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point2 Y',
	      name: 'v1y',
	      value: v1y,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point2 Z',
	      name: 'v1z',
	      value: v1z,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point3 X',
	      name: 'v2x',
	      value: v2x,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point3 Y',
	      name: 'v2y',
	      value: v2y,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Point3 Z',
	      name: 'v2z',
	      value: v2z,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.QuadraticBezierCurveComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.QuadraticBezierCurveComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected.userData.type !== 'QuadraticBezierCurve') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let points = this.selected.userData.points;
	    this.setState({
	      show: true,
	      v0x: points[0].x,
	      v0y: points[0].y,
	      v0z: points[0].z,
	      v1x: points[1].x,
	      v1y: points[1].y,
	      v1z: points[1].z,
	      v2x: points[2].x,
	      v2y: points[2].y,
	      v2z: points[2].z
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      v0x,
	      v0y,
	      v0z,
	      v1x,
	      v1y,
	      v1z,
	      v2x,
	      v2y,
	      v2z
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.userData.points = [new THREE.Vector3(v0x, v0y, v0z), new THREE.Vector3(v1x, v1y, v1z), new THREE.Vector3(v2x, v2y, v2z)];
	    this.selected.update();
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 布组件
	 * @author tengge / https://github.com/tengge1
	 */

	class ClothComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.isPlaying = false;
	    this.state = {
	      show: false,
	      expanded: true,
	      previewText: _t('Preview')
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handlePreview = this.handlePreview.bind(this);
	    this.onAnimate = this.onAnimate.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      previewText
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('ClothComponent'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(ButtonProperty, {
	      text: previewText,
	      onChange: this.handlePreview
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.ClothComponent`, this.handleUpdate);
	    app.on(`objectChanged.ClothComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected.userData.type === 'Cloth')) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      previewText: this.isPlaying ? _t('Cancel') : _t('Preview')
	    });
	  }

	  handlePreview() {
	    if (this.isPlaying) {
	      this.stopPreview();
	    } else {
	      this.startPreview();
	    }
	  }

	  startPreview() {
	    this.isPlaying = true;
	    this.setState({
	      previewText: _t('Cancel')
	    });
	    app.on(`animate.ClothComponent`, this.onAnimate);
	  }

	  stopPreview() {
	    this.isPlaying = false;
	    this.setState({
	      previewText: _t('Preview')
	    });
	    app.on(`animate.ClothComponent`, null);
	  }

	  onAnimate(clock, deltaTime) {
	    this.selected.update();
	  }

	}

	/**
	 * 柏林地形组件
	 * @author tengge / https://github.com/tengge1
	 */

	class PerlinTerrainComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: true,
	      width: 1000,
	      depth: 1000,
	      widthSegments: 256,
	      depthSegments: 256,
	      quality: 80
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      width,
	      depth,
	      widthSegments,
	      depthSegments,
	      quality
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Perlin Terrain'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: _t('Width'),
	      name: 'width',
	      value: width,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Depth'),
	      name: 'depth',
	      value: depth,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      label: _t('WidthSegments'),
	      name: 'widthSegments',
	      value: widthSegments,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      label: _t('DepthSegments'),
	      name: 'depthSegments',
	      value: depthSegments,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Quality'),
	      name: 'quality',
	      value: quality,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.PerlinTerrainComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.PerlinTerrainComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof PerlinTerrain)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      width: this.selected.userData.width,
	      depth: this.selected.userData.depth,
	      widthSegments: this.selected.userData.widthSegments,
	      depthSegments: this.selected.userData.depthSegments,
	      quality: this.selected.userData.quality
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      width,
	      depth,
	      widthSegments,
	      depthSegments,
	      quality
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let terrain = new PerlinTerrain(width, depth, widthSegments, depthSegments, quality);
	    const editor = app.editor;
	    const index = editor.scene.children.indexOf(this.selected);

	    if (index > -1) {
	      editor.select(null);
	      editor.scene.children[index] = terrain;
	      terrain.parent = this.selected.parent;
	      this.selected.parent = null;
	      app.call(`objectRemoved`, this, this.selected);
	      app.call(`objectAdded`, this, terrain);
	      editor.select(terrain);
	    }
	  }

	}

	/**
	 * 天空组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SkyComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: true,
	      turbidity: 10,
	      rayleigh: 2,
	      luminance: 1,
	      mieCoefficient: 0.005,
	      mieDirectionalG: 0.005
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      turbidity,
	      rayleigh,
	      luminance,
	      mieCoefficient,
	      mieDirectionalG
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Sky'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: _t('Turbidity'),
	      name: 'turbidity',
	      value: turbidity,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Rayleigh'),
	      name: 'rayleigh',
	      value: rayleigh,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Luminance'),
	      name: 'luminance',
	      value: luminance,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('MieCofficient'),
	      name: 'mieCoefficient',
	      value: mieCoefficient,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('MieDirectionalG'),
	      name: 'mieDirectionalG',
	      value: mieDirectionalG,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SkyComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.SkyComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected instanceof Sky)) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      turbidity: this.selected.userData.turbidity,
	      rayleigh: this.selected.userData.rayleigh,
	      luminance: this.selected.userData.luminance,
	      mieCoefficient: this.selected.userData.mieCoefficient * 100,
	      mieDirectionalG: this.selected.userData.mieDirectionalG
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      turbidity,
	      rayleigh,
	      luminance,
	      mieCoefficient,
	      mieDirectionalG
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    Object.assign(this.selected.userData, {
	      turbidity,
	      rayleigh,
	      luminance,
	      mieCoefficient: mieCoefficient / 100,
	      mieDirectionalG
	    });
	    const sky = this.selected.children.filter(n => n instanceof THREE.Sky)[0];

	    if (sky) {
	      let uniforms = sky.material.uniforms;
	      uniforms.turbidity.value = turbidity;
	      uniforms.rayleigh.value = rayleigh;
	      uniforms.luminance.value = luminance;
	      uniforms.mieCoefficient.value = mieCoefficient / 100;
	      uniforms.mieDirectionalG.value = mieDirectionalG;
	      sky.material.needsUpdate = true;
	    }

	    app.call(`objectChanged`, this, this.selected);
	  }

	}

	/**
	 * 水组件
	 * @author tengge / https://github.com/tengge1
	 */

	class WaterComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.isPlaying = false;
	    this.state = {
	      show: false,
	      expanded: true,
	      previewText: _t('Preview')
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handlePreview = this.handlePreview.bind(this);
	    this.onAnimate = this.onAnimate.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      previewText
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Water Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(ButtonProperty, {
	      text: previewText,
	      onChange: this.handlePreview
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.WaterComponent`, this.handleUpdate);
	    app.on(`objectChanged.WaterComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !(editor.selected.userData.type === 'Water')) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    this.setState({
	      show: true,
	      previewText: this.isPlaying ? _t('Cancel') : _t('Preview')
	    });
	  }

	  handlePreview() {
	    if (this.isPlaying) {
	      this.stopPreview();
	    } else {
	      this.startPreview();
	    }
	  }

	  startPreview() {
	    this.isPlaying = true;
	    this.setState({
	      previewText: _t('Cancel')
	    });
	    app.on(`animate.WaterComponent`, this.onAnimate);
	  }

	  stopPreview() {
	    this.isPlaying = false;
	    this.setState({
	      previewText: _t('Preview')
	    });
	    app.on(`animate.WaterComponent`, null);
	  }

	  onAnimate(clock, deltaTime) {
	    this.selected.update();
	  }

	}

	/**
	 * 物理类型组件
	 * @author tengge / https://github.com/tengge1
	 */

	class PhysicsTypeComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.type = {
	      rigidBody: _t('RigidBody'),
	      softVolume: _t('SoftVolume')
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      physicsEnabled: false,
	      type: 'rigidBody'
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      physicsEnabled,
	      type
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('PhysicsType'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('Enabled'),
	      name: 'physicsEnabled',
	      value: physicsEnabled,
	      onChange: this.handleChange
	    }), React.createElement(SelectProperty, {
	      label: _t('Type'),
	      options: this.type,
	      name: 'type',
	      value: type,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.PhysicsTypeComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.PhysicsTypeComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !editor.selected.userData.physics || editor.selected === editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let physics = this.selected.userData.physics || {};
	    this.setState({
	      show: true,
	      physicsEnabled: physics.enabled || false,
	      type: physics.type || 'rigidBody'
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      physicsEnabled,
	      type
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });

	    if (!this.selected.userData.physics) {
	      this.selected.userData.physics = {};
	    }

	    let physics = this.selected.userData.physics;
	    physics.enabled = physicsEnabled;
	    physics.type = type;
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 物理环境组件
	 * @author tengge / https://github.com/tengge1
	 */

	class PhysicsWorldComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.type = {
	      'btDefaultCollisionConfiguration': _t('DefaultCollisionConfig'),
	      // 无法使用布料
	      'btSoftBodyRigidBodyCollisionConfiguration': _t('SoftBodyRigidBodyCollisionConfig')
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      type: 'btSoftBodyRigidBodyCollisionConfiguration',
	      gravityX: 0,
	      gravityY: -9.8,
	      gravityZ: 0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      type,
	      gravityX,
	      gravityY,
	      gravityZ
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('PhysicsEnvironment'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(SelectProperty, {
	      label: _t('Type'),
	      options: this.type,
	      name: 'type',
	      value: type,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'GravityX',
	      name: 'gravityX',
	      value: gravityX,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'GravityY',
	      name: 'gravityY',
	      value: gravityY,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'GravityZ',
	      name: 'gravityZ',
	      value: gravityZ,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.PhysicsWorldComponent`, this.handleUpdate.bind(this));
	    app.on(`objectChanged.PhysicsWorldComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;

	    if (!this.selected.userData.physics) {
	      this.selected.userData.physics = {
	        type: 'btSoftBodyRigidBodyCollisionConfiguration',
	        gravityX: 0.0,
	        gravityY: -9.8,
	        gravityZ: 0.0
	      };
	    }

	    let {
	      type,
	      gravityX,
	      gravityY,
	      gravityZ
	    } = this.selected.userData.physics;
	    this.setState({
	      show: true,
	      type,
	      gravityX,
	      gravityY,
	      gravityZ
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      type,
	      gravityX,
	      gravityY,
	      gravityZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.selected.userData.physics = {
	      type,
	      gravityX,
	      gravityY,
	      gravityZ
	    };
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 立方体帮助器
	 * @param {*} object 
	 */
	function BoxShapeHelper(object) {
	  this.object = object;
	  var geometry = this.object.geometry;
	  geometry.computeBoundingBox();
	  var box = geometry.boundingBox;
	  var x = box.max.x - box.min.x;
	  var y = box.max.y - box.min.y;
	  var z = box.max.z - box.min.z;
	  var center = new THREE.Vector3();
	  box.getCenter(center);
	  var geometry = new THREE.BoxBufferGeometry(x, y, z);
	  geometry.translate(center.x, center.y, center.z);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xffff00
	  });
	  material.wireframe = true;
	  material.depthTest = false;
	  THREE.Mesh.call(this, geometry, material);
	  this.update();
	}
	BoxShapeHelper.prototype = Object.create(THREE.Mesh.prototype);
	BoxShapeHelper.prototype.constructor = BoxShapeHelper;

	BoxShapeHelper.prototype.update = function () {
	  this.object.geometry.computeBoundingBox();
	  this.position.copy(this.object.position);
	  this.rotation.copy(this.object.rotation);
	  this.scale.copy(this.object.scale);
	};

	/**
	 * 立方体帮助器
	 * @param {*} object 
	 */
	function SphereShapeHelper(object) {
	  this.object = object;
	  var geometry = this.object.geometry;
	  geometry.computeBoundingSphere();
	  var sphere = geometry.boundingSphere;
	  var geometry = new THREE.SphereBufferGeometry(sphere.radius);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xffff00
	  });
	  material.wireframe = true;
	  material.depthTest = false;
	  THREE.Mesh.call(this, geometry, material);
	  this.update();
	}
	SphereShapeHelper.prototype = Object.create(THREE.Mesh.prototype);
	SphereShapeHelper.prototype.constructor = SphereShapeHelper;

	SphereShapeHelper.prototype.update = function () {
	  this.object.geometry.computeBoundingSphere();
	  this.position.copy(this.object.position);
	  this.rotation.copy(this.object.rotation);
	  this.scale.copy(this.object.scale);
	};

	let physicsShapeHelper = {
	  btBoxShape: BoxShapeHelper,
	  btSphereShape: SphereShapeHelper
	};
	/**
	 * 刚体组件
	 * @author tengge / https://github.com/tengge1
	 */

	class RigidBodyComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.shape = {
	      btBoxShape: _t('BoxShape'),
	      // btBvhTriangleMeshShape: 'bvh三角形网格',
	      // btCapsuleShape: '胶囊',
	      // btCapsuleShapeX: 'x轴胶囊',
	      // btCapsuleShapeZ: 'z轴胶囊',
	      // btCollisionShape: '碰撞体',
	      // btCompoundShape: '复合形状',
	      // btConcaveShape: '凹面体',
	      // btConeShape: '圆锥体',
	      // btConeShapeX: 'x轴圆椎体',
	      // btConeShapeZ: 'z轴圆椎体',
	      // btConvexHullShape: '凸包',
	      // btConvexShape: '凸面体',
	      // btConvexTriangleMeshShape: '凸三角形网格',
	      // btCylinderShape: '圆柱体',
	      // btCylinderShapeX: 'x轴圆柱体',
	      // btCylinderShapeZ: 'z轴圆柱体',
	      // btHeightfieldTerrainShape: '灰阶高程地形',
	      btSphereShape: _t('SphereShape') // btStaticPlaneShape: '静态平板',
	      // btTriangleMeshShape: '三角网格'

	    };
	    this.state = {
	      show: false,
	      expanded: true,
	      shape: 'btBoxShape',
	      mass: 1,
	      inertiaX: 0,
	      inertiaY: 0,
	      inertiaZ: 0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	    this.handleRemoved = this.handleRemoved.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      shape,
	      mass,
	      inertiaX,
	      inertiaY,
	      inertiaZ
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('RigidBody'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(SelectProperty, {
	      label: _t('Shape'),
	      options: this.shape,
	      name: 'shape',
	      value: shape,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'Mass',
	      name: 'mass',
	      value: mass,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'InertiaX',
	      name: 'inertiaX',
	      value: inertiaX,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'InertiaY',
	      name: 'inertiaY',
	      value: inertiaY,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: 'InertiaZ',
	      name: 'inertiaZ',
	      value: inertiaZ,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.RigidBodyComponent`, this.handleUpdate);
	    app.on(`objectChanged.RigidBodyComponent`, this.handleUpdate);
	    app.on(`objectRemoved.RigidBodyComponent`, this.handleRemoved);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !editor.selected.userData.physics || !editor.selected.userData.physics.enabled || editor.selected.userData.physics.type !== 'rigidBody') {
	      if (this.helper !== undefined) {
	        app.editor.removePhysicsHelper(this.helper);
	      }

	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let {
	      shape,
	      mass,
	      inertia
	    } = this.selected.userData.physics || {};
	    this.setState({
	      show: true,
	      shape: shape || 'btBoxShape',
	      mass: mass || 0,
	      inertiaX: inertia.x || 0,
	      inertiaY: inertia.y || 0,
	      inertiaZ: inertia.z || 0
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      shape,
	      mass,
	      inertiaX,
	      inertiaY,
	      inertiaZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let physics = this.selected.userData.physics;
	    physics.shape = shape;
	    physics.mass = mass;
	    physics.inertia.x = inertiaX;
	    physics.inertia.y = inertiaY;
	    physics.inertia.z = inertiaZ;
	    app.call('objectChanged', this, this.selected);
	  }

	  handleRemoved(object) {
	    if (this.helper && this.helper.object === object) {
	      app.editor.removePhysicsHelper(this.helper);
	    }
	  } // -------------------------- 物理形状帮助器 -------------------------------------


	  showPhysicsShapeHelper() {
	    if (this.selected == null) {
	      return;
	    }

	    if (this.helper !== undefined) {
	      app.editor.removePhysicsHelper(this.helper);
	    }

	    let physics = this.selected.userData.physics;

	    if (!physics || !physics.enabled) {
	      return;
	    }

	    let helper = physicsShapeHelper[physics.shape];

	    if (!helper) {
	      console.warn(`RigidBodyComponent: ${physics.shape} ${_t('has no physics helper.')}`);
	      return;
	    }

	    this.helper = new helper(this.selected);
	    app.editor.addPhysicsHelper(this.helper);
	  }

	}

	/**
	 * 柔软体组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SoftVolumeComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: true,
	      mass: 1,
	      pressure: 1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      mass,
	      pressure
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('SoftVolume'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(NumberProperty, {
	      label: 'Mass',
	      name: 'mass',
	      value: mass,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Pressure'),
	      name: 'pressure',
	      value: pressure,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SoftVolumeComponent`, this.handleUpdate);
	    app.on(`objectChanged.SoftVolumeComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || !editor.selected.userData.physics || !editor.selected.userData.physics.enabled || editor.selected.userData.physics.type !== 'softVolume') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let {
	      mass,
	      pressure
	    } = this.selected.userData.physics || {};
	    this.setState({
	      show: true,
	      mass: mass || 0,
	      pressure: pressure || 0
	    });
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      mass,
	      pressure
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let physics = this.selected.userData.physics;
	    physics.mass = mass;
	    physics.pressure = pressure;
	    app.call('objectChanged', this, this.selected);
	  }

	}

	/**
	 * 残影特效组件
	 * @author tengge / https://github.com/tengge1
	 */

	class AfterimageComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      damp: 0.92
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      damp
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('AfterimageEffect'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Damp'),
	      name: 'damp',
	      value: damp,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.AfterimageComponent`, this.handleUpdate);
	    app.on(`objectChanged.AfterimageComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.afterimage ? postProcessing.afterimage.enabled : false,
	      damp: postProcessing.afterimage ? postProcessing.afterimage.damp : this.state.damp
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      damp
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      afterimage: {
	        enabled,
	        damp
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 背景虚化特效组件
	 * @author tengge / https://github.com/tengge1
	 */

	class BokehComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      focus: 50,
	      // 距离相机距离，哪里最清晰
	      aperture: 2.8,
	      // *1e-4，光圈越小越清楚
	      maxBlur: 1 // 最大模糊程度，越大越模糊

	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      focus,
	      aperture,
	      maxBlur
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Bokeh Effect'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Focus'),
	      name: 'focus',
	      value: focus,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Aperture'),
	      name: 'aperture',
	      value: aperture,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('MaxBlur'),
	      name: 'maxBlur',
	      value: maxBlur,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.BokehComponent`, this.handleUpdate);
	    app.on(`objectChanged.BokehComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.bokeh ? postProcessing.bokeh.enabled : false,
	      focus: postProcessing.bokeh ? postProcessing.bokeh.focus : this.state.focus,
	      aperture: postProcessing.bokeh ? postProcessing.bokeh.aperture : this.state.aperture,
	      maxBlur: postProcessing.bokeh ? postProcessing.bokeh.maxBlur : this.state.maxBlur
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      focus,
	      aperture,
	      maxBlur
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      bokeh: {
	        enabled,
	        focus,
	        aperture,
	        maxBlur
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 点阵化组件
	 * @author tengge / https://github.com/tengge1
	 */

	class DotScreenComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      scale: 4.0
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      scale
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('DotScreenEffect'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Scale'),
	      name: 'scale',
	      value: scale,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.DotScreenComponent`, this.handleUpdate);
	    app.on(`objectChanged.DotScreenComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.dotScreen ? postProcessing.dotScreen.enabled : false,
	      scale: postProcessing.dotScreen ? postProcessing.dotScreen.scale : this.state.scale
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      scale
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      dotScreen: {
	        enabled,
	        scale
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 快速近似抗锯齿(FXAA)组件
	 * @author tengge / https://github.com/tengge1
	 */

	class FxaaComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('FXAA Component'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.FxaaComponent`, this.handleUpdate);
	    app.on(`objectChanged.FxaaComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.fxaa ? postProcessing.fxaa.enabled : false
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      fxaa: {
	        enabled
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 毛刺组件
	 * @author tengge / https://github.com/tengge1
	 */

	class GlitchComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      wild: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      wild
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Glitch Effect'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('WildMode'),
	      name: 'wild',
	      value: wild,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.GlitchComponent`, this.handleUpdate);
	    app.on(`objectChanged.GlitchComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.glitch ? postProcessing.glitch.enabled : false,
	      wild: postProcessing.glitch ? postProcessing.glitch.wild : false
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      wild
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      glitch: {
	        enabled,
	        wild
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 半色调特效组件
	 * @author tengge / https://github.com/tengge1
	 */

	class HalftoneComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.shape = {
	      1: _t('Point'),
	      2: _t('Ellipse'),
	      3: _t('Line'),
	      4: _t('Square')
	    };
	    this.blendingMode = {
	      1: _t('Linear'),
	      2: _t('Multiply'),
	      3: _t('Add'),
	      4: _t('Lighter'),
	      5: _t('Darker')
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      shape: 1,
	      radius: 4,
	      rotateR: 15,
	      rotateG: 45,
	      rotateB: 30,
	      scatter: 0,
	      blending: 1,
	      blendingMode: 1,
	      greyscale: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      shape,
	      radius,
	      rotateR,
	      rotateG,
	      rotateB,
	      scatter,
	      blending,
	      blendingMode,
	      greyscale
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Halftone Effect'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), React.createElement(SelectProperty, {
	      label: _t('Shape'),
	      options: this.shape,
	      name: 'shape',
	      value: shape,
	      onChange: this.handleChange
	    }), React.createElement(IntegerProperty, {
	      label: _t('Radius'),
	      name: 'radius',
	      value: radius,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('RotateRed'),
	      name: 'rotateR',
	      value: rotateR,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('RotateGreen'),
	      name: 'rotateG',
	      value: rotateG,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('RotateBlue'),
	      name: 'rotateB',
	      value: rotateB,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Scatter'),
	      name: 'scatter',
	      value: scatter,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Blending'),
	      name: 'blending',
	      value: blending,
	      onChange: this.handleChange
	    }), React.createElement(SelectProperty, {
	      label: _t('BlendingMode'),
	      options: this.blendingMode,
	      name: 'blendingMode',
	      value: blendingMode,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('GreyScale'),
	      name: 'greyscale',
	      value: greyscale,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.HalftoneComponent`, this.handleUpdate);
	    app.on(`objectChanged.HalftoneComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.halftone ? postProcessing.halftone.enabled : false,
	      shape: postProcessing.halftone ? postProcessing.halftone.shape : this.state.shape,
	      radius: postProcessing.halftone ? postProcessing.halftone.radius : this.state.radius,
	      rotateR: postProcessing.halftone ? postProcessing.halftone.rotateR : this.state.rotateR,
	      rotateB: postProcessing.halftone ? postProcessing.halftone.rotateB : this.state.rotateG,
	      rotateG: postProcessing.halftone ? postProcessing.halftone.rotateG : this.state.rotateB,
	      scatter: postProcessing.halftone ? postProcessing.halftone.scatter : this.state.scatter,
	      blending: postProcessing.halftone ? postProcessing.halftone.blending : this.state.blending,
	      blendingMode: postProcessing.halftone ? postProcessing.halftone.blendingMode : this.state.blendingMode,
	      greyscale: postProcessing.halftone ? postProcessing.halftone.greyscale : this.state.greyscale
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      shape,
	      radius,
	      rotateR,
	      rotateG,
	      rotateB,
	      scatter,
	      blending,
	      blendingMode,
	      greyscale
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      halftone: {
	        enabled,
	        shape,
	        radius,
	        rotateR,
	        rotateG,
	        rotateB,
	        scatter,
	        blending,
	        blendingMode,
	        greyscale
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 像素特效组件
	 * @author tengge / https://github.com/tengge1
	 */

	class PixelComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      pixelSize: 8
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      pixelSize
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('PixelEffect'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('PixelSize'),
	      name: 'pixelSize',
	      value: pixelSize,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.PixelComponent`, this.handleUpdate);
	    app.on(`objectChanged.PixelComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.pixel ? postProcessing.pixel.enabled : false,
	      pixelSize: postProcessing.pixel ? postProcessing.pixel.pixelSize : this.state.pixelSize
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      pixelSize
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      pixel: {
	        enabled,
	        pixelSize
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 颜色偏移组件
	 * @author tengge / https://github.com/tengge1
	 */

	class RgbShiftComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      amount: 0.1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      amount
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('RGB Shift Effect'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Amount'),
	      name: 'amount',
	      value: amount,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.RgbShiftComponent`, this.handleUpdate);
	    app.on(`objectChanged.RgbShiftComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.rgbShift ? postProcessing.rgbShift.enabled : false,
	      amount: postProcessing.rgbShift ? postProcessing.rgbShift.amount : this.state.amount
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      amount
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      rgbShift: {
	        enabled,
	        amount
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 可扩展环境光遮挡(SAO)组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SaoComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.output = {
	      1: _t('Beauty'),
	      // THREE.SAOPass.OUTPUT.Beauty
	      0: _t('Beauty&Occlusion'),
	      // THREE.SAOPass.OUTPUT.Default
	      2: _t('Occlusion'),
	      // THREE.SAOPass.OUTPUT.SAO
	      3: _t('Depth'),
	      // THREE.SAOPass.OUTPUT.Depth
	      4: _t('Normal') // THREE.SAOPass.OUTPUT.Normal

	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      output: 0,
	      saoBias: 0.5,
	      saoIntensity: 0.02,
	      saoScale: 100,
	      saoKernelRadius: 50,
	      saoMinResolution: 0,
	      saoBlur: true,
	      saoBlurRadius: 16,
	      saoBlurStdDev: 32.6,
	      saoBlurDepthCutoff: 0.046
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      output,
	      saoBias,
	      saoIntensity,
	      saoScale,
	      saoKernelRadius,
	      saoMinResolution,
	      saoBlur,
	      saoBlurRadius,
	      saoBlurStdDev,
	      saoBlurDepthCutoff
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('SAO'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), React.createElement(SelectProperty, {
	      label: _t('Output'),
	      options: this.output,
	      name: 'output',
	      value: output,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Bias'),
	      name: 'saoBias',
	      value: saoBias,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Intensity'),
	      name: 'saoIntensity',
	      value: saoIntensity,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('Scale'),
	      name: 'saoScale',
	      value: saoScale,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('KernalRadius'),
	      name: 'saoKernelRadius',
	      value: saoKernelRadius,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('MinResolution'),
	      name: 'saoMinResolution',
	      value: saoMinResolution,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('Blur'),
	      name: 'saoBlur',
	      value: saoBlur,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('BlurRadius'),
	      name: 'saoBlurRadius',
	      value: saoBlurRadius,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('BlurStdDev'),
	      name: 'saoBlurStdDev',
	      value: saoBlurStdDev,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('BlurDepthCutoff'),
	      name: 'saoBlurDepthCutoff',
	      value: saoBlurDepthCutoff,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SaoComponent`, this.handleUpdate);
	    app.on(`objectChanged.SaoComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.sao ? postProcessing.sao.enabled : false,
	      output: postProcessing.sao ? postProcessing.sao.output : this.state.output,
	      saoBias: postProcessing.sao ? postProcessing.sao.saoBias : this.state.saoBias,
	      saoIntensity: postProcessing.sao ? postProcessing.sao.saoIntensity : this.state.saoIntensity,
	      saoScale: postProcessing.sao ? postProcessing.sao.saoScale : this.state.saoScale,
	      saoKernelRadius: postProcessing.sao ? postProcessing.sao.saoKernelRadius : this.state.saoKernelRadius,
	      saoMinResolution: postProcessing.sao ? postProcessing.sao.saoMinResolution : this.state.saoMinResolution,
	      saoBlur: postProcessing.sao ? postProcessing.sao.saoBlur : this.state.saoBlur,
	      saoBlurRadius: postProcessing.sao ? postProcessing.sao.saoBlurRadius : this.state.saoBlurRadius,
	      saoBlurStdDev: postProcessing.sao ? postProcessing.sao.saoBlurStdDev : this.setState.saoBlurStdDev,
	      saoBlurDepthCutoff: postProcessing.sao ? postProcessing.sao.saoBlurDepthCutoff : this.state.saoBlurDepthCutoff
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      output,
	      saoBias,
	      saoIntensity,
	      saoScale,
	      saoKernelRadius,
	      saoMinResolution,
	      saoBlur,
	      saoBlurRadius,
	      saoBlurStdDev,
	      saoBlurDepthCutoff
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      sao: {
	        enabled,
	        output,
	        saoBias,
	        saoIntensity,
	        saoScale,
	        saoKernelRadius,
	        saoMinResolution,
	        saoBlur,
	        saoBlurRadius,
	        saoBlurStdDev,
	        saoBlurDepthCutoff
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 多重采样抗锯齿(SMAA)组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SmaaComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('SMAA'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SmaaComponent`, this.handleUpdate);
	    app.on(`objectChanged.SmaaComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.smaa ? postProcessing.smaa.enabled : false
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      smaa: {
	        enabled
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 全屏抗锯齿(SSAA)组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SsaaComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.sampleLevel = {
	      0: _t('1 Sample'),
	      1: _t('2 Samples'),
	      2: _t('4 Samples'),
	      3: _t('8 Samples'),
	      4: _t('16 Samples'),
	      5: _t('32 Samples')
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      sampleLevel: 3,
	      unbiased: true
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      sampleLevel,
	      unbiased
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('SSAA'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), React.createElement(SelectProperty, {
	      label: _t('Level'),
	      options: this.sampleLevel,
	      name: 'sampleLevel',
	      value: sampleLevel,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('Unbiased'),
	      name: 'unbiased',
	      value: unbiased,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SsaaComponent`, this.handleUpdate);
	    app.on(`objectChanged.SsaaComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.ssaa ? postProcessing.ssaa.enabled : false,
	      sampleLevel: postProcessing.ssaa ? postProcessing.ssaa.sampleLevel : this.state.sampleLevel,
	      unbiased: postProcessing.ssaa ? postProcessing.ssaa.unbiased : this.state.unbiased
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      sampleLevel,
	      unbiased
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      ssaa: {
	        enabled,
	        sampleLevel,
	        unbiased
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 屏幕空间环境光遮蔽(SSAO)组件
	 * @author tengge / https://github.com/tengge1
	 */

	class SsaoComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.output = {
	      0: _t('Default'),
	      // THREE.SSAOPass.OUTPUT.Default
	      1: _t('Occlusion'),
	      // THREE.SSAOPass.OUTPUT.SSAO
	      2: _t('Occlusion&Blur'),
	      // THREE.SSAOPass.OUTPUT.Blur
	      3: _t('Beauty'),
	      // THREE.SSAOPass.OUTPUT.Beauty
	      4: _t('Depth'),
	      // THREE.SSAOPass.OUTPUT.Depth
	      5: _t('Normal') // THREE.SSAOPass.OUTPUT.Normal

	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      output: 0,
	      kernelRadius: 10,
	      minDistance: 0.001,
	      maxDistance: 0.1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      output,
	      kernelRadius,
	      minDistance,
	      maxDistance
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('SSAO'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), React.createElement(SelectProperty, {
	      label: _t('Output'),
	      options: this.output,
	      name: 'output',
	      value: output,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('KernalRadius'),
	      name: 'kernelRadius',
	      value: kernelRadius,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('MinDistance'),
	      name: 'minDistance',
	      value: minDistance,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('MaxDistance'),
	      name: 'maxDistance',
	      value: maxDistance,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.SsaoComponent`, this.handleUpdate);
	    app.on(`objectChanged.SsaoComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.ssao ? postProcessing.ssao.enabled : false,
	      output: postProcessing.ssao ? postProcessing.ssao.output : this.state.output,
	      kernelRadius: postProcessing.ssao ? postProcessing.ssao.kernelRadius : this.state.kernelRadius,
	      minDistance: postProcessing.ssao ? postProcessing.ssao.minDistance : this.state.minDistance,
	      maxDistance: postProcessing.ssao ? postProcessing.ssao.maxDistance : this.state.maxDistance
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      output,
	      kernelRadius,
	      minDistance,
	      maxDistance
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      ssao: {
	        enabled,
	        output,
	        kernelRadius,
	        minDistance,
	        maxDistance
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 时间抗锯齿(TAA)组件
	 * @author tengge / https://github.com/tengge1
	 */

	class TaaComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.sampleLevel = {
	      0: _t('1 Sample'),
	      1: _t('2 Samples'),
	      2: _t('4 Samples'),
	      3: _t('8 Samples'),
	      4: _t('16 Samples'),
	      5: _t('32 Samples')
	    };
	    this.state = {
	      show: false,
	      expanded: false,
	      enabled: false,
	      sampleLevel: 3,
	      unbiased: true
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      enabled,
	      sampleLevel,
	      unbiased
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('TAA'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(CheckBoxProperty, {
	      label: _t('EnableState'),
	      name: 'enabled',
	      value: enabled,
	      onChange: this.handleChange
	    }), React.createElement(SelectProperty, {
	      label: _t('Level'),
	      options: this.sampleLevel,
	      name: 'sampleLevel',
	      value: sampleLevel,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('Unbiased'),
	      name: 'unbiased',
	      value: unbiased,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`objectSelected.TaaComponent`, this.handleUpdate);
	    app.on(`objectChanged.TaaComponent`, this.handleUpdate);
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate() {
	    const editor = app.editor;

	    if (!editor.selected || editor.selected !== editor.scene) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.selected = editor.selected;
	    let scene = this.selected;
	    let postProcessing = scene.userData.postProcessing || {};
	    let state = {
	      show: true,
	      enabled: postProcessing.taa ? postProcessing.taa.enabled : false,
	      sampleLevel: postProcessing.taa ? postProcessing.taa.sampleLevel : this.state.sampleLevel,
	      unbiased: postProcessing.taa ? postProcessing.taa.unbiased : this.state.unbiased
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      enabled,
	      sampleLevel,
	      unbiased
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    let scene = this.selected;
	    scene.userData.postProcessing = scene.userData.postProcessing || {};
	    Object.assign(scene.userData.postProcessing, {
	      taa: {
	        enabled,
	        sampleLevel,
	        unbiased
	      }
	    });
	    app.call(`objectChanged`, this, this.selected);
	    app.call(`postProcessingChanged`, this);
	  }

	}

	/**
	 * 属性面板
	 * @author tengge / https://github.com/tengge1
	 */

	class PropertyPanel extends React.Component {
	  constructor(props) {
	    super(props);
	  }

	  render() {
	    return React.createElement(PropertyGrid, null, React.createElement(BasicComponent, null), React.createElement(TransformComponent, null), React.createElement(SceneComponent, null), React.createElement(LightComponent, null), React.createElement(ShadowComponent, null), React.createElement(CameraComponent, null), React.createElement(AudioListenerComponent, null), React.createElement(BackgroundMusicComponent, null), React.createElement(ReflectorComponent, null), React.createElement(FireComponent, null), React.createElement(WaterComponent, null), React.createElement(SmokeComponent, null), React.createElement(LMeshComponent, null), React.createElement(ClothComponent, null), React.createElement(PerlinTerrainComponent, null), React.createElement(SkyComponent, null), React.createElement(ParticleEmitterComponent, null), React.createElement(MMDComponent, null), React.createElement(GisBasicComponent, null), React.createElement(CatmullRomCurveComponent, null), React.createElement(CubicBezierCurveComponent, null), React.createElement(EllipseCurveComponent, null), React.createElement(LineCurveComponent, null), React.createElement(QuadraticBezierCurveComponent, null), React.createElement(ControlComponent, null), React.createElement(FirstPersonControlComponent, null), React.createElement(FlyControlComponent, null), React.createElement(OrbitControlComponent, null), React.createElement(PointerLockControlComponent, null), React.createElement(TrackballControlComponent, null), React.createElement(PhysicsTypeComponent, null), React.createElement(PhysicsWorldComponent, null), React.createElement(RigidBodyComponent, null), React.createElement(SoftVolumeComponent, null), React.createElement(BoxGeometryComponent, null), React.createElement(CircleGeometryComponent, null), React.createElement(CylinderGeometryComponent, null), React.createElement(IcosahedronGeometryComponent, null), React.createElement(LatheGeometryComponent, null), React.createElement(PlaneGeometryComponent, null), React.createElement(SphereGeometryComponent, null), React.createElement(TeapotGeometryComponent, null), React.createElement(TorusGeometryComponent, null), React.createElement(TorusKnotGeometryComponent, null), React.createElement(MaterialComponent, null), React.createElement(AfterimageComponent, null), React.createElement(BokehComponent, null), React.createElement(DotScreenComponent, null), React.createElement(FxaaComponent, null), React.createElement(GlitchComponent, null), React.createElement(HalftoneComponent, null), React.createElement(PixelComponent, null), React.createElement(RgbShiftComponent, null), React.createElement(SaoComponent, null), React.createElement(SmaaComponent, null), React.createElement(SsaaComponent, null), React.createElement(SsaoComponent, null), React.createElement(TaaComponent, null));
	  }

	}

	/**
	 * 片源着色器起始代码
	 */
	function FragmentShaderStarter() {
	  return `
precision mediump float;

void main()	{
	gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}
`;
	}

	/**
	 * JavaScript起始代码
	 */
	function JavaScriptStarter() {
	  return `
// ${_t('Execute before scene render')}
function init() {

}

// ${_t('Execute after scene render')}
function start() {

}

// ${_t('Execute each frame during running')}
function update(clock, deltaTime) {

}

// ${_t('Execute after program stopped')}
function stop() {

}

// ${_t('Listen to click event')}
function onClick(event) {

}

// ${_t('Listen to dblclick event')}
function onDblClick(event) {

}

// ${_t('Listen to keydown event')}
function onKeyDown(event) {

}

// ${_t('Listen to keyup event')}
function onKeyUp(event) {

}

// ${_t('Listen to mousedown event')}
function onMouseDown(event) {

}

// ${_t('Listen to mousemove event')}
function onMouseMove(event) {

}

// ${_t('Listen to mouseup event')}
function onMouseUp(event) {

}

// ${_t('Listen to mousewheel event')}
function onMouseWheel(event) {

}

// ${_t('Listen to resize event')}
function onResize(event) {

}
`;
	}

	/**
	 * Json起始代码
	 */
	function JsonStarter() {
	  return `
{
    "defines": {

    },
    "uniforms": {

    },
    "attributes": {

    }
}
`;
	}

	/**
	 * 顶点着色器起始代码
	 */
	function VertexShaderStarter() {
	  return `
precision mediump float;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

attribute vec3 position;

void main()	{
	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;
	}

	/**
	 * 脚本窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class ScriptWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.scriptTypes = {
	      'javascript': 'JavaScript',
	      'vertexShader': _t('Vertex Shader'),
	      'fragmentShader': _t('Frag Shader'),
	      'json': _t('Shader Program Info')
	    };
	    this.state = {
	      name: _t('No Name'),
	      type: 'javascript'
	    };
	    this.handleNameChange = this.handleNameChange.bind(this);
	    this.handleTypeChange = this.handleTypeChange.bind(this);
	    this.handleOK = this.handleOK.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	    this.handleSaveScript = this.handleSaveScript.bind(this);
	  }

	  render() {
	    const {
	      name,
	      type
	    } = this.state;
	    return React.createElement(Window, {
	      className: 'ScriptWindow',
	      title: _t('Create Script'),
	      onClose: this.handleClose
	    }, React.createElement(Content, null, React.createElement(Form, null, React.createElement(FormControl, null, React.createElement(Label, null, _t('Name')), React.createElement(Input, {
	      value: name,
	      onChange: this.handleNameChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Type')), React.createElement(Select, {
	      options: this.scriptTypes,
	      value: type,
	      disabled: true,
	      onChange: this.handleTypeChange
	    })))), React.createElement(Buttons, null, React.createElement(Button, {
	      onClick: this.handleOK
	    }, _t('OK')), React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  handleNameChange(value) {
	    this.setState({
	      name: value
	    });
	  }

	  handleTypeChange(value) {
	    this.setState({
	      type: value
	    });
	  }

	  handleOK() {
	    const {
	      name,
	      type
	    } = this.state;
	    const uuid = THREE.Math.generateUUID();
	    let source = '';

	    switch (type) {
	      case 'javascript':
	        source = JavaScriptStarter();
	        break;

	      case 'vertexShader':
	        source = VertexShaderStarter();
	        break;

	      case 'fragmentShader':
	        source = FragmentShaderStarter();
	        break;

	      case 'json':
	        source = JsonStarter();
	        break;

	      default:
	        source = JavaScriptStarter();
	    }

	    app.editor.scripts[uuid] = {
	      id: null,
	      name,
	      type,
	      source,
	      uuid
	    };
	    app.call(`scriptChanged`, this);
	    this.handleClose();
	    this.setState({
	      show: false,
	      uuid: null,
	      name: '',
	      type: 'javascript',
	      source: ''
	    });
	    app.call(`editScript`, this, uuid, name, type, source, this.handleSaveScript);
	  }

	  handleSaveScript(uuid, name, type, source) {
	    app.editor.scripts[uuid] = {
	      id: null,
	      uuid,
	      name,
	      type,
	      source
	    };
	    app.call(`scriptChanged`, this);
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	/**
	 * 历史面板
	 * @author tengge / https://github.com/tengge1
	 */

	class ScriptPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      scripts: {}
	    };
	    this.handleAddScript = this.handleAddScript.bind(this);
	    this.handleEditScript = this.handleEditScript.bind(this);
	    this.handleSaveScript = this.handleSaveScript.bind(this);
	    this.handleRemoveScript = this.handleRemoveScript.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const scripts = this.state.scripts;
	    return React.createElement("div", {
	      className: 'ScriptPanel'
	    }, React.createElement("div", {
	      className: 'toolbar'
	    }, React.createElement(Button, {
	      onClick: this.handleAddScript
	    }, _t('New Script'))), React.createElement("ul", {
	      className: 'content'
	    }, Object.values(scripts).map(n => {
	      return React.createElement("li", {
	        key: n.uuid
	      }, React.createElement("span", null, `${n.name}.${this.getExtension(n.type)}`), React.createElement(Icon, {
	        name: n.uuid,
	        icon: 'edit',
	        title: _t('Edit Script'),
	        onClick: this.handleEditScript
	      }), React.createElement(Icon, {
	        name: n.uuid,
	        icon: 'delete',
	        title: _t('Delete Script'),
	        onClick: this.handleRemoveScript
	      }));
	    })));
	  }

	  getExtension(type) {
	    let extension = '';

	    switch (type) {
	      case 'javascript':
	        extension = 'js';
	        break;

	      case 'vertexShader':
	        extension = 'glsl';
	        break;

	      case 'fragmentShader':
	        extension = 'glsl';
	        break;

	      case 'json':
	        extension = 'json';
	        break;
	    }

	    return extension;
	  }

	  componentDidMount() {
	    app.on(`scriptChanged.ScriptPanel`, this.update);
	  }

	  update() {
	    this.setState({
	      scripts: app.editor.scripts
	    });
	  }

	  handleAddScript() {
	    const window = app.createElement(ScriptWindow);
	    app.addElement(window);
	  }

	  handleEditScript(uuid) {
	    var script = app.editor.scripts[uuid];

	    if (script) {
	      app.call(`editScript`, this, uuid, script.name, script.type, script.source, this.handleSaveScript);
	    }
	  }

	  handleSaveScript(uuid, name, type, source) {
	    app.editor.scripts[uuid] = {
	      id: null,
	      uuid,
	      name,
	      type,
	      source
	    };
	    app.call(`scriptChanged`, this);
	  }

	  handleRemoveScript(uuid) {
	    const script = app.editor.scripts[uuid];
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${script.name}.${this.getExtension(script.type)}？`,
	      onOK: () => {
	        delete app.editor.scripts[uuid];
	        app.call('scriptChanged', this);
	      }
	    });
	  }

	}

	/**
	 * 动画基本信息组件
	 * @author tengge / https://github.com/tengge1
	 */

	class BasicAnimationComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.animationType = {
	      Tween: _t('Tween Animation'),
	      Skeletal: _t('Skeletal Animation'),
	      Audio: _t('Play Audio'),
	      Filter: _t('Filter Animation'),
	      Particle: _t('Particle Animation')
	    };
	    this.state = {
	      show: false,
	      expanded: true,
	      name: '',
	      target: null,
	      type: null,
	      beginTime: 0,
	      endTime: 10
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleSetTarget = this.handleSetTarget.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      name,
	      target,
	      type,
	      beginTime,
	      endTime
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Basic Information'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(TextProperty, {
	      label: _t('Name'),
	      name: 'name',
	      value: name,
	      onChange: this.handleChange
	    }), React.createElement(DisplayProperty, {
	      label: _t('Target'),
	      name: 'target',
	      value: target ? target : `(${_t('None')})`,
	      btnText: _t('Set Target'),
	      btnShow: app.editor.selected != null,
	      onClick: this.handleSetTarget,
	      onChange: this.handleChange
	    }), React.createElement(SelectProperty, {
	      label: _t('Type'),
	      options: this.animationType,
	      name: 'type',
	      value: type,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('BeginTime'),
	      name: 'beginTime',
	      value: beginTime,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: _t('EndTime'),
	      name: 'endTime',
	      value: endTime,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`animationSelected.BasicAnimationComponent`, this.handleUpdate.bind(this));
	    app.on(`animationChanged.BasicAnimationComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate(animation) {
	    if (!animation) {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.animation = animation;
	    let state = {
	      show: true,
	      name: this.animation.name,
	      type: this.animation.type,
	      beginTime: this.animation.beginTime,
	      endTime: this.animation.endTime
	    };

	    if (!this.animation.target) {
	      state.target = null;
	    } else {
	      let obj = app.editor.objectByUuid(this.animation.target);

	      if (obj === null) {
	        state.target = null;
	        console.warn(`BasicAnimationComponent: ${_t('Animation Object')} ${this.animation.target} ${_t('is not existed in the scene.')}`);
	      } else {
	        state.target = obj.name;
	      }
	    }

	    this.setState(state);
	  }

	  handleSetTarget() {
	    let selected = app.editor.selected;

	    if (selected == null) {
	      this.animation.target = null;
	    } else {
	      this.animation.target = selected.uuid;
	    }

	    app.call('animationChanged', this, this.animation);
	  }

	  handleChange(value, animName) {
	    if (value === null) {
	      this.setState({
	        [animName]: value
	      });
	      return;
	    }

	    const {
	      name,
	      type,
	      beginTime,
	      endTime
	    } = Object.assign({}, this.state, {
	      [animName]: value
	    });
	    this.animation.name = name;
	    this.animation.type = type;
	    this.animation.beginTime = beginTime;
	    this.animation.endTime = endTime;
	    app.call('animationChanged', this, this.animation);
	  }

	}

	/**
	 * 补间动画组件
	 * @author tengge / https://github.com/tengge1
	 */

	class TweenAnimationComponent extends React.Component {
	  constructor(props) {
	    super(props);
	    this.selected = null;
	    this.beginStatus = {
	      Current: _t('Current Status'),
	      Custom: _t('Custom Status')
	    };
	    this.ease = {
	      linear: 'Linear',
	      quadIn: 'Quad In',
	      quadOut: 'Quad Out',
	      quadInOut: 'Quad In Out',
	      cubicIn: 'Cubic In',
	      cubicOut: 'Cubic Out',
	      cubicInOut: 'Cubic InOut',
	      quartIn: 'Quart In',
	      quartOut: 'Quart Out',
	      quartInOut: 'Quart InOut',
	      quintIn: 'Quint In',
	      quintOut: 'Quint Out',
	      quintInOut: 'Quint In Out',
	      sineIn: 'Sine In',
	      sineOut: 'Sine Out',
	      sineInOut: 'Sine In Out',
	      backIn: 'Back In',
	      backOut: 'Back Out',
	      backInOut: 'Back In Out',
	      circIn: 'Circ In',
	      circOut: 'Circ Out',
	      circInOut: 'Circ In Out',
	      bounceIn: 'Bounce In',
	      bounceOut: 'Bounce Out',
	      bounceInOut: 'Bounce In Out',
	      elasticIn: 'Elastic In',
	      elasticOut: 'Elastic Out',
	      elasticInOut: 'Elastic In Out'
	    };
	    this.state = {
	      show: false,
	      expanded: true,
	      beginStatus: 'Custom',
	      showBeginState: false,
	      beginPositionX: 0,
	      beginPositionY: 0,
	      beginPositionZ: 0,
	      beginRotationX: 0,
	      beginRotationY: 0,
	      beginRotationZ: 0,
	      beginScaleLock: true,
	      beginScaleX: 1,
	      beginScaleY: 1,
	      beginScaleZ: 1,
	      ease: 'Linear',
	      endStatus: 'Custom',
	      showEndState: false,
	      endPositionX: 0,
	      endPositionY: 0,
	      endPositionZ: 0,
	      endRotationX: 0,
	      endRotationY: 0,
	      endRotationZ: 0,
	      endScaleLock: true,
	      endScaleX: 1,
	      endScaleY: 1,
	      endScaleZ: 1
	    };
	    this.handleExpand = this.handleExpand.bind(this);
	    this.handleUpdate = this.handleUpdate.bind(this);
	    this.handleChange = this.handleChange.bind(this);
	  }

	  render() {
	    const {
	      show,
	      expanded,
	      beginStatus,
	      showBeginState,
	      beginPositionX,
	      beginPositionY,
	      beginPositionZ,
	      beginRotationX,
	      beginRotationY,
	      beginRotationZ,
	      beginScaleLock,
	      beginScaleX,
	      beginScaleY,
	      beginScaleZ,
	      ease,
	      endStatus,
	      showEndState,
	      endPositionX,
	      endPositionY,
	      endPositionZ,
	      endRotationX,
	      endRotationY,
	      endRotationZ,
	      endScaleLock,
	      endScaleX,
	      endScaleY,
	      endScaleZ
	    } = this.state;

	    if (!show) {
	      return null;
	    }

	    return React.createElement(PropertyGroup, {
	      title: _t('Tween Animation'),
	      show: show,
	      expanded: expanded,
	      onExpand: this.handleExpand
	    }, React.createElement(SelectProperty, {
	      label: _t('Begin Status'),
	      options: this.beginStatus,
	      name: 'beginStatus',
	      value: beginStatus,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Begin Position')} X`,
	      name: 'beginPositionX',
	      value: beginPositionX,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Begin Position')} Y`,
	      name: 'beginPositionY',
	      value: beginPositionY,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Begin Position')} Z`,
	      name: 'beginPositionZ',
	      value: beginPositionZ,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Begin Rotation')} X`,
	      name: 'beginRotationX',
	      value: beginRotationX,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Begin Rotation')} Y`,
	      name: 'beginRotationY',
	      value: beginRotationY,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Begin Rotation')} Z`,
	      name: 'beginRotationZ',
	      value: beginRotationZ,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('Begin Scale Lock'),
	      name: 'beginScaleLock',
	      value: beginScaleLock,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Begin Scale')} X`,
	      name: 'beginScaleX',
	      value: beginScaleX,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Begin Scale')} Y`,
	      name: 'beginScaleY',
	      value: beginScaleY,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('Begin Scale')} Z`,
	      name: 'beginScaleZ',
	      value: beginScaleZ,
	      show: showBeginState,
	      onChange: this.handleChange
	    }), React.createElement(SelectProperty, {
	      label: _t('Ease Func'),
	      options: this.ease,
	      name: 'ease',
	      value: ease,
	      onChange: this.handleChange
	    }), React.createElement(SelectProperty, {
	      label: _t('End Status'),
	      options: this.beginStatus,
	      name: 'endStatus',
	      value: endStatus,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('End Position')} X`,
	      name: 'endPositionX',
	      value: endPositionX,
	      show: showEndState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('End Position')} Y`,
	      name: 'endPositionY',
	      value: endPositionY,
	      show: showEndState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('End Position')} Z`,
	      name: 'endPositionZ',
	      value: endPositionZ,
	      show: showEndState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('End Rotation')} X`,
	      name: 'endRotationX',
	      value: endRotationX,
	      show: showEndState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('End Rotation')} Y`,
	      name: 'endRotationY',
	      value: endRotationY,
	      show: showEndState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('End Rotation')} Z`,
	      name: 'endRotationZ',
	      value: endRotationZ,
	      show: showEndState,
	      onChange: this.handleChange
	    }), React.createElement(CheckBoxProperty, {
	      label: _t('End Scale Lock'),
	      name: 'endScaleLock',
	      value: endScaleLock,
	      show: showEndState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('End Scale')} X`,
	      name: 'endScaleX',
	      value: endScaleX,
	      show: showEndState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('End Scale')} Y`,
	      name: 'endScaleY',
	      value: endScaleY,
	      show: showEndState,
	      onChange: this.handleChange
	    }), React.createElement(NumberProperty, {
	      label: `${_t('End Scale')} Z`,
	      name: 'endScaleZ',
	      value: endScaleZ,
	      show: showEndState,
	      onChange: this.handleChange
	    }));
	  }

	  componentDidMount() {
	    app.on(`animationSelected.TweenAnimationComponent`, this.handleUpdate.bind(this));
	    app.on(`animationChanged.TweenAnimationComponent`, this.handleUpdate.bind(this));
	  }

	  handleExpand(expanded) {
	    this.setState({
	      expanded
	    });
	  }

	  handleUpdate(animation) {
	    if (!animation || animation.type !== 'Tween') {
	      this.setState({
	        show: false
	      });
	      return;
	    }

	    this.animation = animation;
	    let data = this.animation.data;
	    let state = {
	      show: true,
	      beginStatus: data.beginStatus,
	      showBeginState: data.beginStatus === 'Custom',
	      beginPositionX: data.beginPositionX,
	      beginPositionY: data.beginPositionY,
	      beginPositionZ: data.beginPositionZ,
	      beginRotationX: data.beginRotationX * 180 / Math.PI,
	      beginRotationY: data.beginRotationY * 180 / Math.PI,
	      beginRotationZ: data.beginRotationZ * 180 / Math.PI,
	      beginScaleLock: data.beginScaleLock,
	      beginScaleX: data.beginScaleX,
	      beginScaleY: data.beginScaleY,
	      beginScaleZ: data.beginScaleZ,
	      ease: data.ease,
	      endStatus: data.endStatus,
	      showEndState: data.endStatus === 'Custom',
	      endPositionX: data.endPositionX,
	      endPositionY: data.endPositionY,
	      endPositionZ: data.endPositionZ,
	      endRotationX: data.endRotationX * 180 / Math.PI,
	      endRotationY: data.endRotationY * 180 / Math.PI,
	      endRotationZ: data.endRotationZ * 180 / Math.PI,
	      endScaleLock: data.endScaleLock,
	      endScaleX: data.endScaleX,
	      endScaleY: data.endScaleY,
	      endScaleZ: data.endScaleZ
	    };
	    this.setState(state);
	  }

	  handleChange(value, name) {
	    if (value === null) {
	      this.setState({
	        [name]: value
	      });
	      return;
	    }

	    const {
	      beginStatus,
	      showBeginState,
	      beginPositionX,
	      beginPositionY,
	      beginPositionZ,
	      beginRotationX,
	      beginRotationY,
	      beginRotationZ,
	      beginScaleLock,
	      beginScaleX,
	      beginScaleY,
	      beginScaleZ,
	      ease,
	      endStatus,
	      showEndState,
	      endPositionX,
	      endPositionY,
	      endPositionZ,
	      endRotationX,
	      endRotationY,
	      endRotationZ,
	      endScaleLock,
	      endScaleX,
	      endScaleY,
	      endScaleZ
	    } = Object.assign({}, this.state, {
	      [name]: value
	    });
	    this.animation.data = this.animation.data || {};
	    this.animation.data.beginStatus = beginStatus;
	    this.animation.data.beginPositionX = beginPositionX;
	    this.animation.data.beginPositionY = beginPositionY;
	    this.animation.data.beginPositionZ = beginPositionZ;
	    this.animation.data.beginRotationX = beginRotationX * Math.PI / 180;
	    this.animation.data.beginRotationY = beginRotationY * Math.PI / 180;
	    this.animation.data.beginRotationZ = beginRotationZ * Math.PI / 180;
	    this.animation.data.beginScaleLock = beginScaleLock;
	    this.animation.data.beginScaleX = beginScaleX;
	    this.animation.data.beginScaleY = beginScaleY;
	    this.animation.data.beginScaleZ = beginScaleZ;
	    this.animation.data.ease = ease;
	    this.animation.data.endStatus = endStatus;
	    this.animation.data.endPositionX = endPositionX;
	    this.animation.data.endPositionY = endPositionY;
	    this.animation.data.endPositionZ = endPositionZ;
	    this.animation.data.endRotationX = endRotationX * Math.PI / 180;
	    this.animation.data.endRotationY = endRotationY * Math.PI / 180;
	    this.animation.data.endRotationZ = endRotationZ * Math.PI / 180;
	    this.animation.data.endScaleLock = endScaleLock;
	    this.animation.data.endScaleX = endScaleX;
	    this.animation.data.endScaleY = endScaleY;
	    this.animation.data.endScaleZ = endScaleZ;
	    app.call('animationChanged', this, this.animation);
	  }

	}

	/**
	 * 动画属性面板
	 * @author tengge / https://github.com/tengge1
	 */

	class AnimationPropertyPanel extends React.Component {
	  constructor(props) {
	    super(props);
	  }

	  render() {
	    return React.createElement(PropertyGrid, null, React.createElement(BasicAnimationComponent, null), React.createElement(TweenAnimationComponent, null));
	  }

	}

	/**
	 * 侧边栏
	 * @author tengge / https://github.com/tengge1
	 */

	class EditorSideBar extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      topIndex: 0,
	      bottomIndex: 0
	    };
	    this.handleTopTabChange = this.handleTopTabChange.bind(this);
	    this.handleBottomTabChange = this.handleBottomTabChange.bind(this);
	    this.handleAnimationSelected = this.handleAnimationSelected.bind(this);
	  }

	  render() {
	    const {
	      topIndex,
	      bottomIndex
	    } = this.state;
	    return React.createElement(VBoxLayout, {
	      className: 'EditorSideBar'
	    }, React.createElement(TabLayout, {
	      className: 'top',
	      activeTabIndex: topIndex,
	      onActiveTabChange: this.handleTopTabChange
	    }, React.createElement(HierarchyPanel, {
	      title: _t('Hierachy')
	    }), React.createElement(HistoryPanel, {
	      title: _t('History')
	    })), React.createElement(TabLayout, {
	      className: 'bottom',
	      activeTabIndex: bottomIndex,
	      onActiveTabChange: this.handleBottomTabChange
	    }, React.createElement(PropertyPanel, {
	      title: _t('Property')
	    }), React.createElement(ScriptPanel, {
	      title: _t('Script')
	    }), React.createElement(AnimationPropertyPanel, {
	      title: _t('Animation')
	    })));
	  }

	  componentDidMount() {
	    app.on(`animationSelected.EditorSideBar`, this.handleAnimationSelected);
	  }

	  handleTopTabChange(index) {
	    this.setState({
	      topIndex: index
	    });
	  }

	  handleBottomTabChange(index) {
	    this.setState({
	      bottomIndex: index
	    });
	  }

	  handleAnimationSelected() {
	    this.setState({
	      bottomIndex: 2
	    });
	  }

	}

	/**
	 * 类别编辑窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class CategoryEditWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      name: props.name
	    };
	    this.handleOK = this.handleOK.bind(this, props.callback);
	    this.handleNameChange = this.handleNameChange.bind(this);
	    this.handleCancel = this.handleCancel.bind(this);
	  }

	  render() {
	    const {
	      typeName,
	      id
	    } = this.props;
	    const {
	      name
	    } = this.state;
	    return React.createElement(Window, {
	      className: 'CategoryEditWindow',
	      title: id ? `${typeName} ${_t('Category Edit')}` : `${typeName} ${_t('Category Add')}`,
	      style: {
	        width: '380px',
	        height: '200px'
	      },
	      mask: false,
	      onClose: this.handleCancel
	    }, React.createElement(Content, null, React.createElement(Form, null, React.createElement(FormControl, null, React.createElement(Label, null, _t('Name')), React.createElement(Input, {
	      value: name,
	      onChange: this.handleNameChange
	    })))), React.createElement(Buttons, null, React.createElement(Button, {
	      onClick: this.handleOK
	    }, _t('OK')), React.createElement(Button, {
	      onClick: this.handleCancel
	    }, _t('Cancel'))));
	  }

	  handleNameChange(value) {
	    this.setState({
	      name: value
	    });
	  }

	  handleOK(callback) {
	    const {
	      id,
	      type
	    } = this.props;
	    const {
	      name
	    } = this.state;
	    let body = `type=${type}&name=${name}`;

	    if (id) {
	      body += `&id=${id}`;
	    }

	    fetch(`${app.options.server}/api/Category/Save`, {
	      method: 'POST',
	      headers: {
	        'Content-Type': 'application/x-www-form-urlencoded'
	      },
	      body
	    }).then(response => {
	      response.json().then(json => {
	        if (json.Code === 200) {
	          this.handleCancel();
	          callback && callback();
	        } else {
	          app.toast(_t(json.Msg));
	        }
	      });
	    });
	  }

	  handleCancel() {
	    app.removeElement(this);
	  }

	}

	CategoryEditWindow.propTypes = {
	  type: propTypes.string,
	  typeName: propTypes.string,
	  id: propTypes.string,
	  name: propTypes.string,
	  callback: propTypes.func
	};
	CategoryEditWindow.defaultProps = {
	  type: 'Scene',
	  typeName: 'Scene',
	  id: null,
	  name: '',
	  callback: null
	};

	/**
	 * 类别窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class CategoryWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      selected: null
	    };
	    this.updateUI = this.updateUI.bind(this);
	    this.handleAdd = this.handleAdd.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.handleSelect = this.handleSelect.bind(this);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      type,
	      typeName
	    } = this.props;
	    const {
	      data,
	      selected
	    } = this.state;
	    return React.createElement(Window, {
	      className: 'CategoryWindow',
	      title: `${typeName} ${_t('Category Edit')}`,
	      style: {
	        width: '280px',
	        height: '400px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, React.createElement(Content, null, React.createElement(VBoxLayout, {
	      className: 'box'
	    }, React.createElement(Toolbar, {
	      className: 'toolbar'
	    }, React.createElement(Button, {
	      onClick: this.handleAdd
	    }, _t('Create')), React.createElement(Button, {
	      onClick: this.handleEdit
	    }, _t('Edit')), React.createElement(Button, {
	      onClick: this.handleDelete
	    }, _t('Delete'))), React.createElement(DataGrid, {
	      className: 'list',
	      data: data,
	      selected: selected ? selected.ID : null,
	      onSelect: this.handleSelect
	    }, React.createElement(Columns, null, React.createElement(Column, {
	      type: 'number',
	      title: _t('#')
	    }), React.createElement(Column, {
	      field: 'Name',
	      title: _t('Name')
	    }))))), React.createElement(Buttons, null, React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Close'))));
	  }

	  componentDidMount() {
	    this.updateUI();
	  }

	  updateUI() {
	    Ajax.getJson(`${app.options.server}/api/Category/List?Type=${this.props.type}`, json => {
	      this.setState({
	        data: json.Data.map(n => {
	          return {
	            id: n.ID,
	            ID: n.ID,
	            Name: n.Name
	          };
	        })
	      });
	    });
	  }

	  handleAdd() {
	    const {
	      type,
	      typeName
	    } = this.props;
	    let window = app.createElement(CategoryEditWindow, {
	      type,
	      typeName,
	      id: null,
	      name: '',
	      callback: this.updateUI
	    });
	    app.addElement(window);
	  }

	  handleEdit() {
	    const {
	      type,
	      typeName
	    } = this.props;
	    const {
	      selected
	    } = this.state;

	    if (!selected) {
	      app.toast(_t('Please select a record.'));
	      return;
	    }

	    let window = app.createElement(CategoryEditWindow, {
	      type,
	      typeName,
	      id: selected.ID,
	      name: selected.Name,
	      callback: this.updateUI
	    });
	    app.addElement(window);
	  }

	  handleDelete() {
	    const {
	      selected
	    } = this.state;

	    if (!selected) {
	      app.toast(_t('Please select a record.'));
	      return;
	    }

	    app.confirm({
	      title: _t('Query'),
	      content: _t('Delete this category?'),
	      onOK: () => {
	        fetch(`${app.options.server}/api/Category/Delete?ID=${selected.ID}`, {
	          method: 'POST',
	          headers: {
	            'Content-Type': 'application/x-www-form-urlencoded'
	          }
	        }).then(response => {
	          response.json().then(json => {
	            if (json.Code === 200) {
	              this.updateUI();
	            } else {
	              app.toast(_t(json.Msg));
	            }
	          });
	        });
	      }
	    });
	  }

	  handleSelect(obj) {
	    this.setState({
	      selected: obj
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	CategoryWindow.propTypes = {
	  type: propTypes.oneOf(['Scene', 'Mesh', 'Map', 'Texture', 'Material', 'Audio', 'Particle', 'Screenshot', 'Video']),
	  typeName: propTypes.string,
	  callback: propTypes.func
	};
	CategoryWindow.defaultProps = {
	  type: 'Scene',
	  typeName: 'Scene',
	  callback: null
	};

	/**
	 * 编辑窗口
	 * @author tengge / https://github.com/tengge1
	 */

	class EditWindow extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      name: props.data.Name,
	      categories: null,
	      categoryID: props.data.CategoryID,
	      thumbnail: props.data.Thumbnail
	    };
	    this.updateUI = this.updateUI.bind(this);
	    this.handleNameChange = this.handleNameChange.bind(this);
	    this.handleCategoryChange = this.handleCategoryChange.bind(this);
	    this.handleThumbnailChange = this.handleThumbnailChange.bind(this);
	    this.handleEditCategoryList = this.handleEditCategoryList.bind(this);
	    this.handleSave = this.handleSave.bind(this, props.callback);
	    this.handleClose = this.handleClose.bind(this);
	  }

	  render() {
	    const {
	      typeName
	    } = this.props;
	    const {
	      name,
	      categories,
	      categoryID,
	      thumbnail
	    } = this.state;
	    return React.createElement(Window, {
	      className: 'EditWindow',
	      title: `${_t('Edit')} ${typeName}`,
	      style: {
	        width: '320px',
	        height: '300px'
	      },
	      mask: false,
	      onClose: this.handleClose
	    }, React.createElement(Content, null, React.createElement(Form, null, React.createElement(FormControl, null, React.createElement(Label, null, _t('Name')), React.createElement(Input, {
	      name: 'name',
	      value: name,
	      onChange: this.handleNameChange
	    })), React.createElement(FormControl, null, React.createElement(Label, null, _t('Type')), React.createElement(Select, {
	      name: 'select',
	      options: categories,
	      value: categoryID,
	      onChange: this.handleCategoryChange
	    }), React.createElement(Button, {
	      onClick: this.handleEditCategoryList
	    }, _t('Edit'))), React.createElement(FormControl, null, React.createElement(Label, null, _t('Thumbnail')), React.createElement(ImageUploader, {
	      server: app.options.server,
	      url: thumbnail,
	      noImageText: _t('No Image'),
	      onChange: this.handleThumbnailChange
	    })))), React.createElement(Buttons, null, React.createElement(Button, {
	      onClick: this.handleSave
	    }, _t('OK')), React.createElement(Button, {
	      onClick: this.handleClose
	    }, _t('Cancel'))));
	  }

	  componentDidMount() {
	    this.updateUI();
	  }

	  updateUI() {
	    Ajax.getJson(`${app.options.server}/api/Category/List?Type=${this.props.type}`, json => {
	      var options = {
	        '': _t('Not Set')
	      };
	      json.Data.forEach(n => {
	        options[n.ID] = n.Name;
	      });
	      this.setState({
	        categories: options
	      });
	    });
	  }

	  handleNameChange(value) {
	    this.setState({
	      name: value
	    });
	  }

	  handleCategoryChange(value) {
	    this.setState({
	      categoryID: value
	    });
	  }

	  handleThumbnailChange(file) {
	    Ajax.post(`${app.options.server}/api/Upload/Upload`, {
	      file
	    }, json => {
	      var obj = JSON.parse(json);

	      if (obj.Code === 200) {
	        this.setState({
	          thumbnail: obj.Data.url
	        });
	      } else {
	        app.toast(_t(obj.Msg));
	      }
	    });
	  }

	  handleEditCategoryList() {
	    const window = app.createElement(CategoryWindow, {
	      type: this.props.type,
	      typeName: `${this.props.typeName}`
	    });
	    app.addElement(window);
	  }

	  handleSave() {
	    const {
	      data,
	      saveUrl,
	      callback
	    } = this.props;
	    const {
	      name,
	      categoryID,
	      thumbnail
	    } = this.state;
	    Ajax.post(saveUrl, {
	      ID: data.ID,
	      Name: name,
	      Category: categoryID,
	      Image: thumbnail
	    }, json => {
	      var obj = JSON.parse(json);

	      if (obj.Code === 200) {
	        callback && callback(obj);
	        this.handleClose();
	      } else {
	        app.toast(_t(obj.Msg));
	      }
	    });
	  }

	  handleClose() {
	    app.removeElement(this);
	  }

	}

	EditWindow.propTypes = {
	  type: propTypes.oneOf(['Scene', 'Mesh', 'Map', 'Texture', 'Material', 'Audio', 'Particle', 'Screenshot', 'Video']),
	  typeName: propTypes.string,
	  data: propTypes.object,
	  saveUrl: propTypes.string,
	  callback: propTypes.func
	};
	EditWindow.defaultProps = {
	  type: 'Scene',
	  typeName: 'Scene',
	  data: null,
	  saveUrl: null,
	  callback: null
	};

	/**
	 * 场景面板
	 * @author tengge / https://github.com/tengge1
	 */

	class ScenePanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'scenes',
	        cornerText: `v${n.Version}`
	      });
	    });
	    return React.createElement("div", {
	      className: bind('ScenePanel', className),
	      style: style
	    }, React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      addHidden: true,
	      onInput: this.handleSearch.bind(this)
	    }), React.createElement(ImageList, {
	      data: imageListData,
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate(prevProps, prevState) {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	      app.on(`sceneSaved.ScenePanel`, this.update);
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?type=Scene`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Scene/List`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories, event) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    var editor = app.editor;
	    document.title = data.Name;
	    app.mask(_t('Loading...'));
	    let url = `${app.options.server}/api/Scene/Load?ID=${data.id}`; // 下面代码演示使用，请勿删除

	    if (app.options.server === '.') {
	      url = `${app.options.server}/api/Scene/Scene_${data.id}`;
	    }

	    fetch(url).then(response => {
	      response.json().then(obj => {
	        editor.clear(false);
	        new Converter().fromJson(obj.Data, {
	          server: app.options.server,
	          camera: app.editor.camera
	        }).then(obj => {
	          this.onLoadScene(obj);
	          editor.sceneID = data.id;
	          editor.sceneName = data.title;
	          document.title = data.title;

	          if (obj.options) {
	            app.call('optionsChanged', this);

	            if (obj.options.sceneType === 'GIS') {
	              if (app.editor.gis) {
	                app.editor.gis.stop();
	              }

	              app.editor.gis = new Scene(app, {
	                useCameraPosition: true
	              });
	              app.editor.gis.start();
	            }
	          }

	          if (obj.scripts) {
	            app.call('scriptChanged', this);
	          }

	          if (obj.scene) {
	            app.call('sceneGraphChanged', this);
	          }

	          app.unmask();
	        });
	      });
	    });
	  }

	  onLoadScene(obj) {
	    if (obj.options) {
	      Object.assign(app.options, obj.options);
	    }

	    if (obj.camera) {
	      app.editor.camera.remove(app.editor.audioListener);
	      app.editor.camera.copy(obj.camera);
	      let audioListener = app.editor.camera.children.filter(n => n instanceof THREE.AudioListener)[0];

	      if (audioListener) {
	        app.editor.audioListener = audioListener;
	      }
	    }

	    if (obj.renderer) {
	      var viewport = app.viewport;
	      var oldRenderer = app.editor.renderer;
	      viewport.removeChild(oldRenderer.domElement);
	      viewport.appendChild(obj.renderer.domElement);
	      app.editor.renderer = obj.renderer;
	      app.editor.renderer.setSize(viewport.offsetWidth, viewport.offsetHeight);
	      app.call('resize', this);
	    }

	    if (obj.scripts) {
	      Object.assign(app.editor.scripts, obj.scripts);
	    }

	    if (obj.animations) {
	      Object.assign(app.editor.animations, obj.animations);
	    } else {
	      app.editor.animations = [{
	        id: null,
	        uuid: THREE.Math.generateUUID(),
	        layer: 0,
	        layerName: _t('AnimLayer1'),
	        animations: []
	      }, {
	        id: null,
	        uuid: THREE.Math.generateUUID(),
	        layer: 1,
	        layerName: _t('AnimLayer2'),
	        animations: []
	      }, {
	        id: null,
	        uuid: THREE.Math.generateUUID(),
	        layer: 2,
	        layerName: _t('AnimLayer3'),
	        animations: []
	      }];
	    }

	    if (obj.scene) {
	      app.editor.setScene(obj.scene);
	    }

	    app.editor.camera.updateProjectionMatrix();

	    if (obj.options.selected) {
	      var selected = app.editor.objectByUuid(obj.options.selected);

	      if (selected) {
	        app.editor.select(selected);
	      }
	    } // 可视化
	    // if (obj.visual) {
	    //     app.editor.visual.fromJSON(obj.visual);
	    // } else {
	    // app.editor.visual.clear();
	    // }
	    // app.editor.visual.render(app.editor.svg);


	    app.call('sceneLoaded', this);
	    app.call('animationChanged', this);
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    const window = app.createElement(EditWindow, {
	      type: 'Scene',
	      typeName: _t('Scene'),
	      data,
	      saveUrl: `${app.options.server}/api/Scene/Edit`,
	      callback: this.update
	    });
	    app.addElement(window);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Scene/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code === 200) {
	              this.update();
	            }

	            app.toast(_t(obj.Msg));
	          });
	        });
	      }
	    });
	  }

	}

	ScenePanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	ScenePanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 文件上传器
	 * @author tengge / https://github.com/tengge1
	 */

	/**
	 * 模型面板
	 * @author tengge / https://github.com/tengge1
	 */

	class ModelPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleAdd = this.handleAdd.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'model',
	        cornerText: n.Type
	      });
	    });
	    return React.createElement("div", {
	      className: bind('ModelPanel', className),
	      style: style
	    }, React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      onAdd: this.handleAdd,
	      onInput: this.handleSearch.bind(this)
	    }), React.createElement(ImageList, {
	      data: imageListData,
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate(prevProps, prevState) {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?type=Mesh`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Mesh/List`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories, event) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(model) {
	    let loader = new ModelLoader(app);
	    let url = model.Url;

	    if (model.Url.indexOf(';') > -1) {
	      // 包含多个入口文件
	      url = url.split(';').map(n => app.options.server + n);
	    } else {
	      url = app.options.server + model.Url;
	    }

	    loader.load(url, model, {
	      camera: app.editor.camera,
	      renderer: app.editor.renderer,
	      audioListener: app.editor.audioListener
	    }).then(obj => {
	      if (!obj) {
	        return;
	      }

	      obj.name = model.Name;
	      Object.assign(obj.userData, model, {
	        Server: true
	      });
	      var cmd = new AddObjectCommand(obj);
	      cmd.execute();

	      if (obj.userData.scripts) {
	        obj.userData.scripts.forEach(n => {
	          app.editor.scripts[n.uuid] = n;
	        });
	        app.call('scriptChanged', this);
	      }
	    });
	  } // ------------------------------- 上传 ---------------------------------------


	  handleAdd() {
	    app.upload(`${app.options.server}/api/Mesh/Add`, obj => {
	      if (obj.Code === 200) {
	        this.update();
	      }

	      app.toast(_t(obj.Msg));
	    });
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Mesh',
	      typeName: _t('Model'),
	      data,
	      saveUrl: `${app.options.server}/api/Mesh/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Mesh/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code === 200) {
	              this.update();
	            }

	            app.toast(_t(obj.Msg));
	          });
	        });
	      }
	    });
	  }

	}

	ModelPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	ModelPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 贴图面板
	 * @author tengge / https://github.com/tengge1
	 */

	class MapPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleAdd = this.handleAdd.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'scenes'
	      });
	    });
	    return React.createElement("div", {
	      className: bind('MapPanel', className),
	      style: style
	    }, React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      onAdd: this.handleAdd,
	      onInput: this.handleSearch.bind(this)
	    }), React.createElement(ImageList, {
	      data: imageListData,
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate(prevProps, prevState) {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?type=Map`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Map/List`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories, event) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    app.call(`selectMap`, this, data);
	  } // ------------------------------- 上传 ---------------------------------------


	  handleAdd() {
	    app.upload(`${app.options.server}/api/Map/Add`, obj => {
	      if (obj.Code === 200) {
	        this.update();
	      }

	      app.toast(_t(obj.Msg));
	    });
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Map',
	      typeName: _t('Map'),
	      data,
	      saveUrl: `${app.options.server}/api/Map/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Map/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code === 200) {
	              this.update();
	            }

	            app.toast(_t(obj.Msg));
	          });
	        });
	      }
	    });
	  }

	}

	MapPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	MapPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 材质面板
	 * @author tengge / https://github.com/tengge1
	 */

	class MaterialPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'model',
	        cornerText: n.Type
	      });
	    });
	    return React.createElement("div", {
	      className: bind('MaterialPanel', className),
	      style: style
	    }, React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      addHidden: true,
	      onInput: this.handleSearch.bind(this)
	    }), React.createElement(ImageList, {
	      data: imageListData,
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate(prevProps, prevState) {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?type=Material`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Material/List`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories, event) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    Ajax.get(`${app.options.server}/api/Material/Get?ID=${data.ID}`, result => {
	      var obj = JSON.parse(result);

	      if (obj.Code === 200) {
	        var material = new MaterialsSerializer().fromJSON(obj.Data.Data);
	        app.call(`selectMaterial`, this, material);
	      }
	    });
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Material',
	      typeName: _t('Material'),
	      data,
	      saveUrl: `${app.options.server}/api/Material/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Material/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code === 200) {
	              this.update();
	            }

	            app.toast(_t(obj.Msg));
	          });
	        });
	      }
	    });
	  }

	}

	MaterialPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	MaterialPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 音频面板
	 * @author tengge / https://github.com/tengge1
	 */

	class AudioPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleAdd = this.handleAdd.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'audio' // cornerText: n.Type,

	      });
	    });
	    return React.createElement("div", {
	      className: bind('AudioPanel', className),
	      style: style
	    }, React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      onAdd: this.handleAdd,
	      onInput: this.handleSearch.bind(this)
	    }), React.createElement(ImageList, {
	      data: imageListData,
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate(prevProps, prevState) {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?type=Audio`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Audio/List`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories, event) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    app.call(`selectAudio`, this, data);
	  } // ------------------------------- 上传 ---------------------------------------


	  handleAdd() {
	    app.upload(`${app.options.server}/api/Audio/Add`, obj => {
	      if (obj.Code === 200) {
	        this.update();
	      }

	      app.toast(_t(obj.Msg));
	    });
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Audio',
	      typeName: _t('Audio'),
	      data,
	      saveUrl: `${app.options.server}/api/Audio/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Audio/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code === 200) {
	              this.update();
	            }

	            app.toast(_t(obj.Msg));
	          });
	        });
	      }
	    });
	  }

	}

	AudioPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	AudioPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 动画面板
	 * @author tengge / https://github.com/tengge1
	 */

	class AnimationPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleAdd = this.handleAdd.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'scenes' // cornerText: n.Type,

	      });
	    });
	    return React.createElement("div", {
	      className: bind('AnimationPanel', className),
	      style: style
	    }, React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      onAdd: this.handleAdd,
	      onInput: this.handleSearch.bind(this)
	    }), React.createElement(ImageList, {
	      data: imageListData,
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate(prevProps, prevState) {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?type=Animation`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Animation/List`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories, event) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    app.call(`selectAnimation`, this, data);
	  } // ------------------------------- 上传 ---------------------------------------


	  handleAdd() {
	    app.upload(`${app.options.server}/api/Animation/Add`, obj => {
	      if (obj.Code === 200) {
	        this.update();
	      }

	      app.toast(_t(obj.Msg));
	    });
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Animation',
	      typeName: _t('Animation'),
	      data,
	      saveUrl: `${app.options.server}/api/Animation/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Animation/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code === 200) {
	              this.update();
	            }

	            app.toast(_t(obj.Msg));
	          });
	        });
	      }
	    });
	  }

	}

	AnimationPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	AnimationPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 粒子面板
	 * @author tengge / https://github.com/tengge1
	 */

	class ParticlePanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'model',
	        cornerText: n.Type
	      });
	    });
	    return React.createElement("div", {
	      className: bind('ParticlePanel', className),
	      style: style
	    }, React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      addHidden: true,
	      onInput: this.handleSearch.bind(this)
	    }), React.createElement(ImageList, {
	      data: imageListData,
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate(prevProps, prevState) {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?type=Particle`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Particle/List`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories, event) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    Ajax.get(`${app.options.server}/api/Particle/Get?ID=${data.ID}`, result => {
	      var obj = JSON.parse(result);

	      if (obj.Code === 200) ;
	    });
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Particle',
	      typeName: _t('Particle'),
	      data,
	      saveUrl: `${app.options.server}/api/Particle/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Particle/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code === 200) {
	              this.update();
	            }

	            app.toast(_t(obj.Msg));
	          });
	        });
	      }
	    });
	  }

	}

	ParticlePanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	ParticlePanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 预设体面板
	 * @author tengge / https://github.com/tengge1
	 */

	class PrefabPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'model',
	        cornerText: n.Type
	      });
	    });
	    return React.createElement("div", {
	      className: bind('PrefabPanel', className),
	      style: style
	    }, React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      addHidden: true,
	      onInput: this.handleSearch.bind(this)
	    }), React.createElement(ImageList, {
	      data: imageListData,
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate(prevProps, prevState) {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?type=Prefab`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Prefab/List`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories, event) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    Ajax.get(`${app.options.server}/api/Prefab/Get?ID=${data.ID}`, result => {
	      var obj = JSON.parse(result);

	      if (obj.Code === 200) ;
	    });
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Prefab',
	      typeName: _t('Prefab'),
	      data,
	      saveUrl: `${app.options.server}/api/Prefab/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Prefab/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code === 200) {
	              this.update();
	            }

	            app.toast(_t(obj.Msg));
	          });
	        });
	      }
	    });
	  }

	}

	PrefabPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	PrefabPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 角色面板
	 * @author tengge / https://github.com/tengge1
	 */

	class CharacterPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'model',
	        cornerText: n.Type
	      });
	    });
	    return React.createElement("div", {
	      className: bind('CharacterPanel', className),
	      style: style
	    }, React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      addHidden: true,
	      onInput: this.handleSearch.bind(this)
	    }), React.createElement(ImageList, {
	      data: imageListData,
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate(prevProps, prevState) {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?type=Character`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Character/List`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories, event) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    Ajax.get(`${app.options.server}/api/Character/Get?ID=${data.ID}`, result => {
	      var obj = JSON.parse(result);

	      if (obj.Code === 200) ;
	    });
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Character',
	      typeName: _t('Character'),
	      data,
	      saveUrl: `${app.options.server}/api/Character/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Character/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code === 200) {
	              this.update();
	            }

	            app.toast(_t(obj.Msg));
	          });
	        });
	      }
	    });
	  }

	}

	CharacterPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	CharacterPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 截图面板
	 * @author tengge / https://github.com/tengge1
	 */

	class ScreenshotPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'scenes'
	      });
	    });
	    return React.createElement("div", {
	      className: bind('ScreenshotPanel', className),
	      style: style
	    }, React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      addHidden: true,
	      onInput: this.handleSearch.bind(this)
	    }), React.createElement(ImageList, {
	      data: imageListData,
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate(prevProps, prevState) {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?type=Screenshot`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Screenshot/List`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories, event) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    app.photo(data.Url);
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Screenshot',
	      typeName: _t('Screenshot'),
	      data,
	      saveUrl: `${app.options.server}/api/Screenshot/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Screenshot/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code === 200) {
	              this.update();
	            }

	            app.toast(_t(obj.Msg));
	          });
	        });
	      }
	    });
	  }

	}

	ScreenshotPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	ScreenshotPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 视频面板
	 * @author tengge / https://github.com/tengge1
	 */

	class VideoPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      data: [],
	      categoryData: [],
	      name: '',
	      categories: []
	    };
	    this.handleClick = this.handleClick.bind(this);
	    this.handleEdit = this.handleEdit.bind(this);
	    this.handleDelete = this.handleDelete.bind(this);
	    this.update = this.update.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      data,
	      categoryData,
	      name,
	      categories
	    } = this.state;
	    let list = data;

	    if (name.trim() !== '') {
	      list = list.filter(n => {
	        return n.Name.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.FirstPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1 || n.TotalPinYin.toLowerCase().indexOf(name.toLowerCase()) > -1;
	      });
	    }

	    if (categories.length > 0) {
	      list = list.filter(n => {
	        return categories.indexOf(n.CategoryID) > -1;
	      });
	    }

	    const imageListData = list.map(n => {
	      return Object.assign({}, n, {
	        id: n.ID,
	        src: n.Thumbnail ? `${app.options.server}${n.Thumbnail}` : null,
	        title: n.Name,
	        icon: 'scenes'
	      });
	    });
	    return React.createElement("div", {
	      className: bind('VideoPanel', className),
	      style: style
	    }, React.createElement(SearchField, {
	      data: categoryData,
	      placeholder: _t('Search Content'),
	      addHidden: true,
	      onInput: this.handleSearch.bind(this)
	    }), React.createElement(ImageList, {
	      data: imageListData,
	      onClick: this.handleClick,
	      onEdit: this.handleEdit,
	      onDelete: this.handleDelete
	    }));
	  }

	  componentDidUpdate(prevProps, prevState) {
	    if (this.init === undefined && this.props.show === true) {
	      this.init = true;
	      this.update();
	    }
	  }

	  update() {
	    fetch(`${app.options.server}/api/Category/List?type=Video`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          categoryData: obj.Data
	        });
	      });
	    });
	    fetch(`${app.options.server}/api/Video/List`).then(response => {
	      response.json().then(obj => {
	        this.setState({
	          data: obj.Data
	        });
	      });
	    });
	  }

	  handleSearch(name, categories, event) {
	    this.setState({
	      name,
	      categories
	    });
	  }

	  handleClick(data) {
	    app.video(data.Url);
	  } // ------------------------------- 编辑 ---------------------------------------


	  handleEdit(data) {
	    var win = app.createElement(EditWindow, {
	      type: 'Video',
	      typeName: _t('Video'),
	      data,
	      saveUrl: `${app.options.server}/api/Video/Edit`,
	      callback: this.update
	    });
	    app.addElement(win);
	  } // ------------------------------ 删除 ----------------------------------------


	  handleDelete(data) {
	    app.confirm({
	      title: _t('Confirm'),
	      content: `${_t('Delete')} ${data.title}?`,
	      onOK: () => {
	        fetch(`${app.options.server}/api/Video/Delete?ID=${data.id}`, {
	          method: 'POST'
	        }).then(response => {
	          response.json().then(obj => {
	            if (obj.Code === 200) {
	              this.update();
	            }

	            app.toast(_t(obj.Msg));
	          });
	        });
	      }
	    });
	  }

	}

	VideoPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	VideoPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 日志面板
	 * @author tengge / https://github.com/tengge1
	 */

	class LogPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      logs: []
	    };
	    this.handleLog = this.handleLog.bind(this);
	    this.handleClear = this.handleClear.bind(this);
	  }

	  render() {
	    const {
	      className,
	      style
	    } = this.props;
	    const {
	      logs
	    } = this.state;
	    return React.createElement("div", {
	      className: bind('LogPanel', className),
	      style: style
	    }, React.createElement(Button, {
	      onClick: this.handleClear
	    }, _t('Clear')), React.createElement("div", {
	      className: 'logs'
	    }, logs.map((n, i) => {
	      return React.createElement("div", {
	        className: n.type,
	        key: i
	      }, n.time, " ", n.content);
	    })));
	  }

	  componentDidMount() {
	    app.on(`log.LogPanel`, this.handleLog);
	  }

	  handleLog(content, type) {
	    var date = new Date();
	    var hour = date.getHours();
	    var minute = date.getMinutes();
	    var second = date.getSeconds();
	    hour = hour < 10 ? '0' + hour : hour;
	    minute = minute < 10 ? '0' + minute : minute;
	    second = second < 10 ? '0' + second : second;
	    this.setState(state => {
	      let logs = state.logs;
	      logs.push({
	        time: `${hour}:${minute}:${second}`,
	        type,
	        content
	      });
	      return {
	        logs
	      };
	    });
	  }

	  handleClear() {
	    this.setState({
	      logs: []
	    });
	  }

	}

	LogPanel.propTypes = {
	  className: propTypes.string,
	  style: propTypes.object,
	  show: propTypes.bool
	};
	LogPanel.defaultProps = {
	  className: null,
	  style: null,
	  show: false
	};

	/**
	 * 资源面板
	 * @author tengge / https://github.com/tengge1
	 */

	class AssetsPanel extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      activeIndex: 0,
	      sceneCount: 0,
	      meshCount: 0,
	      mapCount: 0,
	      materialCount: 0,
	      audioCount: 0,
	      animationCount: 0,
	      particleCount: 0,
	      prefabCount: 0,
	      characterCount: 0,
	      screenshotCount: 0,
	      videoCount: 0
	    };
	    this.handleActive = this.handleActive.bind(this);
	  }

	  render() {
	    const {
	      activeIndex,
	      sceneCount,
	      meshCount,
	      mapCount,
	      materialCount,
	      audioCount,
	      animationCount,
	      particleCount,
	      prefabCount,
	      characterCount,
	      screenshotCount,
	      videoCount
	    } = this.state;
	    return React.createElement(AccordionLayout, {
	      className: 'AssetsPanel',
	      onActive: this.handleActive
	    }, React.createElement(Accordion, {
	      name: 'Scene',
	      title: `${_t('Scene')}(${sceneCount})`,
	      maximizable: true
	    }, React.createElement(ScenePanel, {
	      className: 'subPanel',
	      show: 0 === activeIndex
	    })), React.createElement(Accordion, {
	      name: 'Model',
	      title: `${_t('Model')}(${meshCount})`,
	      maximizable: true
	    }, React.createElement(ModelPanel, {
	      className: 'subPanel',
	      show: 1 === activeIndex
	    })), React.createElement(Accordion, {
	      name: 'Map',
	      title: `${_t('Map')}(${mapCount})`,
	      maximizable: true
	    }, React.createElement(MapPanel, {
	      className: 'subPanel',
	      show: 2 === activeIndex
	    })), React.createElement(Accordion, {
	      name: 'Material',
	      title: `${_t('Material')}(${materialCount})`,
	      maximizable: true
	    }, React.createElement(MaterialPanel, {
	      className: 'subPanel',
	      show: 3 === activeIndex
	    })), React.createElement(Accordion, {
	      name: 'Audio',
	      title: `${_t('Audio')}(${audioCount})`,
	      maximizable: true
	    }, React.createElement(AudioPanel, {
	      className: 'subPanel',
	      show: 4 === activeIndex
	    })), React.createElement(Accordion, {
	      name: 'Animation',
	      title: `${_t('Animation')}(${animationCount})`,
	      maximizable: true
	    }, React.createElement(AnimationPanel, {
	      className: 'subPanel',
	      show: 5 === activeIndex
	    })), React.createElement(Accordion, {
	      name: 'Particle',
	      title: `${_t('Particle')}(${particleCount})`,
	      maximizable: true
	    }, React.createElement(ParticlePanel, {
	      className: 'subPanel',
	      show: 6 === activeIndex
	    })), React.createElement(Accordion, {
	      name: 'Prefab',
	      title: `${_t('Prefab')}(${prefabCount})`,
	      maximizable: true
	    }, React.createElement(PrefabPanel, {
	      className: 'subPanel',
	      show: 7 === activeIndex
	    })), React.createElement(Accordion, {
	      name: 'Screenshot',
	      title: `${_t('Screenshot')}(${screenshotCount})`,
	      maximizable: true
	    }, React.createElement(ScreenshotPanel, {
	      className: 'subPanel',
	      show: 8 === activeIndex
	    })), React.createElement(Accordion, {
	      name: 'Video',
	      title: `${_t('Video')}(${videoCount})`,
	      maximizable: true
	    }, React.createElement(VideoPanel, {
	      className: 'subPanel',
	      show: 9 === activeIndex
	    })), React.createElement(Accordion, {
	      name: 'Log',
	      title: `${_t('Logs')}`,
	      maximizable: true
	    }, React.createElement(LogPanel, {
	      className: 'subPanel',
	      show: 10 === activeIndex
	    })));
	  }

	  componentDidMount() {
	    this.update();
	  }

	  update() {
	    fetch(`${app.options.server}/api/Assets/List`).then(response => {
	      if (response.ok) {
	        response.json().then(json => {
	          this.setState(json);
	        });
	      }
	    });
	  }

	  handleActive(index, name) {
	    this.setState({
	      activeIndex: index
	    });
	  }

	}

	/**
	 * 历史记录
	 * @author dforrer / https://github.com/dforrer
	 * Developed as part of a project at University of Applied Sciences and Arts Northwestern Switzerland (www.fhnw.ch)
	 */

	function History(editor) {
	  this.editor = editor;
	  this.undos = [];
	  this.redos = [];
	  this.lastCmdTime = new Date();
	  this.idCounter = 0;
	  Command.call(this, editor);
	}
	History.prototype = Object.create(Command.prototype);
	Object.assign(History.prototype, {
	  constructor: History,
	  execute: function (cmd, optionalName) {
	    var lastCmd = this.undos[this.undos.length - 1];
	    var timeDifference = new Date().getTime() - this.lastCmdTime.getTime();
	    var isUpdatableCmd = lastCmd && lastCmd.updatable && cmd.updatable && lastCmd.object === cmd.object && lastCmd.type === cmd.type && lastCmd.script === cmd.script && lastCmd.attributeName === cmd.attributeName;

	    if (isUpdatableCmd && cmd.type === "SetScriptValueCommand") {
	      // When the cmd.type is "SetScriptValueCommand" the timeDifference is ignored
	      lastCmd.update(cmd);
	      cmd = lastCmd;
	    } else if (isUpdatableCmd && timeDifference < 500) {
	      lastCmd.update(cmd);
	      cmd = lastCmd;
	    } else {
	      // the command is not updatable and is added as a new part of the history
	      this.undos.push(cmd);
	      cmd.id = ++this.idCounter;
	    }

	    cmd.name = optionalName !== undefined ? optionalName : cmd.name;
	    cmd.execute();
	    cmd.inMemory = true;
	    this.lastCmdTime = new Date(); // clearing all the redo-commands

	    this.redos = [];
	    app.call('historyChanged', this, cmd);
	  },
	  undo: function () {
	    var cmd = undefined;

	    if (this.undos.length > 0) {
	      cmd = this.undos.pop();

	      if (cmd.inMemory === false) {
	        cmd.fromJSON(cmd.json);
	      }
	    }

	    if (cmd !== undefined) {
	      cmd.undo();
	      this.redos.push(cmd);
	      app.call('historyChanged', this, cmd);
	    }

	    return cmd;
	  },
	  redo: function () {
	    var cmd = undefined;

	    if (this.redos.length > 0) {
	      cmd = this.redos.pop();

	      if (cmd.inMemory === false) {
	        cmd.fromJSON(cmd.json);
	      }
	    }

	    if (cmd !== undefined) {
	      cmd.execute();
	      this.undos.push(cmd);
	      app.call('historyChanged', this, cmd);
	    }

	    return cmd;
	  },
	  toJSON: function () {
	    var history = {};
	    history.undos = [];
	    history.redos = []; // Append Undos to History

	    for (var i = 0; i < this.undos.length; i++) {
	      if (this.undos[i].hasOwnProperty("json")) {
	        history.undos.push(this.undos[i].json);
	      }
	    } // Append Redos to History


	    for (var i = 0; i < this.redos.length; i++) {
	      if (this.redos[i].hasOwnProperty("json")) {
	        history.redos.push(this.redos[i].json);
	      }
	    }

	    return history;
	  },
	  fromJSON: function (json) {
	    if (json === undefined) return;

	    for (var i = 0; i < json.undos.length; i++) {
	      var cmdJSON = json.undos[i];
	      var cmd = new window[cmdJSON.type](); // creates a new object of type "json.type"

	      cmd.json = cmdJSON;
	      cmd.id = cmdJSON.id;
	      cmd.name = cmdJSON.name;
	      this.undos.push(cmd);
	      this.idCounter = cmdJSON.id > this.idCounter ? cmdJSON.id : this.idCounter; // set last used idCounter
	    }

	    for (var i = 0; i < json.redos.length; i++) {
	      var cmdJSON = json.redos[i];
	      var cmd = new window[cmdJSON.type](); // creates a new object of type "json.type"

	      cmd.json = cmdJSON;
	      cmd.id = cmdJSON.id;
	      cmd.name = cmdJSON.name;
	      this.redos.push(cmd);
	      this.idCounter = cmdJSON.id > this.idCounter ? cmdJSON.id : this.idCounter; // set last used idCounter
	    } // Select the last executed undo-command


	    app.call('historyChanged', this, this.undos[this.undos.length - 1]);
	  },
	  clear: function () {
	    this.undos = [];
	    this.redos = [];
	    this.idCounter = 0;
	    app.call('historyChanged', this);
	  },
	  goToState: function (id) {
	    var cmd = this.undos.length > 0 ? this.undos[this.undos.length - 1] : undefined; // next cmd to pop

	    if (cmd === undefined || id > cmd.id) {
	      cmd = this.redo();

	      while (cmd !== undefined && id > cmd.id) {
	        cmd = this.redo();
	      }
	    } else {
	      while (true) {
	        cmd = this.undos[this.undos.length - 1]; // next cmd to pop

	        if (cmd === undefined || id === cmd.id) break;
	        cmd = this.undo();
	      }
	    }

	    app.call('historyChanged', this, cmd);
	  },
	  enableSerialization: function (id) {
	    /**
	     * because there might be commands in this.undos and this.redos
	     * which have not been serialized with .toJSON() we go back
	     * to the oldest command and redo one command after the other
	     * while also calling .toJSON() on them.
	     */
	    this.goToState(-1);
	    var cmd = this.redo();

	    while (cmd !== undefined) {
	      if (!cmd.hasOwnProperty("json")) {
	        cmd.json = cmd.toJSON();
	      }

	      cmd = this.redo();
	    }

	    this.goToState(id);
	  }
	});

	/**
	 * 网格帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function GridHelper(app) {
	  BaseHelper.call(this, app);
	}

	GridHelper.prototype = Object.create(BaseHelper.prototype);
	GridHelper.prototype.constructor = GridHelper;

	GridHelper.prototype.start = function () {
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	  this.update();
	};

	GridHelper.prototype.stop = function () {
	  app.on(`appStarted.${this.id}`, null);

	  if (this.helper) {
	    var scene = app.editor.sceneHelpers;
	    scene.remove(this.helper);
	    delete this.helper;
	  }
	};

	GridHelper.prototype.update = function () {
	  var showGrid = app.storage.get('showGrid');

	  if (!this.helper) {
	    this.helper = new THREE.GridHelper(30, 30, 0x444444, 0x888888);
	    var array = this.helper.geometry.attributes.color.array;

	    for (let i = 0; i < array.length; i += 60) {
	      for (let j = 0; j < 12; j++) {
	        array[i + j] = 0.26;
	      }
	    }
	  }

	  var scene = app.editor.sceneHelpers;

	  if (showGrid && this.helper.parent !== scene) {
	    scene.add(this.helper);
	  } else if (!showGrid && this.helper.parent === scene) {
	    scene.remove(this.helper);
	  }
	};

	GridHelper.prototype.onStorageChanged = function (key, value) {
	  if (key === 'showGrid') {
	    this.update();
	  }
	};

	/**
	 * 相机帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function CameraHelper(app) {
	  BaseHelper.call(this, app);
	}

	CameraHelper.prototype = Object.create(BaseHelper.prototype);
	CameraHelper.prototype.constructor = CameraHelper;

	CameraHelper.prototype.start = function () {
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	  this.update();
	};

	CameraHelper.prototype.stop = function () {
	  app.on(`appStarted.${this.id}`, null);

	  if (this.helper) {
	    var scene = app.editor.sceneHelpers;
	    scene.remove(this.helper);
	    delete this.helper;
	  }
	};

	CameraHelper.prototype.update = function () {
	  var showCamera = app.storage.get('showCamera');

	  if (!this.helper) {
	    this.helper = new THREE.CameraHelper(app.editor.camera);
	  }

	  var scene = app.editor.sceneHelpers;

	  if (showCamera && this.helper.parent !== scene) {
	    scene.add(this.helper);
	  } else if (!showCamera && this.helper.parent === scene) {
	    scene.remove(this.helper);
	  }
	};

	CameraHelper.prototype.onStorageChanged = function (key, value) {
	  if (key === 'showCamera') {
	    this.update();
	  }
	};

	/**
	 * 具有一定体积的点光源帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} light 
	 * @param {*} sphereSize 
	 * @param {*} color 
	 */
	function VolumePointLightHelper(light, sphereSize, color) {
	  THREE.PointLightHelper.call(this, light, sphereSize, color);
	  var geometry = new THREE.SphereBufferGeometry(2, 4, 2);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xff0000,
	    visible: false
	  });
	  this.picker = new THREE.Mesh(geometry, material);
	  this.picker.name = 'picker';
	  this.add(this.picker);
	}

	VolumePointLightHelper.prototype = Object.create(THREE.PointLightHelper.prototype);
	VolumePointLightHelper.prototype.constructor = VolumePointLightHelper;

	VolumePointLightHelper.prototype.raycast = function (raycaster, intersects) {
	  var intersect = raycaster.intersectObject(this.picker)[0];

	  if (intersect) {
	    intersect.object = this.light;
	    intersects.push(intersect);
	  }
	};

	VolumePointLightHelper.prototype.dispose = function () {
	  this.remove(this.picker);
	  this.picker.geometry.dispose();
	  this.picker.material.dispose();
	  delete this.picker;
	  THREE.PointLightHelper.prototype.dispose.call(this);
	};

	/**
	 * 点光源帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function PointLightHelpers(app) {
	  BaseHelper.call(this, app);
	  this.helpers = [];
	}

	PointLightHelpers.prototype = Object.create(BaseHelper.prototype);
	PointLightHelpers.prototype.constructor = PointLightHelpers;

	PointLightHelpers.prototype.start = function () {
	  app.on(`objectAdded.${this.id}`, this.onObjectAdded.bind(this));
	  app.on(`objectRemoved.${this.id}`, this.onObjectRemoved.bind(this));
	  app.on(`objectChanged.${this.id}`, this.onObjectChanged.bind(this));
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	};

	PointLightHelpers.prototype.stop = function () {
	  app.on(`objectAdded.${this.id}`, null);
	  app.on(`objectRemoved.${this.id}`, null);
	  app.on(`objectChanged.${this.id}`, null);
	  app.on(`storageChanged.${this.id}`, null);
	};

	PointLightHelpers.prototype.onObjectAdded = function (object) {
	  if (!object.isPointLight) {
	    return;
	  }

	  var helper = new VolumePointLightHelper(object, 1);
	  helper.visible = app.storage.get('showPointLight');
	  this.helpers.push(helper);
	  app.editor.sceneHelpers.add(helper);
	};

	PointLightHelpers.prototype.onObjectRemoved = function (object) {
	  if (!object.isPointLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  app.editor.sceneHelpers.remove(this.helpers[index]);
	  this.helpers[index].dispose();
	  this.helpers.splice(index, 1);
	};

	PointLightHelpers.prototype.onObjectChanged = function (object) {
	  if (!object.isPointLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  this.helpers[index].update();
	};

	PointLightHelpers.prototype.onStorageChanged = function (key, value) {
	  if (key !== 'showPointLight') {
	    return;
	  }

	  this.helpers.forEach(n => {
	    n.visible = value;
	  });
	};

	/**
	 * 具有一定体积的平行光帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} light 
	 * @param {*} size 
	 * @param {*} color 
	 */
	function VolumeDirectionalLightHelper(light, size, color) {
	  THREE.DirectionalLightHelper.call(this, light, size, color);
	  var geometry = new THREE.SphereBufferGeometry(2, 4, 2);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xff0000,
	    visible: false
	  });
	  this.picker = new THREE.Mesh(geometry, material);
	  this.picker.name = 'picker';
	  this.add(this.picker);
	}

	VolumeDirectionalLightHelper.prototype = Object.create(THREE.DirectionalLightHelper.prototype);
	VolumeDirectionalLightHelper.prototype.constructor = VolumeDirectionalLightHelper;

	VolumeDirectionalLightHelper.prototype.raycast = function (raycaster, intersects) {
	  var intersect = raycaster.intersectObject(this.picker)[0];

	  if (intersect) {
	    intersect.object = this.light;
	    intersects.push(intersect);
	  }
	};

	VolumeDirectionalLightHelper.prototype.dispose = function () {
	  this.remove(this.picker);
	  this.picker.geometry.dispose();
	  this.picker.material.dispose();
	  delete this.picker;
	  THREE.DirectionalLightHelper.prototype.dispose.call(this);
	};

	/**
	 * 平行光帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function DirectionalLightHelpers(app) {
	  BaseHelper.call(this, app);
	  this.helpers = [];
	}

	DirectionalLightHelpers.prototype = Object.create(BaseHelper.prototype);
	DirectionalLightHelpers.prototype.constructor = DirectionalLightHelpers;

	DirectionalLightHelpers.prototype.start = function () {
	  app.on(`objectAdded.${this.id}`, this.onObjectAdded.bind(this));
	  app.on(`objectRemoved.${this.id}`, this.onObjectRemoved.bind(this));
	  app.on(`objectChanged.${this.id}`, this.onObjectChanged.bind(this));
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	};

	DirectionalLightHelpers.prototype.stop = function () {
	  app.on(`objectAdded.${this.id}`, null);
	  app.on(`objectRemoved.${this.id}`, null);
	  app.on(`objectChanged.${this.id}`, null);
	  app.on(`storageChanged.${this.id}`, null);
	};

	DirectionalLightHelpers.prototype.onObjectAdded = function (object) {
	  if (!object.isDirectionalLight) {
	    return;
	  }

	  var helper = new VolumeDirectionalLightHelper(object, 1);
	  helper.visible = app.storage.get('showDirectionalLight');
	  this.helpers.push(helper);
	  app.editor.sceneHelpers.add(helper);
	};

	DirectionalLightHelpers.prototype.onObjectRemoved = function (object) {
	  if (!object.isDirectionalLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  app.editor.sceneHelpers.remove(this.helpers[index]);
	  this.helpers[index].dispose();
	  this.helpers.splice(index, 1);
	};

	DirectionalLightHelpers.prototype.onObjectChanged = function (object) {
	  if (!object.isDirectionalLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  this.helpers[index].update();
	};

	DirectionalLightHelpers.prototype.onStorageChanged = function (key, value) {
	  if (key !== 'showDirectionalLight') {
	    return;
	  }

	  this.helpers.forEach(n => {
	    n.visible = value;
	  });
	};

	/**
	 * 具有一定体积的半球光帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} light 
	 * @param {*} size 
	 * @param {*} color 
	 */
	function VolumeHemisphereLightHelper(light, size, color) {
	  THREE.HemisphereLightHelper.call(this, light, size, color);
	  var geometry = new THREE.SphereBufferGeometry(2, 4, 2);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xff0000,
	    visible: false
	  });
	  this.picker = new THREE.Mesh(geometry, material);
	  this.picker.name = 'picker';
	  this.add(this.picker);
	}

	VolumeHemisphereLightHelper.prototype = Object.create(THREE.HemisphereLightHelper.prototype);
	VolumeHemisphereLightHelper.prototype.constructor = VolumeHemisphereLightHelper;

	VolumeHemisphereLightHelper.prototype.raycast = function (raycaster, intersects) {
	  var intersect = raycaster.intersectObject(this.picker)[0];

	  if (intersect) {
	    intersect.object = this.light;
	    intersects.push(intersect);
	  }
	};

	VolumeHemisphereLightHelper.prototype.dispose = function () {
	  this.remove(this.picker);
	  this.picker.geometry.dispose();
	  this.picker.material.dispose();
	  delete this.picker;
	  THREE.HemisphereLightHelper.prototype.dispose.call(this);
	};

	/**
	 * 半球光帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function HemisphereLightHelpers(app) {
	  BaseHelper.call(this, app);
	  this.helpers = [];
	}

	HemisphereLightHelpers.prototype = Object.create(BaseHelper.prototype);
	HemisphereLightHelpers.prototype.constructor = HemisphereLightHelpers;

	HemisphereLightHelpers.prototype.start = function () {
	  app.on(`objectAdded.${this.id}`, this.onObjectAdded.bind(this));
	  app.on(`objectRemoved.${this.id}`, this.onObjectRemoved.bind(this));
	  app.on(`objectChanged.${this.id}`, this.onObjectChanged.bind(this));
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	};

	HemisphereLightHelpers.prototype.stop = function () {
	  app.on(`objectAdded.${this.id}`, null);
	  app.on(`objectRemoved.${this.id}`, null);
	  app.on(`objectChanged.${this.id}`, null);
	  app.on(`storageChanged.${this.id}`, null);
	};

	HemisphereLightHelpers.prototype.onObjectAdded = function (object) {
	  if (!object.isHemisphereLight) {
	    return;
	  }

	  var helper = new VolumeHemisphereLightHelper(object, 1);
	  helper.visible = app.storage.get('showHemisphereLight');
	  this.helpers.push(helper);
	  app.editor.sceneHelpers.add(helper);
	};

	HemisphereLightHelpers.prototype.onObjectRemoved = function (object) {
	  if (!object.isHemisphereLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  app.editor.sceneHelpers.remove(this.helpers[index]);
	  this.helpers[index].dispose();
	  this.helpers.splice(index, 1);
	};

	HemisphereLightHelpers.prototype.onObjectChanged = function (object) {
	  if (!object.isHemisphereLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  this.helpers[index].update();
	};

	HemisphereLightHelpers.prototype.onStorageChanged = function (key, value) {
	  if (key !== 'showHemisphereLight') {
	    return;
	  }

	  this.helpers.forEach(n => {
	    n.visible = value;
	  });
	};

	/**
	 * 具有一定体积的矩形光帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} light 
	 * @param {*} color 
	 */
	function VolumeRectAreaLightHelper(light, color) {
	  THREE.RectAreaLightHelper.call(this, light, color); // TODO: three.js bugs： 未设置矩形光帮助器矩阵

	  this.matrix = light.matrixWorld;
	  this.matrixAutoUpdate = false;
	  var geometry = new THREE.SphereBufferGeometry(2, 4, 2);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xff0000,
	    visible: false
	  });
	  this.picker = new THREE.Mesh(geometry, material);
	  this.picker.name = 'picker';
	  this.add(this.picker);
	}

	VolumeRectAreaLightHelper.prototype = Object.create(THREE.RectAreaLightHelper.prototype);
	VolumeRectAreaLightHelper.prototype.constructor = VolumeRectAreaLightHelper;

	VolumeRectAreaLightHelper.prototype.raycast = function (raycaster, intersects) {
	  var intersect = raycaster.intersectObject(this.picker)[0];

	  if (intersect) {
	    intersect.object = this.light;
	    intersects.push(intersect);
	  }
	};

	VolumeRectAreaLightHelper.prototype.dispose = function () {
	  this.remove(this.picker);
	  this.picker.geometry.dispose();
	  this.picker.material.dispose();
	  delete this.picker;
	  THREE.RectAreaLightHelper.prototype.dispose.call(this);
	};

	/**
	 * 矩形光帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function RectAreaLightHelpers(app) {
	  BaseHelper.call(this, app);
	  this.helpers = [];
	}

	RectAreaLightHelpers.prototype = Object.create(BaseHelper.prototype);
	RectAreaLightHelpers.prototype.constructor = RectAreaLightHelpers;

	RectAreaLightHelpers.prototype.start = function () {
	  app.on(`objectAdded.${this.id}`, this.onObjectAdded.bind(this));
	  app.on(`objectRemoved.${this.id}`, this.onObjectRemoved.bind(this));
	  app.on(`objectChanged.${this.id}`, this.onObjectChanged.bind(this));
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	};

	RectAreaLightHelpers.prototype.stop = function () {
	  app.on(`objectAdded.${this.id}`, null);
	  app.on(`objectRemoved.${this.id}`, null);
	  app.on(`objectChanged.${this.id}`, null);
	  app.on(`storageChanged.${this.id}`, null);
	};

	RectAreaLightHelpers.prototype.onObjectAdded = function (object) {
	  if (!object.isRectAreaLight) {
	    return;
	  }

	  var helper = new VolumeRectAreaLightHelper(object, 0xffffff);
	  helper.visible = app.storage.get('showRectAreaLight');
	  this.helpers.push(helper);
	  app.editor.sceneHelpers.add(helper);
	};

	RectAreaLightHelpers.prototype.onObjectRemoved = function (object) {
	  if (!object.isRectAreaLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  app.editor.sceneHelpers.remove(this.helpers[index]);
	  this.helpers[index].dispose();
	  this.helpers.splice(index, 1);
	};

	RectAreaLightHelpers.prototype.onObjectChanged = function (object) {
	  if (!object.isRectAreaLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  this.helpers[index].update();
	};

	RectAreaLightHelpers.prototype.onStorageChanged = function (key, value) {
	  if (key !== 'showRectAreaLight') {
	    return;
	  }

	  this.helpers.forEach(n => {
	    n.visible = value;
	  });
	};

	/**
	 * 具有一定体积的聚光灯帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} light 
	 * @param {*} color 
	 */
	function VolumeSpotLightHelper(light, color) {
	  THREE.SpotLightHelper.call(this, light, color);
	  var geometry = new THREE.SphereBufferGeometry(2, 4, 2);
	  var material = new THREE.MeshBasicMaterial({
	    color: 0xff0000,
	    visible: false
	  });
	  this.picker = new THREE.Mesh(geometry, material);
	  this.picker.name = 'picker';
	  this.add(this.picker);
	}

	VolumeSpotLightHelper.prototype = Object.create(THREE.SpotLightHelper.prototype);
	VolumeSpotLightHelper.prototype.constructor = VolumeSpotLightHelper;

	VolumeSpotLightHelper.prototype.raycast = function (raycaster, intersects) {
	  var intersect = raycaster.intersectObject(this.picker)[0];

	  if (intersect) {
	    intersect.object = this.light;
	    intersects.push(intersect);
	  }
	};

	VolumeSpotLightHelper.prototype.dispose = function () {
	  this.remove(this.picker);
	  this.picker.geometry.dispose();
	  this.picker.material.dispose();
	  delete this.picker;
	  THREE.SpotLightHelper.prototype.dispose.call(this);
	};

	/**
	 * 聚光灯帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function SpotLightHelpers(app) {
	  BaseHelper.call(this, app);
	  this.helpers = [];
	}

	SpotLightHelpers.prototype = Object.create(BaseHelper.prototype);
	SpotLightHelpers.prototype.constructor = SpotLightHelpers;

	SpotLightHelpers.prototype.start = function () {
	  app.on(`objectAdded.${this.id}`, this.onObjectAdded.bind(this));
	  app.on(`objectRemoved.${this.id}`, this.onObjectRemoved.bind(this));
	  app.on(`objectChanged.${this.id}`, this.onObjectChanged.bind(this));
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	};

	SpotLightHelpers.prototype.stop = function () {
	  app.on(`objectAdded.${this.id}`, null);
	  app.on(`objectRemoved.${this.id}`, null);
	  app.on(`objectChanged.${this.id}`, null);
	  app.on(`storageChanged.${this.id}`, null);
	};

	SpotLightHelpers.prototype.onObjectAdded = function (object) {
	  if (!object.isSpotLight) {
	    return;
	  }

	  var helper = new VolumeSpotLightHelper(object, 0xffffff);
	  helper.visible = app.storage.get('showSpotLight');
	  this.helpers.push(helper);
	  app.editor.sceneHelpers.add(helper);
	};

	SpotLightHelpers.prototype.onObjectRemoved = function (object) {
	  if (!object.isSpotLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  app.editor.sceneHelpers.remove(this.helpers[index]);
	  this.helpers[index].dispose();
	  this.helpers.splice(index, 1);
	};

	SpotLightHelpers.prototype.onObjectChanged = function (object) {
	  if (!object.isSpotLight) {
	    return;
	  }

	  var index = this.helpers.findIndex(n => {
	    return n.light === object;
	  });

	  if (index === -1) {
	    return;
	  }

	  this.helpers[index].update();
	};

	SpotLightHelpers.prototype.onStorageChanged = function (key, value) {
	  if (key !== 'showSpotLight') {
	    return;
	  }

	  this.helpers.forEach(n => {
	    n.visible = value;
	  });
	};

	var ArrowVertex = "precision highp float;\r\nprecision highp int;\r\n\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\n\r\nuniform mat4 modelViewMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform mat3 normalMatrix;\r\n\r\nuniform float domWidth;\r\nuniform float domHeight;\r\nuniform float size;\r\nuniform float z;\r\n\r\nvarying vec3 vPosition;\r\nvarying vec3 vNormal;\r\n\r\nvoid main() {\r\n    mat4 translateMatrix = mat4(\r\n        1.0, 0.0, 0.0, 0.0,\r\n        0.0, 1.0, 0.0, 0.0,\r\n        0.0, 0.0, 1.0, 0.0,\r\n        1.0 - size / domWidth, 1.0 - size / domHeight, 0.0, 1.0\r\n    );\r\n\r\n    mat4 _modelViewMatrix = modelViewMatrix;\r\n    _modelViewMatrix[3][0] = 0.0;\r\n    _modelViewMatrix[3][1] = 0.0;\r\n    _modelViewMatrix[3][2] = -z;\r\n    \r\n    vec4 mvPosition = _modelViewMatrix * vec4(position, 1.0);\r\n\r\n    gl_Position = translateMatrix * projectionMatrix * mvPosition;\r\n    \r\n    vPosition = vec3(mvPosition);\r\n    vNormal = normalize(normalMatrix * normal);\r\n}";

	var ArrowFragment = "precision highp float;\r\nprecision highp int;\r\n\r\nuniform mat4 viewMatrix;\r\n\r\nuniform vec3 color;\r\nuniform vec3 ambientColor;\r\nuniform vec3 lightPosition;\r\nuniform vec3 diffuseColor;\r\nuniform float shininess;\r\n\r\nvarying vec3 vPosition;\r\nvarying vec3 vNormal;\r\n\r\nvoid main() {\r\n    vec3 ambient = ambientColor * color;\r\n    \r\n    vec3 normal = normalize(vNormal);\r\n    vec3 vLightPosition = vec3(0.0, 0.0, 1.0);\r\n    vec3 lightDirection = normalize(vLightPosition - vPosition);\r\n    float dotL = max(dot(lightDirection, normal), 0.0);\r\n    vec3 diffuse = diffuseColor * dotL * color;\r\n\r\n    vec3 eyeDirection = normalize(- vPosition);\r\n    vec3 reflectionDirection = reflect(-lightDirection, normal);\r\n    float specularLightWeight = pow(max(dot(reflectionDirection, eyeDirection), 0.0), shininess);\r\n    vec3 specular = color * specularLightWeight;\r\n\r\n    gl_FragColor = vec4(ambient + diffuse + specular, 1.0);\r\n}";

	/**
	 * 视角帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function ViewHelper(app) {
	  BaseHelper.call(this, app);
	}

	ViewHelper.prototype = Object.create(BaseHelper.prototype);
	ViewHelper.prototype.constructor = ViewHelper;

	ViewHelper.prototype.start = function () {
	  this.scene = new THREE.Scene();
	  let show = app.storage.get('showViewHelper');

	  if (show === undefined) {
	    show = true;
	    app.storage.set('showViewHelper', true);
	  }

	  this.show = show;
	  this.mesh = this.createMesh();
	  this.scene.add(this.mesh);
	  app.on(`storageChanged.${this.id}`, this.onStorageChanged.bind(this));
	  app.on(`afterRender.${this.id}`, this.onAfterRender.bind(this)); // app.on(`mousedown.${this.id}`, this.onMouseDown.bind(this));

	  app.on(`resize.${this.id}`, this.onResize.bind(this));
	};

	ViewHelper.prototype.stop = function () {
	  this.scene.remove(this.mesh);
	  delete this.scene;
	  delete this.mesh;
	  app.on(`storageChanged.${this.id}`, null);
	  app.on(`afterRender.${this.id}`, null); // app.on(`mousedown.${this.id}`, null);

	  app.on(`resize.${this.id}`, null);
	};

	ViewHelper.prototype.createMesh = function () {
	  var geometry = new THREE.ConeBufferGeometry(0.25, 1.0, 16, 16);
	  geometry.computeBoundingBox();
	  geometry.translate(0, geometry.boundingBox.min.y, 0);
	  var geometryPX = geometry.clone();
	  geometryPX.rotateZ(Math.PI / 2);
	  var geometryNX = geometry.clone();
	  geometryNX.rotateZ(-Math.PI / 2);
	  var geometryPY = geometry.clone();
	  geometryPY.rotateX(Math.PI);
	  var geometryNY = geometry.clone();
	  var geometryPZ = geometry.clone();
	  geometryPZ.rotateX(-Math.PI / 2);
	  var geometryNZ = geometry.clone();
	  geometryNZ.rotateX(Math.PI / 2);
	  geometry = THREE.BufferGeometryUtils.mergeBufferGeometries([geometryPX, geometryNX, geometryPY, geometryNY, geometryPZ, geometryNZ], true);
	  var domElement = app.editor.renderer.domElement;
	  var domWidth = domElement.clientWidth;
	  var domHeight = domElement.clientHeight;
	  this.z = 16; // 控件中心到相机距离，越远越小

	  var fov = app.editor.camera.fov;
	  var top = this.z * Math.tan(fov * Math.PI / 180 * 0.5); // 到相机垂直距离为z的地方屏幕高度一半

	  this.size = (domHeight / (2 * top) + 12) * 2; // 12为留白

	  var uniforms = {
	    domWidth: {
	      type: 'f',
	      value: domWidth
	    },
	    domHeight: {
	      type: 'f',
	      value: domHeight
	    },
	    size: {
	      type: 'f',
	      value: this.size
	    },
	    z: {
	      type: 'f',
	      value: this.z
	    },
	    color: {
	      type: 'v3',
	      value: new THREE.Vector3(1.0, 0.0, 0.0)
	    },
	    ambientColor: {
	      type: 'v3',
	      value: new THREE.Vector3(0.4, 0.4, 0.4)
	    },
	    lightPosition: {
	      type: 'v3',
	      value: new THREE.Vector3(10, 10, 10)
	    },
	    diffuseColor: {
	      type: 'v3',
	      value: new THREE.Vector3(1.0, 1.0, 1.0)
	    },
	    shininess: {
	      type: 'float',
	      value: 30
	    }
	  };
	  var material1 = new THREE.RawShaderMaterial({
	    uniforms: THREE.UniformsUtils.clone(uniforms),
	    vertexShader: ArrowVertex,
	    fragmentShader: ArrowFragment
	  });
	  var material2 = material1.clone();
	  material2.uniforms.color.value = new THREE.Vector3(0.5, 0.5, 0.5);
	  var material3 = material1.clone();
	  material3.uniforms.color.value = new THREE.Vector3(0.0, 1.0, 0.0);
	  var material4 = material1.clone();
	  material4.uniforms.color.value = new THREE.Vector3(0.5, 0.5, 0.5);
	  var material5 = material1.clone();
	  material5.uniforms.color.value = new THREE.Vector3(0.0, 0.0, 1.0);
	  var material6 = material1.clone();
	  material6.uniforms.color.value = new THREE.Vector3(0.5, 0.5, 0.5);
	  return new THREE.Mesh(geometry, [material1, material2, material3, material4, material5, material6]);
	};

	ViewHelper.prototype.onStorageChanged = function (key, value) {
	  if (key !== 'showViewHelper') {
	    return;
	  }

	  this.show = value;
	};

	ViewHelper.prototype.onAfterRender = function () {
	  if (!this.show) {
	    return;
	  }

	  if (!app.editor.showViewHelper) {
	    return;
	  }

	  let renderer = app.editor.renderer; // 最后绘制而且清空深度缓冲，保证视角控件不会被其他物体遮挡

	  renderer.clearDepth();
	  renderer.render(this.scene, app.editor.camera);
	};

	ViewHelper.prototype.onMouseDown = function (event) {
	  if (this.mouse === undefined) {
	    this.mouse = new THREE.Vector3();
	  }

	  if (this.raycaster === undefined) {
	    this.raycaster = new THREE.Raycaster();
	  }

	  var domElement = app.editor.renderer.domElement;
	  this.mouse.set(event.offsetX / domElement.clientWidth * 2 - 1, -event.offsetY / domElement.clientHeight * 2 + 1);
	  this.raycaster.setFromCamera(this.mouse, app.editor.camera); // 设置几何体矩阵，将其转换到左上角

	  if (this.matrix === undefined) {
	    this.matrix = new THREE.Matrix4();
	  }

	  this.matrix.copy(this.mesh.matrixWorld); // 旧：projectionMatrix * modelViewMatrix
	  // 新：translateMatrix * projectionMatrix * _modelViewMatrix
	  // matrixWorld = 

	  if (this.screenXY === undefined) {
	    this.screenXY = new THREE.Vector3();
	  }

	  this.screenXY.set((domElement.clientWidth - this.size / 2) / domElement.clientWidth * 2 - 1, -this.size / 2 / domElement.clientHeight * 2 + 1, -this.z);
	  this.screenXY.unproject(app.editor.camera);
	  var obj = this.raycaster.intersectObject(this.mesh)[0];
	  this.mesh.matrixWorld.copy(this.matrix);

	  if (obj) {
	    var materialIndex = obj.face.materialIndex;
	  }
	};

	ViewHelper.prototype.onResize = function () {
	  var materials = this.mesh.material;
	  var width = app.editor.renderer.domElement.width;
	  var height = app.editor.renderer.domElement.height;
	  var fov = app.editor.camera.fov;
	  var top = this.z * Math.tan(fov * Math.PI / 180 * 0.5); // 到相机垂直距离为z的地方屏幕高度一半

	  this.size = (height / (2 * top) + 12) * 2; // 12为留白

	  materials.forEach(n => {
	    n.uniforms.domWidth.value = width;
	    n.uniforms.domHeight.value = height;
	    n.uniforms.size.value = this.size;
	  });
	};

	var MaskVertex = "// https://github.com/mrdoob/three.js/blob/dev/examples/js/postprocessing/OutlinePass.js\r\n\r\nvoid main() {\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}";

	var MaskFragment = "// https://github.com/mrdoob/three.js/blob/dev/examples/js/postprocessing/OutlinePass.js\r\n\r\nvoid main() {\r\n    gl_FragColor = vec4(0.0, 1.0, 1.0, 1.0);\r\n}";

	var EdgeVertex = "varying vec2 vUv;\r\n\r\n// https://github.com/mrdoob/three.js/blob/dev/examples/js/postprocessing/OutlinePass.js\r\n\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}";

	var EdgeFragment = "uniform sampler2D maskTexture;\r\nuniform vec2 texSize;\r\nuniform vec3 color;\r\nuniform float thickness;\r\n\r\nvarying vec2 vUv;\r\n\r\n// https://github.com/mrdoob/three.js/blob/dev/examples/js/postprocessing/OutlinePass.js\r\n\r\nvoid main() {\r\n    vec2 invSize = thickness / texSize;\r\n    vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\r\n\r\n    vec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\r\n    vec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\r\n    vec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\r\n    vec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\r\n    \r\n    float diff1 = (c1.r - c2.r)*0.5;\r\n    float diff2 = (c3.r - c4.r)*0.5;\r\n    \r\n    float d = length( vec2(diff1, diff2) );\r\n    gl_FragColor = vec4(color, 1.0) * vec4(d);\r\n}";

	/**
	 * 选择帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function SelectHelper(app) {
	  BaseHelper.call(this, app);
	}

	SelectHelper.prototype = Object.create(BaseHelper.prototype);
	SelectHelper.prototype.constructor = SelectHelper;

	SelectHelper.prototype.start = function () {
	  app.on(`objectSelected.${this.id}`, this.onObjectSelected.bind(this));
	  app.on(`objectRemoved.${this.id}`, this.onObjectRemoved.bind(this));
	  app.on(`afterRender.${this.id}`, this.onAfterRender.bind(this));
	};

	SelectHelper.prototype.stop = function () {
	  app.on(`objectSelected.${this.id}`, null);
	  app.on(`afterRender.${this.id}`, null);
	};

	SelectHelper.prototype.onObjectSelected = function (obj) {
	  if (!obj) {
	    this.unselect();
	    return;
	  } // 进制选中场景和相机


	  if (obj === app.editor.scene || obj === app.editor.camera) {
	    return;
	  }

	  if (!this.size) {
	    this.size = new THREE.Vector2();
	  }

	  app.editor.renderer.getDrawingBufferSize(this.size);
	  var width = this.size.x;
	  var height = this.size.y;

	  if (this.scene === undefined) {
	    this.scene = new THREE.Scene();
	  }

	  if (this.camera === undefined) {
	    this.camera = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, 0, 1);
	    this.camera.position.z = 1;
	    this.camera.lookAt(new THREE.Vector3());
	  }

	  if (this.quad === undefined) {
	    this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(width, height), null);
	    this.quad.frustumCulled = false;
	    this.scene.add(this.quad);
	  }

	  var params = {
	    minFilter: THREE.LinearFilter,
	    magFilter: THREE.LinearFilter,
	    format: THREE.RGBAFormat,
	    antialias: true
	  };

	  if (this.maskBuffer === undefined) {
	    this.maskBuffer = new THREE.WebGLRenderTarget(width, height, params);
	    this.maskBuffer.texture.generateMipmaps = false;
	  }

	  if (this.edgeBuffer === undefined) {
	    this.edgeBuffer = new THREE.WebGLRenderTarget(width, height, params);
	    this.edgeBuffer.texture.generateMipmaps = false;
	  }

	  if (this.maskMaterial === undefined) {
	    this.maskMaterial = new THREE.ShaderMaterial({
	      vertexShader: MaskVertex,
	      fragmentShader: MaskFragment,
	      depthTest: false
	    });
	  }

	  if (this.edgeMaterial === undefined) {
	    this.edgeMaterial = new THREE.ShaderMaterial({
	      vertexShader: EdgeVertex,
	      fragmentShader: EdgeFragment,
	      uniforms: {
	        maskTexture: {
	          value: this.maskBuffer.texture
	        },
	        texSize: {
	          value: new THREE.Vector2(width, height)
	        },
	        color: {
	          value: new THREE.Vector3(1.0, 1.0, 1.0)
	        },
	        thickness: {
	          type: 'f',
	          value: 2
	        }
	      },
	      depthTest: false
	    });
	  }

	  if (this.copyMaterial === undefined) {
	    this.copyMaterial = new THREE.ShaderMaterial({
	      vertexShader: THREE.FXAAShader.vertexShader,
	      fragmentShader: THREE.FXAAShader.fragmentShader,
	      uniforms: {
	        tDiffuse: {
	          value: this.edgeBuffer.texture
	        },
	        resolution: {
	          value: new THREE.Vector2(1 / width, 1 / height)
	        }
	      },
	      blending: THREE.AdditiveBlending,
	      depthTest: false
	    });
	  }

	  this.object = obj;
	};

	SelectHelper.prototype.onObjectRemoved = function (object) {
	  if (object === this.object) {
	    this.unselect();
	  }
	};

	SelectHelper.prototype.unselect = function () {
	  if (this.object) {
	    delete this.object;
	  }
	};

	SelectHelper.prototype.onAfterRender = function () {
	  if (!this.object || !this.object.parent) {
	    // TODO: this.object.parent为null时表示该物体被移除
	    return;
	  }

	  var renderScene = app.editor.scene;
	  var renderCamera = app.editor.camera;
	  var renderer = app.editor.renderer;
	  var scene = this.scene;
	  var camera = this.camera;
	  var selected = this.object; // 记录原始状态

	  var oldOverrideMaterial = renderScene.overrideMaterial;
	  var oldBackground = renderScene.background;
	  var oldAutoClear = renderer.autoClear;
	  var oldClearColor = renderer.getClearColor();
	  var oldClearAlpha = renderer.getClearAlpha();
	  var oldRenderTarget = renderer.getRenderTarget(); // 绘制蒙版

	  this.hideNonSelectedObjects(renderScene, selected);
	  renderScene.overrideMaterial = this.maskMaterial;
	  renderScene.background = null;
	  renderer.autoClear = false;
	  renderer.setRenderTarget(this.maskBuffer);
	  renderer.setClearColor(0xffffff);
	  renderer.setClearAlpha(1);
	  renderer.clear();
	  renderer.render(renderScene, renderCamera);
	  this.showNonSelectedObjects(renderScene, selected); // 绘制边框

	  this.quad.material = this.edgeMaterial;
	  renderScene.overrideMaterial = null;
	  renderer.setRenderTarget(this.edgeBuffer);
	  renderer.clear();
	  renderer.render(scene, camera); // 与原场景叠加

	  this.quad.material = this.copyMaterial;
	  renderer.setRenderTarget(null);
	  renderer.render(scene, camera); // 还原原始状态

	  renderScene.overrideMaterial = oldOverrideMaterial;
	  renderScene.background = oldBackground;
	  renderer.autoClear = oldAutoClear;
	  renderer.setClearColor(oldClearColor);
	  renderer.setClearAlpha(oldClearAlpha);
	  renderer.setRenderTarget(oldRenderTarget);
	};

	SelectHelper.prototype.hideNonSelectedObjects = function (scene, selected) {
	  scene.traverse(obj => {
	    if (obj.isMesh && obj !== selected) {
	      obj.userData.oldVisible = obj.visible;
	      obj.visible = false;
	    }
	  });
	};

	SelectHelper.prototype.showNonSelectedObjects = function (scene, selected) {
	  scene.traverse(obj => {
	    if (obj.isMesh && obj !== selected && obj.userData.oldVisible) {
	      obj.visible = obj.userData.oldVisible;
	      delete obj.userData.oldVisible;
	    }
	  });
	};

	/**
	 * 所有帮助器
	 * @author tengge / https://github.com/tengge1
	 * @param {*} app 
	 */

	function Helpers(app) {
	  BaseHelper.call(this, app);
	  this.helpers = [new GridHelper(app), new CameraHelper(app), new PointLightHelpers(app), new DirectionalLightHelpers(app), new HemisphereLightHelpers(app), new RectAreaLightHelpers(app), new SpotLightHelpers(app), new SelectHelper(app), new ViewHelper(app), new SplineHelper(app)];
	}

	Helpers.prototype = Object.create(BaseHelper.prototype);
	Helpers.prototype.constructor = Helpers;

	Helpers.prototype.start = function () {
	  this.helpers.forEach(n => {
	    n.start();
	  });
	};

	Helpers.prototype.stop = function () {
	  this.helpers.forEach(n => {
	    n.stop();
	  });
	};

	const ComponentTypes = {
	  Button: Button$1,
	  Label: Label$1,
	  Panel: Panel$1,
	  HorizontalLine,
	  BarChart,
	  TimeLabel,
	  DateWeekLabel,
	  TimeDisk,
	  KeyValueLabel,
	  FormPanel,
	  Gauge,
	  Histogram,
	  LineChart,
	  SideBar,
	  Histogram2,
	  ScatterPlot,
	  PieChart,
	  ChordGraph,
	  ForceDirectedGraph,
	  TreeDiagram,
	  ClusterDiagram,
	  PackDiagram,
	  PartitionDiagram
	};
	/**
	 * 数据可视化
	 * @author tengge / https://github.com/tengge1
	 */

	function Visualization() {
	  BaseComponent.call(this);
	  this.components = [];
	}

	Visualization.prototype = Object.create(BaseComponent.prototype);
	Visualization.prototype.constructor = Visualization;
	/**
	 * 添加一个组件
	 * @param {BaseComponent} component 可视化组件
	 */

	Visualization.prototype.add = function (component) {
	  if (!(component instanceof BaseComponent)) {
	    console.warn(`Visualization: component is not an instance of BaseComponent.`);
	    return;
	  }

	  if (this.components.indexOf(component) > -1) {
	    console.warn(`Visualization: component has already added to the list.`);
	    return;
	  }

	  this.components.push(component);
	};
	/**
	 * 移除一个组件
	 * @param {BaseComponent} component 可视化组件
	 */


	Visualization.prototype.remove = function (component) {
	  if (!(component instanceof BaseComponent)) {
	    console.warn(`Visualization: component is not an instance of BaseComponent.`);
	    return;
	  }

	  var index = this.components.indexOf(component);

	  if (index === -1) {
	    console.warn(`Visualization: component does not exist in the list.`);
	    return;
	  }

	  this.components.splice(index, 1);
	};

	Visualization.prototype.get = function (id) {
	  var component = this.components.filter(n => {
	    return n.id === id;
	  })[0];

	  if (!component) {
	    console.warn(`Visualization: component#${id} is not defined.`);
	    return null;
	  }

	  return component;
	};
	/**
	 * 将所有控件渲染到svgDom里面
	 * @param {SVGSVGElement} svgDom SVG元素
	 */


	Visualization.prototype.render = function (svgDom) {
	  if (!(svgDom instanceof SVGSVGElement)) {
	    console.warn(`Visualization: svgDom is not an instance of SVGSVGElement.`);
	    return;
	  }

	  this.components.forEach(n => {
	    n.render(svgDom);
	  });
	};
	/**
	 * svg控件转json
	 */


	Visualization.prototype.toJSON = function () {
	  var list = [];
	  this.components.forEach(n => {
	    var jsons = n.toJSON();

	    if (Array.isArray(jsons)) {
	      list.push.apply(list, jsons);
	    } else if (jsons) {
	      list.push(jsons);
	    } else {
	      console.warn(`Visualization: ${n.id}.toJSON() result in null.`);
	    }
	  });
	  return list;
	};
	/**
	 * json转svg控件
	 * @param {Object} jsons JSON字符串序列后的对象
	 */


	Visualization.prototype.fromJSON = function (jsons) {
	  if (!Array.isArray(jsons)) {
	    console.warn(`Visualization: jsons is not an Array.`);
	    return;
	  }

	  this.clear();
	  jsons.forEach(n => {
	    var ctype = ComponentTypes[n.type];

	    if (ctype) {
	      var component = new ctype();
	      component.fromJSON(n);
	      this.add(component);
	    } else {
	      console.warn(`Visualization: there is no ComponentType named ${n.type}.`);
	    }
	  });
	};
	/**
	 * 清空组件
	 */


	Visualization.prototype.clear = function () {
	  this.components.forEach(n => {
	    n.clear();
	  });
	  this.components.length = 0;
	};

	/**
	 * @author qiao / https://github.com/qiao
	 * @author mrdoob / http://mrdoob.com
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	function EditorControls(object, domElement) {
	  domElement = domElement !== undefined ? domElement : document; // API

	  this.enabled = true;
	  this.center = new THREE.Vector3();
	  this.panSpeed = 0.002;
	  this.zoomSpeed = 0.1;
	  this.rotationSpeed = 0.005; // internals

	  var scope = this;
	  var vector = new THREE.Vector3();
	  var delta = new THREE.Vector3();
	  var box = new THREE.Box3();
	  var STATE = {
	    NONE: -1,
	    ROTATE: 0,
	    ZOOM: 1,
	    PAN: 2
	  };
	  var state = STATE.NONE;
	  var center = this.center;
	  var normalMatrix = new THREE.Matrix3();
	  var pointer = new THREE.Vector2();
	  var pointerOld = new THREE.Vector2();
	  var spherical = new THREE.Spherical();
	  var sphere = new THREE.Sphere(); // events

	  var changeEvent = {
	    type: 'change'
	  };

	  this.focus = function (target) {
	    var distance;
	    box.setFromObject(target);

	    if (box.isEmpty() === false) {
	      box.getCenter(center);
	      distance = box.getBoundingSphere(sphere).radius;
	    } else {
	      // Focusing on an Group, AmbientLight, etc
	      center.setFromMatrixPosition(target.matrixWorld);
	      distance = 0.1;
	    }

	    delta.set(0, 0, 1);
	    delta.applyQuaternion(object.quaternion);
	    delta.multiplyScalar(distance * 4);
	    object.position.copy(center).add(delta);
	    scope.dispatchEvent(changeEvent);
	  };

	  this.pan = function (delta) {
	    var distance = object.position.distanceTo(center);
	    delta.multiplyScalar(distance * scope.panSpeed);
	    delta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));
	    object.position.add(delta);
	    center.add(delta);
	    scope.dispatchEvent(changeEvent);
	  };

	  this.zoom = function (delta) {
	    var distance = object.position.distanceTo(center);
	    delta.multiplyScalar(distance * scope.zoomSpeed);
	    if (delta.length() > distance) return;
	    delta.applyMatrix3(normalMatrix.getNormalMatrix(object.matrix));
	    object.position.add(delta);
	    scope.dispatchEvent(changeEvent);
	  };

	  this.rotate = function (delta) {
	    vector.copy(object.position).sub(center);
	    spherical.setFromVector3(vector);
	    spherical.theta += delta.x * scope.rotationSpeed;
	    spherical.phi += delta.y * scope.rotationSpeed;
	    spherical.makeSafe();
	    vector.setFromSpherical(spherical);
	    object.position.copy(center).add(vector);
	    object.lookAt(center);
	    scope.dispatchEvent(changeEvent);
	  }; // mouse


	  function onMouseDown(event) {
	    if (scope.enabled === false) return;

	    if (event.button === 0) {
	      state = STATE.ROTATE;
	    } else if (event.button === 1) {
	      state = STATE.ZOOM;
	    } else if (event.button === 2) {
	      state = STATE.PAN;
	    }

	    pointerOld.set(event.clientX, event.clientY);
	    domElement.addEventListener('mousemove', onMouseMove, false);
	    domElement.addEventListener('mouseup', onMouseUp, false);
	    domElement.addEventListener('mouseout', onMouseUp, false);
	    domElement.addEventListener('dblclick', onMouseUp, false);
	  }

	  function onMouseMove(event) {
	    if (scope.enabled === false) return;
	    pointer.set(event.clientX, event.clientY);
	    var movementX = pointer.x - pointerOld.x;
	    var movementY = pointer.y - pointerOld.y;

	    if (state === STATE.ROTATE) {
	      scope.rotate(delta.set(-movementX, -movementY, 0));
	    } else if (state === STATE.ZOOM) {
	      scope.zoom(delta.set(0, 0, movementY));
	    } else if (state === STATE.PAN) {
	      scope.pan(delta.set(-movementX, movementY, 0));
	    }

	    pointerOld.set(event.clientX, event.clientY);
	  }

	  function onMouseUp(event) {
	    domElement.removeEventListener('mousemove', onMouseMove, false);
	    domElement.removeEventListener('mouseup', onMouseUp, false);
	    domElement.removeEventListener('mouseout', onMouseUp, false);
	    domElement.removeEventListener('dblclick', onMouseUp, false);
	    state = STATE.NONE;
	  }

	  function onMouseWheel(event) {
	    event.preventDefault(); // Normalize deltaY due to https://bugzilla.mozilla.org/show_bug.cgi?id=1392460

	    scope.zoom(delta.set(0, 0, event.deltaY > 0 ? 1 : -1));
	  }

	  function contextmenu(event) {
	    event.preventDefault();
	  }

	  this.dispose = function () {
	    domElement.removeEventListener('contextmenu', contextmenu, false);
	    domElement.removeEventListener('mousedown', onMouseDown, false);
	    domElement.removeEventListener('wheel', onMouseWheel, false);
	    domElement.removeEventListener('mousemove', onMouseMove, false);
	    domElement.removeEventListener('mouseup', onMouseUp, false);
	    domElement.removeEventListener('mouseout', onMouseUp, false);
	    domElement.removeEventListener('dblclick', onMouseUp, false);
	    domElement.removeEventListener('touchstart', touchStart, false);
	    domElement.removeEventListener('touchmove', touchMove, false);
	  };

	  domElement.addEventListener('contextmenu', contextmenu, false);
	  domElement.addEventListener('mousedown', onMouseDown, false);
	  domElement.addEventListener('wheel', onMouseWheel, false); // touch

	  var touches = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
	  var prevTouches = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
	  var prevDistance = null;

	  function touchStart(event) {
	    if (scope.enabled === false) return;

	    switch (event.touches.length) {
	      case 1:
	        touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0).divideScalar(window.devicePixelRatio);
	        touches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0).divideScalar(window.devicePixelRatio);
	        break;

	      case 2:
	        touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0).divideScalar(window.devicePixelRatio);
	        touches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0).divideScalar(window.devicePixelRatio);
	        prevDistance = touches[0].distanceTo(touches[1]);
	        break;
	    }

	    prevTouches[0].copy(touches[0]);
	    prevTouches[1].copy(touches[1]);
	  }

	  function touchMove(event) {
	    if (scope.enabled === false) return;
	    event.preventDefault();
	    event.stopPropagation();

	    function getClosest(touch, touches) {
	      var closest = touches[0];

	      for (var i in touches) {
	        if (closest.distanceTo(touch) > touches[i].distanceTo(touch)) closest = touches[i];
	      }

	      return closest;
	    }

	    switch (event.touches.length) {
	      case 1:
	        touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0).divideScalar(window.devicePixelRatio);
	        touches[1].set(event.touches[0].pageX, event.touches[0].pageY, 0).divideScalar(window.devicePixelRatio);
	        scope.rotate(touches[0].sub(getClosest(touches[0], prevTouches)).multiplyScalar(-1));
	        break;

	      case 2:
	        touches[0].set(event.touches[0].pageX, event.touches[0].pageY, 0).divideScalar(window.devicePixelRatio);
	        touches[1].set(event.touches[1].pageX, event.touches[1].pageY, 0).divideScalar(window.devicePixelRatio);
	        var distance = touches[0].distanceTo(touches[1]);
	        scope.zoom(delta.set(0, 0, prevDistance - distance));
	        prevDistance = distance;
	        var offset0 = touches[0].clone().sub(getClosest(touches[0], prevTouches));
	        var offset1 = touches[1].clone().sub(getClosest(touches[1], prevTouches));
	        offset0.x = -offset0.x;
	        offset1.x = -offset1.x;
	        scope.pan(offset0.add(offset1));
	        break;
	    }

	    prevTouches[0].copy(touches[0]);
	    prevTouches[1].copy(touches[1]);
	  }

	  domElement.addEventListener('touchstart', touchStart, false);
	  domElement.addEventListener('touchmove', touchMove, false);
	}
	EditorControls.prototype = Object.create(THREE.EventDispatcher.prototype);
	EditorControls.prototype.constructor = EditorControls;

	/**
	 * 编辑器
	 * @author tengge / https://github.com/tengge1
	 */

	class Editor extends React.Component {
	  constructor(props) {
	    super(props);
	    this.state = {
	      showMask: false,
	      maskText: _t('Waiting...'),
	      elements: []
	    };
	    this.type = 'scene'; // 编辑器类型：scene, mesh, texture, material, terrain, ai

	    this.onToggle = this.onToggle.bind(this);
	  }

	  render() {
	    const {
	      showMask,
	      maskText,
	      elements
	    } = this.state;
	    return React.createElement(React.Fragment, null, React.createElement(BorderLayout, {
	      className: 'Editor'
	    }, React.createElement(EditorMenuBar, {
	      region: 'north'
	    }), React.createElement(EditorStatusBar, {
	      region: 'south'
	    }), React.createElement(AssetsPanel, {
	      region: 'west',
	      split: true,
	      onToggle: this.onToggle
	    }), React.createElement(EditorSideBar, {
	      region: 'east',
	      split: true,
	      onToggle: this.onToggle
	    }), React.createElement(BorderLayout, {
	      region: 'center'
	    }, React.createElement(EditorToolbar, {
	      region: 'west'
	    }), React.createElement(Viewport, {
	      region: 'center'
	    }), React.createElement(TimelinePanel, {
	      region: 'south',
	      split: true,
	      onToggle: this.onToggle
	    }))), elements.map((n, i) => {
	      return React.createElement("div", {
	        key: i
	      }, n);
	    }), React.createElement(LoadMask, {
	      text: maskText,
	      show: showMask
	    }));
	  }

	  componentDidMount() {
	    app.editor = this; // 基础

	    this.history = new History(this); // 场景

	    this.scene = new THREE.Scene();
	    this.scene.name = _t('Scene');
	    this.scene.background = new THREE.Color(0xaaaaaa);
	    this.sceneHelpers = new THREE.Scene();
	    this.sceneID = null; // 当前场景ID

	    this.sceneName = null; // 当前场景名称

	    const width = app.viewport.clientWidth;
	    const height = app.viewport.clientHeight; // 相机

	    this.DEFAULT_CAMERA = new THREE.PerspectiveCamera(50, width / height, 0.1, 10000);
	    this.DEFAULT_CAMERA.name = _t('DefaultCamera');
	    this.DEFAULT_CAMERA.userData.isDefault = true;
	    this.DEFAULT_CAMERA.userData.control = 'OrbitControls'; // 场景控制类型

	    this.DEFAULT_CAMERA.position.set(20, 10, 20);
	    this.DEFAULT_CAMERA.lookAt(new THREE.Vector3()); // 视图

	    this.view = 'perspective'; // perspective, front, side, top
	    // 透视相机

	    this.camera = this.DEFAULT_CAMERA.clone(); // 正交相机

	    this.orthCamera = new THREE.OrthographicCamera(-width / 4, width / 4, height / 4, -height / 4, 0.1, 10000); // 渲染器

	    this.renderer = new THREE.WebGLRenderer({
	      antialias: true
	    });
	    this.renderer.gammaInput = false;
	    this.renderer.gammaOutput = false;
	    this.renderer.shadowMap.enabled = true;
	    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	    this.renderer.autoClear = false;
	    this.renderer.autoUpdateScene = false;
	    this.renderer.setPixelRatio(window.devicePixelRatio);
	    app.viewport.appendChild(this.renderer.domElement);
	    this.renderer.setSize(width, height); // 物体

	    this.objects = []; // 脚本 格式：{ uuid: { id: 'MongoDB _id', name: 'Script Name', type: 'Script Type', source: 'Source Code', uuid: 'uuid' }}
	    // 其中，uuid是创建脚本时自动生成，不可改变，关联时使用，id是mongo数据库ID字段；name：随便填写；type：javascript，vertexShader, fragmentShader, json；source：源码。

	    this.scripts = {}; // 动画格式：[{ id: 'MongoDB _id', uuid: 'uuid', layer: '动画层序号', layerName: '动画层名称', animations: '动画' }, ...]
	    // 其中，动画：[{ id: 'MongoDB _id', uuid: 'uuid', name: '动画名称', target: '动画对象uuid', type: '动画类型', beginTime: '开始时间(s)', endTime: '结束时间(s)', data: '动画参数' }, ...]
	    // 其中，uuid是创建脚本时自动生成，不可改变，关联时使用。
	    // 动画层序号：在时间面板显示位置，从0开始计算。
	    // 动画类型：Tween-补间动画，Skeletal-骨骼动画，Audio-音频播放，Shader-着色器动画，Filter-滤镜动画，Particle-粒子动画
	    // 动画参数：是一个字典，根据动画类型不同，参数也不同

	    this.animations = []; // 当前选中物体

	    this.selected = null; // 平移旋转缩放控件

	    this.transformControls = new THREE.TransformControls(this.camera, app.viewport);
	    this.sceneHelpers.add(this.transformControls); // 编辑器控件

	    this.controls = new EditorControls(this.camera, app.viewport); // 碰撞检测

	    this.raycaster = new THREE.Raycaster();
	    this.mouse = new THREE.Vector2(); // 帮助器场景灯光

	    var light = new THREE.DirectionalLight(0xffffff, 1.0);
	    light.position.z = 10;
	    this.sceneHelpers.add(light);
	    this.showViewHelper = true; // 可视化

	    this.svg = app.svgRef;
	    this.visual = new Visualization(); // 事件

	    app.on(`appStarted.Editor`, this.onAppStarted.bind(this));
	    app.on(`mousedown.Editor`, this.onMouseDown.bind(this));
	    app.on(`mousemove.Editor`, this.onMouseMove.bind(this));
	    app.on(`showMask.Editor`, this.onShowMask.bind(this)); // 帮助器

	    this.helpers = new Helpers(app);
	    app.call('appStart', this);
	    app.call('appStarted', this);
	    app.call('resize', this);
	    app.log(_t('Program started.'));
	  }

	  componentWillUnmount() {
	    app.call('appStop', this);
	    app.call('appStoped', this);
	    app.log(_t('Program stoped.'));
	    app.event.stop();
	  }

	  onAppStarted() {
	    this.helpers.start();
	    this.clear();
	    this._addAudioListener = this._addAudioListener.bind(this);
	    document.addEventListener('click', this._addAudioListener);
	  }

	  onToggle(expanded) {
	    app.call('resize', this);
	  } // -------------------- 场景 --------------------------


	  setScene(scene) {
	    // 设置场景
	    // 移除原有物体
	    var objects = this.scene.children;

	    while (objects.length > 0) {
	      this.removeObject(objects[0]);
	    } // 添加新物体


	    var children = scene.children.slice();
	    scene.children.length = 0;
	    this.scene = scene;
	    children.forEach(n => {
	      this.addObject(n);
	    });
	    app.call('sceneGraphChanged', this);
	  }

	  clear(addObject = true) {
	    // 清空场景
	    this.history.clear();
	    this.camera.copy(this.DEFAULT_CAMERA);

	    if (this.audioListener && this.camera.children.findIndex(o => o instanceof THREE.AudioListener) === -1) {
	      this.camera.add(this.audioListener);
	    }

	    if (this.scene.background instanceof THREE.Texture) {
	      this.scene.background = new THREE.Color(0xaaaaaa);
	    } else if (this.scene.background instanceof THREE.Color) {
	      this.scene.background.setHex(0xaaaaaa);
	    }

	    this.scene.fog = null;
	    this.deselect(); // 移除场景物体

	    var objects = this.scene.children;

	    while (objects.length > 0) {
	      this.removeObject(objects[0]);
	    }

	    this.scripts = {};
	    this.animations = [{
	      id: null,
	      uuid: THREE.Math.generateUUID(),
	      layer: 0,
	      layerName: _t('AnimLayer1'),
	      animations: []
	    }, {
	      id: null,
	      uuid: THREE.Math.generateUUID(),
	      layer: 1,
	      layerName: _t('AnimLayer2'),
	      animations: []
	    }, {
	      id: null,
	      uuid: THREE.Math.generateUUID(),
	      layer: 2,
	      layerName: _t('AnimLayer3'),
	      animations: []
	    }]; // 添加默认元素

	    if (addObject) {
	      var light1 = new THREE.AmbientLight(0xffffff, 0.24);
	      light1.name = _t('Ambient');
	      this.addObject(light1);
	      var light2 = new THREE.DirectionalLight(0xffffff, 0.56);
	      light2.name = _t('Directional');
	      light2.castShadow = true;
	      light2.position.set(5, 10, 7.5);
	      light2.shadow.radius = 0;
	      light2.shadow.mapSize.x = 2048;
	      light2.shadow.mapSize.y = 2048;
	      light2.shadow.camera.left = -20;
	      light2.shadow.camera.right = 20;
	      light2.shadow.camera.top = 20;
	      light2.shadow.camera.bottom = -20;
	      light2.shadow.camera.near = 0.1;
	      light2.shadow.camera.far = 500;
	      this.addObject(light2);
	    }

	    app.call('editorCleared', this);
	    app.call('scriptChanged', this);
	    app.call('animationChanged', this);
	  } // 点击编辑器时才添加AudioListener，避免警告信息


	  _addAudioListener() {
	    document.removeEventListener('click', this._addAudioListener);
	    this.audioListener = new THREE.AudioListener();
	    this.audioListener.name = _t('AudioListener');

	    if (this.camera.children.findIndex(o => o instanceof THREE.AudioListener) === -1) {
	      this.camera.add(this.audioListener);
	    }
	  } // ---------------------- 物体 ---------------------------


	  objectByUuid(uuid) {
	    // 根据uuid获取物体
	    return this.scene.getObjectByProperty('uuid', uuid, true);
	  }

	  addObject(object) {
	    // 添加物体
	    this.scene.add(object);
	    app.call('objectAdded', this, object);
	    app.call('sceneGraphChanged', this);
	  }

	  moveObject(object, parent, before) {
	    // 移动物体
	    if (parent === undefined) {
	      parent = this.scene;
	    }

	    parent.add(object); // sort children array

	    if (before !== undefined) {
	      var index = parent.children.indexOf(before);
	      parent.children.splice(index, 0, object);
	      parent.children.pop();
	    }

	    app.call('sceneGraphChanged', this);
	  }

	  removeObject(object) {
	    // 移除物体
	    if (object.parent === null) {
	      // 避免删除相机或场景
	      return;
	    }

	    object.parent.remove(object);
	    app.call('objectRemoved', this, object);
	    app.call('sceneGraphChanged', this);
	  } // ------------------------- 帮助 ------------------------------


	  addPhysicsHelper(helper) {
	    var geometry = new THREE.SphereBufferGeometry(2, 4, 2);
	    var material = new THREE.MeshBasicMaterial({
	      color: 0xff0000,
	      visible: false
	    });
	    var picker = new THREE.Mesh(geometry, material);
	    picker.name = 'picker';
	    picker.userData.object = helper.object;
	    helper.add(picker);
	    this.sceneHelpers.add(helper);
	    this.helpers[helper.object.id] = helper;
	    this.objects.push(picker);
	  }

	  removePhysicsHelper(helper) {
	    if (this.helpers[helper.object.id] !== undefined) {
	      var helper = this.helpers[helper.object.id];
	      helper.parent.remove(helper);
	      delete this.helpers[helper.object.id];
	      var objects = this.objects;
	      objects.splice(objects.indexOf(helper.getObjectByName('picker')), 1);
	    }
	  } // ------------------------ 脚本 ----------------------------


	  addScript(object, script) {
	    // 添加脚本
	    if (this.scripts[object.uuid] === undefined) {
	      this.scripts[object.uuid] = [];
	    }

	    this.scripts[object.uuid].push(script);
	    app.call('scriptAdded', this, script);
	  }

	  removeScript(object, script) {
	    // 移除脚本
	    if (this.scripts[object.uuid] === undefined) {
	      return;
	    }

	    var index = this.scripts[object.uuid].indexOf(script);

	    if (index !== -1) {
	      this.scripts[object.uuid].splice(index, 1);
	    }

	    app.call('scriptRemoved', this);
	  } // ------------------------ 选中事件 --------------------------------


	  select(object) {
	    // 选中物体
	    if (this.selected === object) {
	      return;
	    }

	    this.selected = object;

	    if (!object) {
	      this.transformControls.detach();
	    }

	    app.call('objectSelected', this, object);
	  }

	  selectById(id) {
	    // 根据id选中物体
	    if (id === this.camera.id) {
	      this.select(this.camera);
	      return;
	    }

	    this.select(this.scene.getObjectById(id, true));
	  }

	  selectByUuid(uuid) {
	    // 根据uuid选中物体
	    if (uuid === this.camera.uuid) {
	      this.select(this.camera);
	      return;
	    }

	    this.scene.traverse(child => {
	      if (child.uuid === uuid) {
	        this.select(child);
	      }
	    });
	  }

	  deselect() {
	    // 取消选中物体
	    this.select(null);
	  } // ---------------------- 焦点事件 --------------------------


	  focus(object) {
	    // 设置焦点
	    app.call('objectFocused', this, object);
	  }

	  focusById(id) {
	    // 根据id设置交点
	    var obj = this.scene.getObjectById(id, true);

	    if (obj) {
	      this.focus(obj);
	    }
	  }

	  focusByUUID(uuid) {
	    // 根据uuid设置焦点
	    if (uuid === this.camera.uuid) {
	      this.focus(this.camera);
	      return;
	    }

	    this.scene.traverse(child => {
	      if (child.uuid === uuid) {
	        this.focus(child);
	      }
	    });
	  } // ----------------------- 命令事件 --------------------------


	  execute(cmd, optionalName) {
	    // 执行事件
	    this.history.execute(cmd, optionalName);
	  }

	  undo() {
	    // 撤销事件
	    this.history.undo();
	  }

	  redo() {
	    // 重做事件
	    this.history.redo();
	  } // ---------------------- 碰撞检测 -----------------------------


	  onMouseDown(event) {
	    this.raycaster.setFromCamera(this.mouse, this.camera);
	    var intersect = this.raycaster.intersectObjects(this.scene.children, true)[0];

	    if (intersect) {
	      app.call(`intersect`, this, intersect, event);
	    }
	  }

	  onMouseMove(event) {
	    this.mouse.x = event.offsetX / this.renderer.domElement.clientWidth * 2 - 1;
	    this.mouse.y = -(event.offsetY / this.renderer.domElement.clientHeight) * 2 + 1;
	  } // ---------------------- 用户界面 --------------------------------


	  createElement(type, props = {}, children = undefined) {
	    let ref = React.createRef();
	    props.ref = ref;
	    return React.createElement(type, props, children);
	  }

	  addElement(element, callback) {
	    let elements = this.state.elements;
	    elements.push(element);
	    this.setState({
	      elements
	    }, callback);
	  }

	  removeElement(element, callback) {
	    let elements = this.state.elements;
	    let index = elements.findIndex(n => n === element || n.ref && n.ref.current === element);

	    if (index > -1) {
	      elements.splice(index, 1);
	    }

	    this.setState({
	      elements
	    }, callback);
	  }

	  onShowMask(enabled, text) {
	    this.setState({
	      showMask: enabled,
	      maskText: text || _t('Waiting...')
	    });
	  }

	}

	/**
	 * 应用程序
	 * @author mrdoob / http://mrdoob.com/
	 * @author tengge / https://github.com/tengge1
	 */

	function Application(container, options) {
	  // 容器
	  this.container = container;
	  this.width = this.container.clientWidth;
	  this.height = this.container.clientHeight;
	  window.app = this; // 配置

	  this.options = new Options(options); // 存储

	  this.storage = new Storage();
	  this.debug = this.storage.get('debug') || false; // 包管理器

	  this.packageManager = new PackageManager();
	  this.require = this.packageManager.require.bind(this.packageManager); // 事件

	  this.event = new EventDispatcher(this);
	  this.call = this.event.call.bind(this.event);
	  this.on = this.event.on.bind(this.event); // 加载语言包

	  if (!window._t) {
	    const loader = new LanguageLoader();
	    loader.load().then(() => {
	      this.ui = React.createElement(Editor); // TODO: 由于ammo.js升级，导致很多类库不兼容，所以只能这么写。

	      Ammo().then(AmmoLib => {
	        window.Ammo = AmmoLib;
	        this.event.start();
	        ReactDOM.render(this.ui, this.container);
	      });
	    });
	  }
	} // ----------------------- UI函数 ---------------------------------

	/**
	 * 创建元素
	 * @param {React.Component} type ReactComponent类型
	 * @param {Object} props ReactComponent属性
	 * @param {Object} children 子节点
	 */


	Application.prototype.createElement = function (type, props, children) {
	  return this.editor.createElement(type, props, children);
	};
	/**
	 * 添加元素
	 * @param {Object} element ReactElement元素
	 * @param {Function} callback 回调函数
	 */


	Application.prototype.addElement = function (element, callback) {
	  return this.editor.addElement(element, callback);
	};
	/**
	 * 移除元素
	 * @param {Object} element ReactElement元素
	 * @param {Function} callback 回调函数
	 */


	Application.prototype.removeElement = function (element, callback) {
	  return this.editor.removeElement(element, callback);
	};
	/**
	 * 弹窗一段时间消失的消息窗口
	 * @param {String} content 内容
	 */


	Application.prototype.toast = function (content) {
	  let component = this.createElement(Toast, undefined, content);
	  this.addElement(component);
	  setTimeout(() => {
	    this.removeElement(component);
	  }, 5000);
	};
	/**
	 * 提示窗口
	 * @param {Object} options 选项
	 * @param {String} options.title 标题
	 * @param {String} options.content 内容
	 * @param {String} options.className 样式类
	 * @param {Object} options.style 样式
	 * @param {Function} options.onOK 点击确定回调函数
	 * @param {Function} options.onClose 点击关闭回调函数
	 */


	Application.prototype.alert = function (options = {}) {
	  let {
	    title,
	    content,
	    className,
	    style,
	    onOK,
	    onClose
	  } = options;
	  let component;

	  let close = () => {
	    component && this.removeElement(component);
	  };

	  if (onOK === undefined && onClose === undefined) {
	    onOK = onClose = close;
	  } else if (onClose === undefined) {
	    onClose = onOK;
	  }

	  component = this.createElement(Alert, {
	    title,
	    okText: _t('OK'),
	    className,
	    style,
	    onOK,
	    onClose
	  }, content);
	  this.addElement(component);
	  return {
	    component,
	    close
	  };
	};
	/**
	 * 询问窗口
	 * @param {Object} options 选项
	 * @param {String} options.title 标题
	 * @param {String} options.content 内容
	 * @param {String} options.className 样式类
	 * @param {Object} options.style 样式
	 * @param {Function} options.onOK 点击确定回调函数
	 * @param {Function} options.onCancel 点击取消回调函数
	 */


	Application.prototype.confirm = function (options = {}) {
	  let {
	    title,
	    content,
	    className,
	    style,
	    onOK,
	    onCancel
	  } = options;
	  let component;

	  let close = () => {
	    component && this.removeElement(component);
	  };

	  let handleOK = () => {
	    if (onOK && onOK() !== false) {
	      close();
	    }
	  };

	  if (onCancel === undefined) {
	    onCancel = close;
	  }

	  component = this.createElement(Confirm, {
	    title,
	    okText: _t('OK'),
	    cancelText: _t('Cancel'),
	    className,
	    style,
	    onOK: handleOK,
	    onCancel,
	    onClose: onCancel
	  }, content);
	  this.addElement(component);
	  return {
	    component,
	    close
	  };
	};
	/**
	 * 输入窗口
	 * @param {Object} options 选项
	 * @param {String} options.title 标题
	 * @param {String} options.content 内容
	 * @param {String} options.className 样式类
	 * @param {Object} options.style 样式
	 * @param {String} options.value 默认值
	 * @param {Function} options.onOK 点击确定执行函数
	 * @param {Function} options.onClose 点击关闭执行函数
	 */


	Application.prototype.prompt = function (options = {}) {
	  let {
	    title,
	    content,
	    className,
	    style,
	    value,
	    onOK,
	    onClose
	  } = options;
	  let component;

	  let close = () => {
	    component && this.removeElement(component);
	  };

	  let handleOK = value => {
	    if (onOK && onOK(value) !== false) {
	      close();
	    }
	  };

	  if (onClose === undefined) {
	    onClose = close;
	  }

	  component = this.createElement(Prompt, {
	    title,
	    content,
	    className,
	    style,
	    value,
	    okText: _t('OK'),
	    onOK: handleOK,
	    onClose
	  });
	  this.addElement(component);
	  return {
	    component,
	    close
	  };
	};
	/**
	 * 显示加载器
	 * @param {*} text 加载器文本
	 */


	Application.prototype.mask = function (text) {
	  this.call('showMask', this, true, text);
	};
	/**
	 * 隐藏加载器
	 */


	Application.prototype.unmask = function () {
	  this.call('showMask', this, false);
	};
	/**
	 * 查看图片
	 * @param {String} url 地址
	 */


	Application.prototype.photo = function (url) {
	  let component = null;

	  let close = () => {
	    if (component) {
	      this.removeElement(component);
	      component = null;
	    }
	  };

	  component = this.createElement(Photo, {
	    url,
	    onClick: close
	  });
	  this.addElement(component);
	};
	/**
	 * 查看视频
	 * @param {String} url 地址
	 */


	Application.prototype.video = function (url) {
	  let component = null;

	  let close = () => {
	    if (component) {
	      this.removeElement(component);
	      component = null;
	    }
	  };

	  component = this.createElement(Video, {
	    url,
	    onClick: close
	  });
	  this.addElement(component);
	}; // -------------------- 工具函数  -----------------------

	/**
	 * 上传文件
	 * @param {Object} url 上传Url
	 * @param {String} callback 回调函数
	 */


	Application.prototype.upload = function () {
	  var input;
	  return function (url, callback) {
	    if (!input) {
	      input = document.createElement('input');
	      input.type = 'file';
	      input.style.display = 'none';
	      input.addEventListener('change', event => {
	        Ajax.post(url, {
	          file: event.target.files[0]
	        }, json => {
	          var obj = JSON.parse(json);

	          if (obj.Code === 200) {
	            callback(obj);
	          } else {
	            app.toast(obj.Msg);
	          }
	        });
	      });
	      document.body.appendChild(input);
	    }

	    input.click();
	  };
	}(); // ----------------------- 记录日志  --------------------------------


	Application.prototype.log = function (content) {
	  // 普通日志
	  this.call('log', this, content);
	};

	Application.prototype.warn = function (content) {
	  // 警告日志
	  this.call('log', this, content, 'warn');
	};

	Application.prototype.error = function (content) {
	  // 错误日志
	  this.call('log', this, content, 'error');
	};

	exports.Application = Application;
	exports.GeoUtils = GeoUtils;
	exports.LanguageLoader = LanguageLoader;
	exports.Options = Options;
	exports.Player = Player;
	exports.PropTypes = propTypes;
	exports.classNames = bind;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
